"use strict";(self.webpackChunkfederation_clients=self.webpackChunkfederation_clients||[]).push([["vendors-node_modules_pixi_assets_lib_index_mjs"],{"./node_modules/@pixi/assets/lib/index.mjs":(e,t,s)=>{s.d(t,{sP:()=>X,UR:()=>S,l2:()=>c,T9:()=>h,P7:()=>H,sH:()=>A,WO:()=>o,zD:()=>n,Y8:()=>te,mV:()=>M,sZ:()=>L,Qq:()=>z,MX:()=>K,pI:()=>q,GX:()=>J,dD:()=>N,YR:()=>V,Zq:()=>_,aP:()=>d,Dt:()=>R,Fj:()=>p,dE:()=>C,Pp:()=>j,fc:()=>u,mc:()=>$,eg:()=>v,jC:()=>ee});var a=s("./node_modules/@pixi/core/lib/index.mjs");const r={loader:a.Ag.LoadParser,resolver:a.Ag.ResolveParser,cache:a.Ag.CacheParser,detection:a.Ag.DetectionParser};a.XO.handle(a.Ag.Asset,(e=>{const t=e.ref;Object.entries(r).filter((([e])=>!!t[e])).forEach((([e,s])=>a.XO.add(Object.assign(t[e],{extension:t[e].extension??s}))))}),(e=>{const t=e.ref;Object.keys(r).filter((e=>!!t[e])).forEach((e=>a.XO.remove(t[e])))}));class i{constructor(e,t=!1){this._loader=e,this._assetList=[],this._isLoading=!1,this._maxConcurrent=1,this.verbose=t}add(e){e.forEach((e=>{this._assetList.push(e)})),this.verbose&&console.log("[BackgroundLoader] assets: ",this._assetList),this._isActive&&!this._isLoading&&this._next()}async _next(){if(this._assetList.length&&this._isActive){this._isLoading=!0;const e=[],t=Math.min(this._assetList.length,this._maxConcurrent);for(let s=0;s<t;s++)e.push(this._assetList.pop());await this._loader.load(e),this._isLoading=!1,this._next()}}get active(){return this._isActive}set active(e){this._isActive!==e&&(this._isActive=e,e&&!this._isLoading&&this._next())}}function o(e,t){const s=e.split("?")[0],r=a.Wp.path.extname(s).toLowerCase();return Array.isArray(t)?t.includes(r):r===t}const n=(e,t,s=!1)=>(Array.isArray(e)||(e=[e]),t?e.map((e=>"string"==typeof e||s?t(e):e)):e),c=new class{constructor(){this._parsers=[],this._cache=new Map,this._cacheMap=new Map}reset(){this._cacheMap.clear(),this._cache.clear()}has(e){return this._cache.has(e)}get(e){const t=this._cache.get(e);return t||console.warn(`[Assets] Asset id ${e} was not found in the Cache`),t}set(e,t){const s=n(e);let r;for(let e=0;e<this.parsers.length;e++){const a=this.parsers[e];if(a.test(t)){r=a.getCacheableAssets(s,t);break}}r||(r={},s.forEach((e=>{r[e]=t})));const i=Object.keys(r),o={cacheKeys:i,keys:s};if(s.forEach((e=>{this._cacheMap.set(e,o)})),i.forEach((e=>{this._cache.has(e)&&this._cache.get(e)!==t&&console.warn("[Cache] already has key:",e),this._cache.set(e,r[e])})),t instanceof a.gP){const e=t;s.forEach((t=>{e.baseTexture!==a.gP.EMPTY.baseTexture&&a.t5.addToCache(e.baseTexture,t),a.gP.addToCache(e,t)}))}}remove(e){if(!this._cacheMap.has(e))return void console.warn(`[Assets] Asset id ${e} was not found in the Cache`);const t=this._cacheMap.get(e);t.cacheKeys.forEach((e=>{this._cache.delete(e)})),t.keys.forEach((e=>{this._cacheMap.delete(e)}))}get parsers(){return this._parsers}},d=e=>!Array.isArray(e);class l{constructor(){this._parsers=[],this._parsersValidated=!1,this.parsers=new Proxy(this._parsers,{set:(e,t,s)=>(this._parsersValidated=!1,e[t]=s,!0)}),this.promiseCache={}}reset(){this._parsersValidated=!1,this.promiseCache={}}_getLoadPromiseAndParser(e,t){const s={promise:null,parser:null};return s.promise=(async()=>{let a=null,r=null;if(t.loadParser&&(r=this._parserHash[t.loadParser],r||console.warn(`[Assets] specified load parser "${t.loadParser}" not found while loading ${e}`)),!r){for(let s=0;s<this.parsers.length;s++){const a=this.parsers[s];if(a.load&&a.test?.(e,t,this)){r=a;break}}if(!r)return console.warn(`[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`),null}a=await r.load(e,t,this),s.parser=r;for(let e=0;e<this.parsers.length;e++){const r=this.parsers[e];r.parse&&r.parse&&await(r.testParse?.(a,t,this))&&(a=await r.parse(a,t,this)||a,s.parser=r)}return a})(),s}async load(e,t){this._parsersValidated||this._validateParsers();let s=0;const r={},i=d(e),o=n(e,(e=>({alias:[e],src:e}))),c=o.length,l=o.map((async e=>{const i=a.Wp.path.toAbsolute(e.src);if(!r[e.src])try{this.promiseCache[i]||(this.promiseCache[i]=this._getLoadPromiseAndParser(i,e)),r[e.src]=await this.promiseCache[i].promise,t&&t(++s/c)}catch(t){throw delete this.promiseCache[i],delete r[e.src],new Error(`[Loader.load] Failed to load ${i}.\n${t}`)}}));return await Promise.all(l),i?r[o[0].src]:r}async unload(e){const t=n(e,(e=>({alias:[e],src:e}))).map((async e=>{const t=a.Wp.path.toAbsolute(e.src),s=this.promiseCache[t];if(s){const a=await s.promise;delete this.promiseCache[t],s.parser?.unload?.(a,e,this)}}));await Promise.all(t)}_validateParsers(){this._parsersValidated=!0,this._parserHash=this._parsers.filter((e=>e.name)).reduce(((e,t)=>(e[t.name]&&console.warn(`[Assets] loadParser name conflict "${t.name}"`),{...e,[t.name]:t})),{})}}var h=(e=>(e[e.Low=0]="Low",e[e.Normal=1]="Normal",e[e.High=2]="High",e))(h||{});function A(e,t){if(Array.isArray(t)){for(const s of t)if(e.startsWith(`data:${s}`))return!0;return!1}return e.startsWith(`data:${t}`)}const p={extension:{type:a.Ag.LoadParser,priority:h.Low},name:"loadJson",test:e=>A(e,"application/json")||o(e,".json"),load:async e=>await(await a.W0.ADAPTER.fetch(e)).json()};a.XO.add(p);const u={name:"loadTxt",extension:{type:a.Ag.LoadParser,priority:h.Low},test:e=>A(e,"text/plain")||o(e,".txt"),load:async e=>await(await a.W0.ADAPTER.fetch(e)).text()};a.XO.add(u);const f=["normal","bold","100","200","300","400","500","600","700","800","900"],m=[".ttf",".otf",".woff",".woff2"],g=["font/ttf","font/otf","font/woff","font/woff2"],y=/^(--|-?[A-Z_])[0-9A-Z_-]*$/i;function _(e){const t=a.Wp.path.extname(e),s=a.Wp.path.basename(e,t).replace(/(-|_)/g," ").toLowerCase().split(" ").map((e=>e.charAt(0).toUpperCase()+e.slice(1)));let r=s.length>0;for(const e of s)if(!e.match(y)){r=!1;break}let i=s.join(" ");return r||(i=`"${i.replace(/[\\"]/g,"\\$&")}"`),i}const w=/^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/,v={extension:{type:a.Ag.LoadParser,priority:h.Low},name:"loadWebFont",test:e=>A(e,g)||o(e,m),async load(e,t){const s=a.W0.ADAPTER.getFontFaceSet();if(s){const a=[],i=t.data?.family??_(e),o=t.data?.weights?.filter((e=>f.includes(e)))??["normal"],n=t.data??{};for(let t=0;t<o.length;t++){const c=o[t],d=new FontFace(i,`url(${r=e,w.test(r)?r:encodeURI(r)})`,{...n,weight:c});await d.load(),s.add(d),a.push(d)}return 1===a.length?a[0]:a}var r;return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"),null},unload(e){(Array.isArray(e)?e:[e]).forEach((e=>a.W0.ADAPTER.getFontFaceSet().delete(e)))}};a.XO.add(v);let b=null;class P{constructor(){b||(b=URL.createObjectURL(new Blob(['(function() {\n  "use strict";\n  const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";\n  async function checkImageBitmap() {\n    try {\n      if (typeof createImageBitmap != "function")\n        return !1;\n      const imageBlob = await (await fetch(WHITE_PNG)).blob(), imageBitmap = await createImageBitmap(imageBlob);\n      return imageBitmap.width === 1 && imageBitmap.height === 1;\n    } catch {\n      return !1;\n    }\n  }\n  checkImageBitmap().then((result) => {\n    self.postMessage(result);\n  });\n})();\n'],{type:"application/javascript"}))),this.worker=new Worker(b)}}P.revokeObjectURL=function(){b&&(URL.revokeObjectURL(b),b=null)};let B=null;class k{constructor(){B||(B=URL.createObjectURL(new Blob(['(function() {\n  "use strict";\n  async function loadImageBitmap(url) {\n    const response = await fetch(url);\n    if (!response.ok)\n      throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n    const imageBlob = await response.blob();\n    return await createImageBitmap(imageBlob);\n  }\n  self.onmessage = async (event) => {\n    try {\n      const imageBitmap = await loadImageBitmap(event.data.data[0]);\n      self.postMessage({\n        data: imageBitmap,\n        uuid: event.data.uuid,\n        id: event.data.id\n      }, [imageBitmap]);\n    } catch (e) {\n      self.postMessage({\n        error: e,\n        uuid: event.data.uuid,\n        id: event.data.id\n      });\n    }\n  };\n})();\n'],{type:"application/javascript"}))),this.worker=new Worker(B)}}k.revokeObjectURL=function(){B&&(URL.revokeObjectURL(B),B=null)};let I,O=0;const x=new class{constructor(){this._initialized=!1,this._createdWorkers=0,this.workerPool=[],this.queue=[],this.resolveHash={}}isImageBitmapSupported(){return void 0!==this._isImageBitmapSupported||(this._isImageBitmapSupported=new Promise((e=>{const{worker:t}=new P;t.addEventListener("message",(s=>{t.terminate(),P.revokeObjectURL(),e(s.data)}))}))),this._isImageBitmapSupported}loadImageBitmap(e){return this._run("loadImageBitmap",[e])}async _initWorkers(){this._initialized||(this._initialized=!0)}getWorker(){void 0===I&&(I=navigator.hardwareConcurrency||4);let e=this.workerPool.pop();return!e&&this._createdWorkers<I&&(this._createdWorkers++,e=(new k).worker,e.addEventListener("message",(e=>{this.complete(e.data),this.returnWorker(e.target),this.next()}))),e}returnWorker(e){this.workerPool.push(e)}complete(e){void 0!==e.error?this.resolveHash[e.uuid].reject(e.error):this.resolveHash[e.uuid].resolve(e.data),this.resolveHash[e.uuid]=null}async _run(e,t){await this._initWorkers();const s=new Promise(((s,a)=>{this.queue.push({id:e,arguments:t,resolve:s,reject:a})}));return this.next(),s}next(){if(!this.queue.length)return;const e=this.getWorker();if(!e)return;const t=this.queue.pop(),s=t.id;this.resolveHash[O]={resolve:t.resolve,reject:t.reject},e.postMessage({data:t.arguments,uuid:O++,id:s})}};function L(e,t,s){e.resource.internal=!0;const r=new a.gP(e),i=()=>{delete t.promiseCache[s],c.has(s)&&c.remove(s)};return r.baseTexture.once("destroyed",(()=>{s in t.promiseCache&&(console.warn("[Assets] A BaseTexture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the BaseTexture."),i())})),r.once("destroyed",(()=>{e.destroyed||(console.warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."),i())})),r}const E=[".jpeg",".jpg",".png",".webp",".avif"],W=["image/jpeg","image/png","image/webp","image/avif"];async function R(e){const t=await a.W0.ADAPTER.fetch(e);if(!t.ok)throw new Error(`[loadImageBitmap] Failed to fetch ${e}: ${t.status} ${t.statusText}`);const s=await t.blob();return await createImageBitmap(s)}const j={name:"loadTextures",extension:{type:a.Ag.LoadParser,priority:h.High},config:{preferWorkers:!0,preferCreateImageBitmap:!0,crossOrigin:"anonymous"},test:e=>A(e,W)||o(e,E),async load(e,t,s){const r=globalThis.createImageBitmap&&this.config.preferCreateImageBitmap;let i;i=r?this.config.preferWorkers&&await x.isImageBitmapSupported()?await x.loadImageBitmap(e):await R(e):await new Promise(((t,s)=>{const a=new Image;a.crossOrigin=this.config.crossOrigin,a.src=e,a.complete?t(a):(a.onload=()=>t(a),a.onerror=e=>s(e))}));const o={...t.data};o.resolution??(o.resolution=a.Wp.getResolutionOfUrl(e)),r&&void 0===o.resourceOptions?.ownsImageBitmap&&(o.resourceOptions={...o.resourceOptions},o.resourceOptions.ownsImageBitmap=!0);const n=new a.t5(i,o);return n.resource.src=e,L(n,s,e)},unload(e){e.destroy(!0)}};a.XO.add(j);const C={extension:{type:a.Ag.LoadParser,priority:h.High},name:"loadSVG",test:e=>A(e,"image/svg+xml")||o(e,".svg"),testParse:async e=>a.$f.test(e),async parse(e,t,s){const r=new a.$f(e,t?.data?.resourceOptions);await r.load();const i=new a.t5(r,{resolution:a.Wp.getResolutionOfUrl(e),...t?.data});return i.resource.src=t.src,L(i,s,t.src)},load:async(e,t)=>(await a.W0.ADAPTER.fetch(e)).text(),unload:j.unload};a.XO.add(C);const F=[".mp4",".m4v",".webm",".ogv"],T=["video/mp4","video/webm","video/ogg"],$={name:"loadVideo",extension:{type:a.Ag.LoadParser,priority:h.High},config:{defaultAutoPlay:!0,defaultUpdateFPS:0,defaultLoop:!1,defaultMuted:!1,defaultPlaysinline:!0},test:e=>A(e,T)||o(e,F),async load(e,t,s){let r;const i=await(await a.W0.ADAPTER.fetch(e)).blob(),o=URL.createObjectURL(i);try{const i={autoPlay:this.config.defaultAutoPlay,updateFPS:this.config.defaultUpdateFPS,loop:this.config.defaultLoop,muted:this.config.defaultMuted,playsinline:this.config.defaultPlaysinline,...t?.data?.resourceOptions,autoLoad:!0},n=new a.A5(o,i);await n.load();const c=new a.t5(n,{alphaMode:await a.Wp.detectVideoAlphaMode(),resolution:a.Wp.getResolutionOfUrl(e),...t?.data});c.resource.src=e,r=L(c,s,e),r.baseTexture.once("destroyed",(()=>{URL.revokeObjectURL(o)}))}catch(e){throw URL.revokeObjectURL(o),e}return r},unload(e){e.destroy(!0)}};function U(e,t,s,a,r){const i=t[s];for(let o=0;o<i.length;o++){const n=i[o];s<t.length-1?U(e.replace(a[s],n),t,s+1,a,r):r.push(e.replace(a[s],n))}}function M(e){const t=e.match(/\{(.*?)\}/g),s=[];if(t){const a=[];t.forEach((e=>{const t=e.substring(1,e.length-1).split(",");a.push(t)})),U(e,a,0,t,s)}else s.push(e);return s}a.XO.add($);class D{constructor(){this._defaultBundleIdentifierOptions={connector:"-",createBundleAssetId:(e,t)=>`${e}${this._bundleIdConnector}${t}`,extractAssetIdFromBundle:(e,t)=>t.replace(`${e}${this._bundleIdConnector}`,"")},this._bundleIdConnector=this._defaultBundleIdentifierOptions.connector,this._createBundleAssetId=this._defaultBundleIdentifierOptions.createBundleAssetId,this._extractAssetIdFromBundle=this._defaultBundleIdentifierOptions.extractAssetIdFromBundle,this._assetMap={},this._preferredOrder=[],this._parsers=[],this._resolverHash={},this._bundles={}}setBundleIdentifier(e){if(this._bundleIdConnector=e.connector??this._bundleIdConnector,this._createBundleAssetId=e.createBundleAssetId??this._createBundleAssetId,this._extractAssetIdFromBundle=e.extractAssetIdFromBundle??this._extractAssetIdFromBundle,"bar"!==this._extractAssetIdFromBundle("foo",this._createBundleAssetId("foo","bar")))throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")}prefer(...e){e.forEach((e=>{this._preferredOrder.push(e),e.priority||(e.priority=Object.keys(e.params))})),this._resolverHash={}}set basePath(e){this._basePath=e}get basePath(){return this._basePath}set rootPath(e){this._rootPath=e}get rootPath(){return this._rootPath}get parsers(){return this._parsers}reset(){this.setBundleIdentifier(this._defaultBundleIdentifierOptions),this._assetMap={},this._preferredOrder=[],this._resolverHash={},this._rootPath=null,this._basePath=null,this._manifest=null,this._bundles={},this._defaultSearchParams=null}setDefaultSearchParams(e){if("string"==typeof e)this._defaultSearchParams=e;else{const t=e;this._defaultSearchParams=Object.keys(t).map((e=>`${encodeURIComponent(e)}=${encodeURIComponent(t[e])}`)).join("&")}}getAlias(e){const{alias:t,name:s,src:a,srcs:r}=e;return n(t||s||a||r,(e=>"string"==typeof e?e:Array.isArray(e)?e.map((e=>e?.src??e?.srcs??e)):e?.src||e?.srcs?e.src??e.srcs:e),!0)}addManifest(e){this._manifest&&console.warn("[Resolver] Manifest already exists, this will be overwritten"),this._manifest=e,e.bundles.forEach((e=>{this.addBundle(e.name,e.assets)}))}addBundle(e,t){const s=[];Array.isArray(t)?t.forEach((t=>{const a=t.src??t.srcs,r=t.alias??t.name;let i;if("string"==typeof r){const t=this._createBundleAssetId(e,r);s.push(t),i=[r,t]}else{const t=r.map((t=>this._createBundleAssetId(e,t)));s.push(...t),i=[...r,...t]}this.add({...t,alias:i,src:a})})):Object.keys(t).forEach((a=>{const r=[a,this._createBundleAssetId(e,a)];if("string"==typeof t[a])this.add({alias:r,src:t[a]});else if(Array.isArray(t[a]))this.add({alias:r,src:t[a]});else{const e=t[a],s=e.src??e.srcs;this.add({...e,alias:r,src:Array.isArray(s)?s:[s]})}s.push(...r)})),this._bundles[e]=s}add(e,t,s,r,i){const o=[];let c;"string"==typeof e||Array.isArray(e)&&"string"==typeof e[0]?(a.Wp.deprecation("7.2.0","Assets.add now uses an object instead of individual parameters.\nPlease use Assets.add({ alias, src, data, format, loadParser }) instead."),o.push({alias:e,src:t,data:s,format:r,loadParser:i})):Array.isArray(e)?o.push(...e):o.push(e),c=e=>{this.hasKey(e)&&console.warn(`[Resolver] already has key: ${e} overwriting`)},n(o).forEach((e=>{const{src:t,srcs:s}=e;let{data:a,format:r,loadParser:i}=e;const o=n(t||s).map((e=>"string"==typeof e?M(e):Array.isArray(e)?e:[e])),d=this.getAlias(e);Array.isArray(d)?d.forEach(c):c(d);const l=[];o.forEach((e=>{e.forEach((e=>{let t={};if("object"!=typeof e){t.src=e;for(let s=0;s<this._parsers.length;s++){const a=this._parsers[s];if(a.test(e)){t=a.parse(e);break}}}else a=e.data??a,r=e.format??r,i=e.loadParser??i,t={...t,...e};if(!d)throw new Error(`[Resolver] alias is undefined for this asset: ${t.src}`);t=this.buildResolvedAsset(t,{aliases:d,data:a,format:r,loadParser:i}),l.push(t)}))})),d.forEach((e=>{this._assetMap[e]=l}))}))}resolveBundle(e){const t=d(e);e=n(e);const s={};return e.forEach((e=>{const t=this._bundles[e];if(t){const a=this.resolve(t),r={};for(const t in a){const s=a[t];r[this._extractAssetIdFromBundle(e,t)]=s}s[e]=r}})),t?s[e[0]]:s}resolveUrl(e){const t=this.resolve(e);if("string"!=typeof e){const e={};for(const s in t)e[s]=t[s].src;return e}return t.src}resolve(e){const t=d(e);e=n(e);const s={};return e.forEach((e=>{if(!this._resolverHash[e])if(this._assetMap[e]){let t=this._assetMap[e];const s=t[0],a=this._getPreferredOrder(t);a?.priority.forEach((e=>{a.params[e].forEach((s=>{const a=t.filter((t=>!!t[e]&&t[e]===s));a.length&&(t=a)}))})),this._resolverHash[e]=t[0]??s}else this._resolverHash[e]=this.buildResolvedAsset({alias:[e],src:e},{});s[e]=this._resolverHash[e]})),t?s[e[0]]:s}hasKey(e){return!!this._assetMap[e]}hasBundle(e){return!!this._bundles[e]}_getPreferredOrder(e){for(let t=0;t<e.length;t++){const t=e[0],s=this._preferredOrder.find((e=>e.params.format.includes(t.format)));if(s)return s}return this._preferredOrder[0]}_appendDefaultSearchParams(e){return this._defaultSearchParams?`${e}${/\?/.test(e)?"&":"?"}${this._defaultSearchParams}`:e}buildResolvedAsset(e,t){const{aliases:s,data:r,loadParser:i,format:o}=t;return(this._basePath||this._rootPath)&&(e.src=a.Wp.path.toAbsolute(e.src,this._basePath,this._rootPath)),e.alias=s??e.alias??[e.src],e.src=this._appendDefaultSearchParams(e.src),e.data={...r||{},...e.data},e.loadParser=i??e.loadParser,e.format=o??e.format??a.Wp.path.extname(e.src).slice(1),e.srcs=e.src,e.name=e.alias,e}}class S{constructor(){this._detections=[],this._initialized=!1,this.resolver=new D,this.loader=new l,this.cache=c,this._backgroundLoader=new i(this.loader),this._backgroundLoader.active=!0,this.reset()}async init(e={}){if(this._initialized)return void console.warn("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");if(this._initialized=!0,e.defaultSearchParams&&this.resolver.setDefaultSearchParams(e.defaultSearchParams),e.basePath&&(this.resolver.basePath=e.basePath),e.bundleIdentifier&&this.resolver.setBundleIdentifier(e.bundleIdentifier),e.manifest){let t=e.manifest;"string"==typeof t&&(t=await this.load(t)),this.resolver.addManifest(t)}const t=e.texturePreference?.resolution??1,s="number"==typeof t?[t]:t,a=await this._detectFormats({preferredFormats:e.texturePreference?.format,skipDetections:e.skipDetections,detections:this._detections});this.resolver.prefer({params:{format:a,resolution:s}}),e.preferences&&this.setPreferences(e.preferences)}add(e,t,s,a,r){this.resolver.add(e,t,s,a,r)}async load(e,t){this._initialized||await this.init();const s=d(e),a=n(e).map((e=>{if("string"!=typeof e){const t=this.resolver.getAlias(e);return t.some((e=>!this.resolver.hasKey(e)))&&this.add(e),Array.isArray(t)?t[0]:t}return this.resolver.hasKey(e)||this.add({alias:e,src:e}),e})),r=this.resolver.resolve(a),i=await this._mapLoadToResolve(r,t);return s?i[a[0]]:i}addBundle(e,t){this.resolver.addBundle(e,t)}async loadBundle(e,t){this._initialized||await this.init();let s=!1;"string"==typeof e&&(s=!0,e=[e]);const a=this.resolver.resolveBundle(e),r={},i=Object.keys(a);let o=0,n=0;const c=()=>{t?.(++o/n)},d=i.map((e=>{const t=a[e];return n+=Object.keys(t).length,this._mapLoadToResolve(t,c).then((t=>{r[e]=t}))}));return await Promise.all(d),s?r[e[0]]:r}async backgroundLoad(e){this._initialized||await this.init(),"string"==typeof e&&(e=[e]);const t=this.resolver.resolve(e);this._backgroundLoader.add(Object.values(t))}async backgroundLoadBundle(e){this._initialized||await this.init(),"string"==typeof e&&(e=[e]);const t=this.resolver.resolveBundle(e);Object.values(t).forEach((e=>{this._backgroundLoader.add(Object.values(e))}))}reset(){this.resolver.reset(),this.loader.reset(),this.cache.reset(),this._initialized=!1}get(e){if("string"==typeof e)return c.get(e);const t={};for(let s=0;s<e.length;s++)t[s]=c.get(e[s]);return t}async _mapLoadToResolve(e,t){const s=Object.values(e),a=Object.keys(e);this._backgroundLoader.active=!1;const r=await this.loader.load(s,t);this._backgroundLoader.active=!0;const i={};return s.forEach(((e,t)=>{const s=r[e.src],o=[e.src];e.alias&&o.push(...e.alias),i[a[t]]=s,c.set(o,s)})),i}async unload(e){this._initialized||await this.init();const t=n(e).map((e=>"string"!=typeof e?e.src:e)),s=this.resolver.resolve(t);await this._unloadFromResolved(s)}async unloadBundle(e){this._initialized||await this.init(),e=n(e);const t=this.resolver.resolveBundle(e),s=Object.keys(t).map((e=>this._unloadFromResolved(t[e])));await Promise.all(s)}async _unloadFromResolved(e){const t=Object.values(e);t.forEach((e=>{c.remove(e.src)})),await this.loader.unload(t)}async _detectFormats(e){let t=[];e.preferredFormats&&(t=Array.isArray(e.preferredFormats)?e.preferredFormats:[e.preferredFormats]);for(const s of e.detections)e.skipDetections||await s.test()?t=await s.add(t):e.skipDetections||(t=await s.remove(t));return t=t.filter(((e,s)=>t.indexOf(e)===s)),t}get detections(){return this._detections}get preferWorkers(){return j.config.preferWorkers}set preferWorkers(e){a.Wp.deprecation("7.2.0","Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead."),this.setPreferences({preferWorkers:e})}setPreferences(e){this.loader.parsers.forEach((t=>{t.config&&Object.keys(t.config).filter((t=>t in e)).forEach((s=>{t.config[s]=e[s]}))}))}}const X=new S;a.XO.handleByList(a.Ag.LoadParser,X.loader.parsers).handleByList(a.Ag.ResolveParser,X.resolver.parsers).handleByList(a.Ag.CacheParser,X.cache.parsers).handleByList(a.Ag.DetectionParser,X.detections);const H={extension:a.Ag.CacheParser,test:e=>Array.isArray(e)&&e.every((e=>e instanceof a.gP)),getCacheableAssets:(e,t)=>{const s={};return e.forEach((e=>{t.forEach(((t,a)=>{s[e+(0===a?"":a+1)]=t}))})),s}};async function G(e){if("Image"in globalThis)return new Promise((t=>{const s=new Image;s.onload=()=>{t(!0)},s.onerror=()=>{t(!1)},s.src=e}));if("createImageBitmap"in globalThis&&"fetch"in globalThis){try{const t=await(await fetch(e)).blob();await createImageBitmap(t)}catch{return!1}return!0}return!1}a.XO.add(H);const z={extension:{type:a.Ag.DetectionParser,priority:1},test:async()=>G("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),add:async e=>[...e,"avif"],remove:async e=>e.filter((e=>"avif"!==e))};a.XO.add(z);const V={extension:{type:a.Ag.DetectionParser,priority:0},test:async()=>G("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),add:async e=>[...e,"webp"],remove:async e=>e.filter((e=>"webp"!==e))};a.XO.add(V);const Q=["png","jpg","jpeg"],K={extension:{type:a.Ag.DetectionParser,priority:-1},test:()=>Promise.resolve(!0),add:async e=>[...e,...Q],remove:async e=>e.filter((e=>!Q.includes(e)))};a.XO.add(K);const Y="WorkerGlobalScope"in globalThis&&globalThis instanceof globalThis.WorkerGlobalScope;function Z(e){return!Y&&""!==document.createElement("video").canPlayType(e)}const N={extension:{type:a.Ag.DetectionParser,priority:0},test:async()=>Z("video/webm"),add:async e=>[...e,"webm"],remove:async e=>e.filter((e=>"webm"!==e))};a.XO.add(N);const q={extension:{type:a.Ag.DetectionParser,priority:0},test:async()=>Z("video/mp4"),add:async e=>[...e,"mp4","m4v"],remove:async e=>e.filter((e=>"mp4"!==e&&"m4v"!==e))};a.XO.add(q);const J={extension:{type:a.Ag.DetectionParser,priority:0},test:async()=>Z("video/ogg"),add:async e=>[...e,"ogv"],remove:async e=>e.filter((e=>"ogv"!==e))};a.XO.add(J);const ee={extension:a.Ag.ResolveParser,test:j.test,parse:e=>({resolution:parseFloat(a.W0.RETINA_PREFIX.exec(e)?.[1]??"1"),format:a.Wp.path.extname(e).slice(1),src:e})};a.XO.add(ee);const te=(e,t)=>{const s=t.split("?")[1];return s&&(e+=`?${s}`),e}}}]);