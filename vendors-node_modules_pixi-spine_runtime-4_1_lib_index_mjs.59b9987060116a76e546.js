"use strict";(self.webpackChunkfederation_clients=self.webpackChunkfederation_clients||[]).push([["vendors-node_modules_pixi-spine_runtime-4_1_lib_index_mjs"],{"./node_modules/@pixi-spine/runtime-4.1/lib/index.mjs":(t,e,s)=>{s.r(e),s.d(e,{AlphaTimeline:()=>U,Animation:()=>w,AnimationState:()=>J,AnimationStateAdapter:()=>nt,AnimationStateData:()=>dt,AtlasAttachmentLoader:()=>mt,Attachment:()=>a,AttachmentTimeline:()=>V,Bone:()=>ft,BoneData:()=>gt,BoundingBoxAttachment:()=>o,ClippingAttachment:()=>h,ConstraintData:()=>pt,CurveTimeline:()=>y,CurveTimeline1:()=>k,CurveTimeline2:()=>A,DeformTimeline:()=>j,DrawOrderTimeline:()=>N,Event:()=>xt,EventData:()=>wt,EventQueue:()=>et,EventTimeline:()=>L,EventType:()=>st,IkConstraint:()=>bt,IkConstraintData:()=>yt,IkConstraintTimeline:()=>$,MeshAttachment:()=>c,PathAttachment:()=>l,PathConstraint:()=>qt,PathConstraintData:()=>kt,PathConstraintMixTimeline:()=>Q,PathConstraintPositionTimeline:()=>O,PathConstraintSpacingTimeline:()=>z,PointAttachment:()=>d,RGB2Timeline:()=>D,RGBA2Timeline:()=>R,RGBATimeline:()=>B,RGBTimeline:()=>E,RegionAttachment:()=>u,RotateTimeline:()=>S,ScaleTimeline:()=>F,ScaleXTimeline:()=>Y,ScaleYTimeline:()=>C,Sequence:()=>g,SequenceMode:()=>p,SequenceModeValues:()=>x,SequenceTimeline:()=>H,ShearTimeline:()=>M,ShearXTimeline:()=>X,ShearYTimeline:()=>T,Skeleton:()=>Yt,SkeletonBinary:()=>Et,SkeletonBounds:()=>ce,SkeletonData:()=>Ct,SkeletonJson:()=>le,Skin:()=>Bt,SkinEntry:()=>Tt,Slot:()=>It,SlotData:()=>Mt,SpacingMode:()=>At,Spine:()=>pe,Timeline:()=>b,TrackEntry:()=>tt,TransformConstraint:()=>vt,TransformConstraintData:()=>Xt,TransformConstraintTimeline:()=>_,TranslateTimeline:()=>q,TranslateXTimeline:()=>I,TranslateYTimeline:()=>v,VertexAttachment:()=>i});var n=s("./node_modules/@pixi-spine/base/lib/index.mjs");class a{constructor(t){if(!t)throw new Error("name cannot be null.");this.name=t}}const r=class extends a{constructor(t){super(t),this.id=r.nextID++,this.bones=null,this.vertices=[],this.worldVerticesLength=0,this.timelineAttachment=this}computeWorldVerticesOld(t,e){this.computeWorldVertices(t,0,this.worldVerticesLength,e,0,2)}computeWorldVertices(t,e,s,n,a,r){s=a+(s>>1)*r;const i=t.bone.skeleton,o=t.deform;let h=this.vertices;const c=this.bones;if(!c){o.length>0&&(h=o);const i=t.bone.matrix,c=i.tx,l=i.ty,d=i.a,m=i.c,u=i.b,f=i.d;for(let t=e,i=a;i<s;t+=2,i+=r){const e=h[t],s=h[t+1];n[i]=e*d+s*m+c,n[i+1]=e*u+s*f+l}return}let l=0,d=0;for(let t=0;t<e;t+=2){const t=c[l];l+=t+1,d+=t}const m=i.bones;if(0==o.length)for(let t=a,e=3*d;t<s;t+=r){let s=0,a=0,r=c[l++];for(r+=l;l<r;l++,e+=3){const t=m[c[l]].matrix,n=h[e],r=h[e+1],i=h[e+2];s+=(n*t.a+r*t.c+t.tx)*i,a+=(n*t.b+r*t.d+t.ty)*i}n[t]=s,n[t+1]=a}else{const t=o;for(let e=a,i=3*d,o=d<<1;e<s;e+=r){let s=0,a=0,r=c[l++];for(r+=l;l<r;l++,i+=3,o+=2){const e=m[c[l]].matrix,n=h[i]+t[o],r=h[i+1]+t[o+1],d=h[i+2];s+=(n*e.a+r*e.c+e.tx)*d,a+=(n*e.b+r*e.d+e.ty)*d}n[e]=s,n[e+1]=a}}}copyTo(t){this.bones?(t.bones=new Array(this.bones.length),n.Aq.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,this.vertices&&(t.vertices=n.Aq.newFloatArray(this.vertices.length),n.Aq.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)),t.worldVerticesLength=this.worldVerticesLength,t.timelineAttachment=this.timelineAttachment}};let i=r;i.nextID=0;class o extends i{constructor(t){super(t),this.type=n.wh.BoundingBox,this.color=new n.Q1(1,1,1,1)}copy(){const t=new o(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class h extends i{constructor(t){super(t),this.type=n.wh.Clipping,this.endSlot=null,this.color=new n.Q1(.2275,.2275,.8078,1)}copy(){const t=new h(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class c extends i{constructor(t,e){super(t),this.type=n.wh.Mesh,this.region=null,this.triangles=[],this.color=new n.Q1(1,1,1,1),this.width=0,this.height=0,this.hullLength=0,this.edges=[],this.parentMesh=null,this.sequence=null,this.tempColor=new n.Q1(0,0,0,0),this.path=e}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new c(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),n.Aq.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),n.Aq.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,t.sequence=null!=this.sequence?this.sequence.copy():null,this.edges&&(t.edges=new Array(this.edges.length),n.Aq.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}computeWorldVertices(t,e,s,n,a,r){null!=this.sequence&&this.sequence.apply(t,this),super.computeWorldVertices(t,e,s,n,a,r)}newLinkedMesh(){const t=new c(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),t.timelineAttachment=this.timelineAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}}class l extends i{constructor(t){super(t),this.type=n.wh.Path,this.lengths=[],this.closed=!1,this.constantSpeed=!1,this.color=new n.Q1(1,1,1,1)}copy(){const t=new l(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),n.Aq.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class d extends i{constructor(t){super(t),this.type=n.wh.Point,this.x=0,this.y=0,this.rotation=0,this.color=new n.Q1(.38,.94,0,1)}computeWorldPosition(t,e){const s=t.matrix;return e.x=this.x*s.a+this.y*s.c+t.worldX,e.y=this.x*s.b+this.y*s.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,s=n.cj.cosDeg(this.rotation),a=n.cj.sinDeg(this.rotation),r=s*e.a+a*e.c,i=s*e.b+a*e.d;return Math.atan2(i,r)*n.cj.radDeg}copy(){const t=new d(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}const m=class extends a{constructor(t,e){super(t),this.type=n.wh.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new n.Q1(1,1,1,1),this.rendererObject=null,this.region=null,this.sequence=null,this.offset=n.Aq.newFloatArray(8),this.uvs=n.Aq.newFloatArray(8),this.tempColor=new n.Q1(1,1,1,1),this.path=e}updateRegion(){if(!this.region)throw new Error("Region not set.");const t=this.region,e=this.width/this.region.originalWidth*this.scaleX,s=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*e,a=-this.height/2*this.scaleY+this.region.offsetY*s,r=n+this.region.width*e,i=a+this.region.height*s,o=this.rotation*Math.PI/180,h=Math.cos(o),c=Math.sin(o),l=this.x,d=this.y,m=n*h+l,u=n*c,f=a*h+d,g=a*c,p=r*h+l,x=r*c,w=i*h+d,b=i*c,y=this.offset;y[0]=m-g,y[1]=f+u,y[2]=m-b,y[3]=w+u,y[4]=p-b,y[5]=w+x,y[6]=p-g,y[7]=f+x;const k=this.uvs;90==t.degrees?(k[2]=t.u,k[3]=t.v2,k[4]=t.u,k[5]=t.v,k[6]=t.u2,k[7]=t.v,k[0]=t.u2,k[1]=t.v2):(k[0]=t.u,k[1]=t.v2,k[2]=t.u,k[3]=t.v,k[4]=t.u2,k[5]=t.v,k[6]=t.u2,k[7]=t.v2)}computeWorldVertices(t,e,s,n){null!=this.sequence&&this.sequence.apply(t,this);const a=t.bone,r=this.offset,i=a.matrix,o=i.tx,h=i.ty,c=i.a,l=i.c,d=i.b,m=i.d;let u=0,f=0;u=r[0],f=r[1],e[s]=u*c+f*l+o,e[s+1]=u*d+f*m+h,s+=n,u=r[2],f=r[3],e[s]=u*c+f*l+o,e[s+1]=u*d+f*m+h,s+=n,u=r[4],f=r[5],e[s]=u*c+f*l+o,e[s+1]=u*d+f*m+h,s+=n,u=r[6],f=r[7],e[s]=u*c+f*l+o,e[s+1]=u*d+f*m+h}copy(){const t=new m(this.name,this.path);return t.region=this.region,t.rendererObject=this.rendererObject,t.x=this.x,t.y=this.y,t.scaleX=this.scaleX,t.scaleY=this.scaleY,t.rotation=this.rotation,t.width=this.width,t.height=this.height,n.Aq.arrayCopy(this.uvs,0,t.uvs,0,8),n.Aq.arrayCopy(this.offset,0,t.offset,0,8),t.color.setFromColor(this.color),t.sequence=null!=this.sequence?this.sequence.copy():null,t}};let u=m;u.X1=0,u.Y1=1,u.C1R=2,u.C1G=3,u.C1B=4,u.C1A=5,u.U1=6,u.V1=7,u.X2=8,u.Y2=9,u.C2R=10,u.C2G=11,u.C2B=12,u.C2A=13,u.U2=14,u.V2=15,u.X3=16,u.Y3=17,u.C3R=18,u.C3G=19,u.C3B=20,u.C3A=21,u.U3=22,u.V3=23,u.X4=24,u.Y4=25,u.C4R=26,u.C4G=27,u.C4B=28,u.C4A=29,u.U4=30,u.V4=31;const f=class{constructor(t){this.id=f.nextID(),this.start=0,this.digits=0,this.setupIndex=0,this.regions=new Array(t)}copy(){const t=new f(this.regions.length);return n.Aq.arrayCopy(this.regions,0,t.regions,0,this.regions.length),t.start=this.start,t.digits=this.digits,t.setupIndex=this.setupIndex,t}apply(t,e){let s=t.sequenceIndex;-1==s&&(s=this.setupIndex),s>=this.regions.length&&(s=this.regions.length-1);const n=this.regions[s];e.region!=n&&(e.region=n)}getPath(t,e){let s=t;const n=(this.start+e).toString();for(let t=this.digits-n.length;t>0;t--)s+="0";return s+=n,s}static nextID(){return f._nextID++}};let g=f;g._nextID=0;var p=(t=>(t[t.hold=0]="hold",t[t.once=1]="once",t[t.loop=2]="loop",t[t.pingpong=3]="pingpong",t[t.onceReverse=4]="onceReverse",t[t.loopReverse=5]="loopReverse",t[t.pingpongReverse=6]="pingpongReverse",t))(p||{});const x=[0,1,2,3,4,5,6];class w{constructor(t,e,s){if(this.timelines=[],this.timelineIds=new n.eE,!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(e),this.duration=s}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds.clear();for(let e=0;e<t.length;e++)this.timelineIds.addAll(t[e].getPropertyIds())}hasTimeline(t){for(let e=0;e<t.length;e++)if(this.timelineIds.contains(t[e]))return!0;return!1}apply(t,e,s,n,a,r,i,o){if(!t)throw new Error("skeleton cannot be null.");n&&0!=this.duration&&(s%=this.duration,e>0&&(e%=this.duration));const h=this.timelines;for(let n=0,c=h.length;n<c;n++)h[n].apply(t,e,s,a,r,i,o)}}class b{constructor(t,e){this.propertyIds=e,this.frames=n.Aq.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,e){const s=t.length;for(let n=1;n<s;n++)if(t[n]>e)return n-1;return s-1}static search(t,e,s){const n=t.length;for(let a=s;a<n;a+=s)if(t[a]>e)return a-s;return n-s}}class y extends b{constructor(t,e,s){super(t,s),this.curves=n.Aq.newFloatArray(t+18*e),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const e=this.getFrameCount()+18*t;if(this.curves.length>e){const t=n.Aq.newFloatArray(e);n.Aq.arrayCopy(this.curves,0,t,0,e),this.curves=t}}setBezier(t,e,s,n,a,r,i,o,h,c,l){const d=this.curves;let m=this.getFrameCount()+18*t;0==s&&(d[e]=2+m);const u=.03*(n-2*r+o),f=.03*(a-2*i+h),g=.006*(3*(r-o)-n+c),p=.006*(3*(i-h)-a+l);let x=2*u+g,w=2*f+p,b=.3*(r-n)+u+.16666667*g,y=.3*(i-a)+f+.16666667*p,k=n+b,A=a+y;for(let t=m+18;m<t;m+=2)d[m]=k,d[m+1]=A,b+=x,y+=w,x+=g,w+=p,k+=b,A+=y}getBezierValue(t,e,s,n){const a=this.curves;if(a[n]>t){const r=this.frames[e],i=this.frames[e+s];return i+(t-r)/(a[n]-r)*(a[n+1]-i)}const r=n+18;for(n+=2;n<r;n+=2)if(a[n]>=t){const e=a[n-2],s=a[n-1];return s+(t-e)/(a[n]-e)*(a[n+1]-s)}e+=this.getFrameEntries();const i=a[r-2],o=a[r-1];return o+(t-i)/(this.frames[e]-i)*(this.frames[e+s]-o)}}class k extends y{constructor(t,e,s){super(t,e,[s])}getFrameEntries(){return 2}setFrame(t,e,s){t<<=1,this.frames[t]=e,this.frames[t+1]=s}getCurveValue(t){const e=this.frames;let s=e.length-2;for(let n=2;n<=s;n+=2)if(e[n]>t){s=n-2;break}const n=this.curves[s>>1];switch(n){case 0:const n=e[s],a=e[s+1];return a+(t-n)/(e[s+2]-n)*(e[s+2+1]-a);case 1:return e[s+1]}return this.getBezierValue(t,s,1,n-2)}}class A extends y{constructor(t,e,s,n){super(t,e,[s,n])}getFrameEntries(){return 3}setFrame(t,e,s,n){t*=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n}}class S extends k{constructor(t,e,s){super(t,e,`0|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,e,s,a,r,i,o){const h=t.bones[this.boneIndex];if(!h.active)return;if(s<this.frames[0]){switch(i){case n.qU.setup:return void(h.rotation=h.data.rotation);case n.qU.first:h.rotation+=(h.data.rotation-h.rotation)*r}return}let c=this.getCurveValue(s);switch(i){case n.qU.setup:h.rotation=h.data.rotation+c*r;break;case n.qU.first:case n.qU.replace:c+=h.data.rotation-h.rotation;case n.qU.add:h.rotation+=c*r}}}class q extends A{constructor(t,e,s){super(t,e,`1|${s}`,`2|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,e,s,a,r,i,o){const h=t.bones[this.boneIndex];if(!h.active)return;const c=this.frames;if(s<c[0]){switch(i){case n.qU.setup:return h.x=h.data.x,void(h.y=h.data.y);case n.qU.first:h.x+=(h.data.x-h.x)*r,h.y+=(h.data.y-h.y)*r}return}let l=0,d=0;const m=b.search(c,s,3),u=this.curves[m/3];switch(u){case 0:const t=c[m];l=c[m+1],d=c[m+2];const e=(s-t)/(c[m+3]-t);l+=(c[m+3+1]-l)*e,d+=(c[m+3+2]-d)*e;break;case 1:l=c[m+1],d=c[m+2];break;default:l=this.getBezierValue(s,m,1,u-2),d=this.getBezierValue(s,m,2,u+18-2)}switch(i){case n.qU.setup:h.x=h.data.x+l*r,h.y=h.data.y+d*r;break;case n.qU.first:case n.qU.replace:h.x+=(h.data.x+l-h.x)*r,h.y+=(h.data.y+d-h.y)*r;break;case n.qU.add:h.x+=l*r,h.y+=d*r}}}class I extends k{constructor(t,e,s){super(t,e,`1|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,e,s,a,r,i,o){const h=t.bones[this.boneIndex];if(!h.active)return;if(s<this.frames[0]){switch(i){case n.qU.setup:return void(h.x=h.data.x);case n.qU.first:h.x+=(h.data.x-h.x)*r}return}const c=this.getCurveValue(s);switch(i){case n.qU.setup:h.x=h.data.x+c*r;break;case n.qU.first:case n.qU.replace:h.x+=(h.data.x+c-h.x)*r;break;case n.qU.add:h.x+=c*r}}}class v extends k{constructor(t,e,s){super(t,e,`2|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,e,s,a,r,i,o){const h=t.bones[this.boneIndex];if(!h.active)return;if(s<this.frames[0]){switch(i){case n.qU.setup:return void(h.y=h.data.y);case n.qU.first:h.y+=(h.data.y-h.y)*r}return}const c=this.getCurveValue(s);switch(i){case n.qU.setup:h.y=h.data.y+c*r;break;case n.qU.first:case n.qU.replace:h.y+=(h.data.y+c-h.y)*r;break;case n.qU.add:h.y+=c*r}}}class F extends A{constructor(t,e,s){super(t,e,`3|${s}`,`4|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,e,s,a,r,i,o){const h=t.bones[this.boneIndex];if(!h.active)return;const c=this.frames;if(s<c[0]){switch(i){case n.qU.setup:return h.scaleX=h.data.scaleX,void(h.scaleY=h.data.scaleY);case n.qU.first:h.scaleX+=(h.data.scaleX-h.scaleX)*r,h.scaleY+=(h.data.scaleY-h.scaleY)*r}return}let l,d;const m=b.search(c,s,3),u=this.curves[m/3];switch(u){case 0:const t=c[m];l=c[m+1],d=c[m+2];const e=(s-t)/(c[m+3]-t);l+=(c[m+3+1]-l)*e,d+=(c[m+3+2]-d)*e;break;case 1:l=c[m+1],d=c[m+2];break;default:l=this.getBezierValue(s,m,1,u-2),d=this.getBezierValue(s,m,2,u+18-2)}if(l*=h.data.scaleX,d*=h.data.scaleY,1==r)i==n.qU.add?(h.scaleX+=l-h.data.scaleX,h.scaleY+=d-h.data.scaleY):(h.scaleX=l,h.scaleY=d);else{let t=0,e=0;if(o==n.mj.mixOut)switch(i){case n.qU.setup:t=h.data.scaleX,e=h.data.scaleY,h.scaleX=t+(Math.abs(l)*n.cj.signum(t)-t)*r,h.scaleY=e+(Math.abs(d)*n.cj.signum(e)-e)*r;break;case n.qU.first:case n.qU.replace:t=h.scaleX,e=h.scaleY,h.scaleX=t+(Math.abs(l)*n.cj.signum(t)-t)*r,h.scaleY=e+(Math.abs(d)*n.cj.signum(e)-e)*r;break;case n.qU.add:h.scaleX+=(l-h.data.scaleX)*r,h.scaleY+=(d-h.data.scaleY)*r}else switch(i){case n.qU.setup:t=Math.abs(h.data.scaleX)*n.cj.signum(l),e=Math.abs(h.data.scaleY)*n.cj.signum(d),h.scaleX=t+(l-t)*r,h.scaleY=e+(d-e)*r;break;case n.qU.first:case n.qU.replace:t=Math.abs(h.scaleX)*n.cj.signum(l),e=Math.abs(h.scaleY)*n.cj.signum(d),h.scaleX=t+(l-t)*r,h.scaleY=e+(d-e)*r;break;case n.qU.add:h.scaleX+=(l-h.data.scaleX)*r,h.scaleY+=(d-h.data.scaleY)*r}}}}class Y extends k{constructor(t,e,s){super(t,e,`3|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,e,s,a,r,i,o){const h=t.bones[this.boneIndex];if(!h.active)return;if(s<this.frames[0]){switch(i){case n.qU.setup:return void(h.scaleX=h.data.scaleX);case n.qU.first:h.scaleX+=(h.data.scaleX-h.scaleX)*r}return}const c=this.getCurveValue(s)*h.data.scaleX;if(1==r)i==n.qU.add?h.scaleX+=c-h.data.scaleX:h.scaleX=c;else{let t=0;if(o==n.mj.mixOut)switch(i){case n.qU.setup:t=h.data.scaleX,h.scaleX=t+(Math.abs(c)*n.cj.signum(t)-t)*r;break;case n.qU.first:case n.qU.replace:t=h.scaleX,h.scaleX=t+(Math.abs(c)*n.cj.signum(t)-t)*r;break;case n.qU.add:h.scaleX+=(c-h.data.scaleX)*r}else switch(i){case n.qU.setup:t=Math.abs(h.data.scaleX)*n.cj.signum(c),h.scaleX=t+(c-t)*r;break;case n.qU.first:case n.qU.replace:t=Math.abs(h.scaleX)*n.cj.signum(c),h.scaleX=t+(c-t)*r;break;case n.qU.add:h.scaleX+=(c-h.data.scaleX)*r}}}}class C extends k{constructor(t,e,s){super(t,e,`4|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,e,s,a,r,i,o){const h=t.bones[this.boneIndex];if(!h.active)return;if(s<this.frames[0]){switch(i){case n.qU.setup:return void(h.scaleY=h.data.scaleY);case n.qU.first:h.scaleY+=(h.data.scaleY-h.scaleY)*r}return}const c=this.getCurveValue(s)*h.data.scaleY;if(1==r)i==n.qU.add?h.scaleY+=c-h.data.scaleY:h.scaleY=c;else{let t=0;if(o==n.mj.mixOut)switch(i){case n.qU.setup:t=h.data.scaleY,h.scaleY=t+(Math.abs(c)*n.cj.signum(t)-t)*r;break;case n.qU.first:case n.qU.replace:t=h.scaleY,h.scaleY=t+(Math.abs(c)*n.cj.signum(t)-t)*r;break;case n.qU.add:h.scaleY+=(c-h.data.scaleY)*r}else switch(i){case n.qU.setup:t=Math.abs(h.data.scaleY)*n.cj.signum(c),h.scaleY=t+(c-t)*r;break;case n.qU.first:case n.qU.replace:t=Math.abs(h.scaleY)*n.cj.signum(c),h.scaleY=t+(c-t)*r;break;case n.qU.add:h.scaleY+=(c-h.data.scaleY)*r}}}}class M extends A{constructor(t,e,s){super(t,e,`5|${s}`,`6|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,e,s,a,r,i,o){const h=t.bones[this.boneIndex];if(!h.active)return;const c=this.frames;if(s<c[0]){switch(i){case n.qU.setup:return h.shearX=h.data.shearX,void(h.shearY=h.data.shearY);case n.qU.first:h.shearX+=(h.data.shearX-h.shearX)*r,h.shearY+=(h.data.shearY-h.shearY)*r}return}let l=0,d=0;const m=b.search(c,s,3),u=this.curves[m/3];switch(u){case 0:const t=c[m];l=c[m+1],d=c[m+2];const e=(s-t)/(c[m+3]-t);l+=(c[m+3+1]-l)*e,d+=(c[m+3+2]-d)*e;break;case 1:l=c[m+1],d=c[m+2];break;default:l=this.getBezierValue(s,m,1,u-2),d=this.getBezierValue(s,m,2,u+18-2)}switch(i){case n.qU.setup:h.shearX=h.data.shearX+l*r,h.shearY=h.data.shearY+d*r;break;case n.qU.first:case n.qU.replace:h.shearX+=(h.data.shearX+l-h.shearX)*r,h.shearY+=(h.data.shearY+d-h.shearY)*r;break;case n.qU.add:h.shearX+=l*r,h.shearY+=d*r}}}class X extends k{constructor(t,e,s){super(t,e,`5|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,e,s,a,r,i,o){const h=t.bones[this.boneIndex];if(!h.active)return;if(s<this.frames[0]){switch(i){case n.qU.setup:return void(h.shearX=h.data.shearX);case n.qU.first:h.shearX+=(h.data.shearX-h.shearX)*r}return}const c=this.getCurveValue(s);switch(i){case n.qU.setup:h.shearX=h.data.shearX+c*r;break;case n.qU.first:case n.qU.replace:h.shearX+=(h.data.shearX+c-h.shearX)*r;break;case n.qU.add:h.shearX+=c*r}}}class T extends k{constructor(t,e,s){super(t,e,`6|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,e,s,a,r,i,o){const h=t.bones[this.boneIndex];if(!h.active)return;if(s<this.frames[0]){switch(i){case n.qU.setup:return void(h.shearY=h.data.shearY);case n.qU.first:h.shearY+=(h.data.shearY-h.shearY)*r}return}const c=this.getCurveValue(s);switch(i){case n.qU.setup:h.shearY=h.data.shearY+c*r;break;case n.qU.first:case n.qU.replace:h.shearY+=(h.data.shearY+c-h.shearY)*r;break;case n.qU.add:h.shearY+=c*r}}}class B extends y{constructor(t,e,s){super(t,e,[`7|${s}`,`8|${s}`]),this.slotIndex=0,this.slotIndex=s}getFrameEntries(){return 5}setFrame(t,e,s,n,a,r){t*=5,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=a,this.frames[t+4]=r}apply(t,e,s,a,r,i,o){const h=t.slots[this.slotIndex];if(!h.bone.active)return;const c=this.frames,l=h.color;if(s<c[0]){const t=h.data.color;switch(i){case n.qU.setup:return void l.setFromColor(t);case n.qU.first:l.add((t.r-l.r)*r,(t.g-l.g)*r,(t.b-l.b)*r,(t.a-l.a)*r)}return}let d=0,m=0,u=0,f=0;const g=b.search(c,s,5),p=this.curves[g/5];switch(p){case 0:const t=c[g];d=c[g+1],m=c[g+2],u=c[g+3],f=c[g+4];const e=(s-t)/(c[g+5]-t);d+=(c[g+5+1]-d)*e,m+=(c[g+5+2]-m)*e,u+=(c[g+5+3]-u)*e,f+=(c[g+5+4]-f)*e;break;case 1:d=c[g+1],m=c[g+2],u=c[g+3],f=c[g+4];break;default:d=this.getBezierValue(s,g,1,p-2),m=this.getBezierValue(s,g,2,p+18-2),u=this.getBezierValue(s,g,3,p+36-2),f=this.getBezierValue(s,g,4,p+54-2)}1==r?l.set(d,m,u,f):(i==n.qU.setup&&l.setFromColor(h.data.color),l.add((d-l.r)*r,(m-l.g)*r,(u-l.b)*r,(f-l.a)*r))}}class E extends y{constructor(t,e,s){super(t,e,[`7|${s}`]),this.slotIndex=0,this.slotIndex=s}getFrameEntries(){return 4}setFrame(t,e,s,n,a){t<<=2,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=a}apply(t,e,s,a,r,i,o){const h=t.slots[this.slotIndex];if(!h.bone.active)return;const c=this.frames,l=h.color;if(s<c[0]){const t=h.data.color;switch(i){case n.qU.setup:return l.r=t.r,l.g=t.g,void(l.b=t.b);case n.qU.first:l.r+=(t.r-l.r)*r,l.g+=(t.g-l.g)*r,l.b+=(t.b-l.b)*r}return}let d=0,m=0,u=0;const f=b.search(c,s,4),g=this.curves[f>>2];switch(g){case 0:const t=c[f];d=c[f+1],m=c[f+2],u=c[f+3];const e=(s-t)/(c[f+4]-t);d+=(c[f+4+1]-d)*e,m+=(c[f+4+2]-m)*e,u+=(c[f+4+3]-u)*e;break;case 1:d=c[f+1],m=c[f+2],u=c[f+3];break;default:d=this.getBezierValue(s,f,1,g-2),m=this.getBezierValue(s,f,2,g+18-2),u=this.getBezierValue(s,f,3,g+36-2)}if(1==r)l.r=d,l.g=m,l.b=u;else{if(i==n.qU.setup){const t=h.data.color;l.r=t.r,l.g=t.g,l.b=t.b}l.r+=(d-l.r)*r,l.g+=(m-l.g)*r,l.b+=(u-l.b)*r}}}class U extends k{constructor(t,e,s){super(t,e,`8|${s}`),this.slotIndex=0,this.slotIndex=s}apply(t,e,s,a,r,i,o){const h=t.slots[this.slotIndex];if(!h.bone.active)return;const c=h.color;if(s<this.frames[0]){const t=h.data.color;switch(i){case n.qU.setup:return void(c.a=t.a);case n.qU.first:c.a+=(t.a-c.a)*r}return}const l=this.getCurveValue(s);1==r?c.a=l:(i==n.qU.setup&&(c.a=h.data.color.a),c.a+=(l-c.a)*r)}}class R extends y{constructor(t,e,s){super(t,e,[`7|${s}`,`8|${s}`,`9|${s}`]),this.slotIndex=0,this.slotIndex=s}getFrameEntries(){return 8}setFrame(t,e,s,n,a,r,i,o,h){t<<=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=a,this.frames[t+4]=r,this.frames[t+5]=i,this.frames[t+6]=o,this.frames[t+7]=h}apply(t,e,s,a,r,i,o){const h=t.slots[this.slotIndex];if(!h.bone.active)return;const c=this.frames,l=h.color,d=h.darkColor;if(s<c[0]){const t=h.data.color,e=h.data.darkColor;switch(i){case n.qU.setup:return l.setFromColor(t),d.r=e.r,d.g=e.g,void(d.b=e.b);case n.qU.first:l.add((t.r-l.r)*r,(t.g-l.g)*r,(t.b-l.b)*r,(t.a-l.a)*r),d.r+=(e.r-d.r)*r,d.g+=(e.g-d.g)*r,d.b+=(e.b-d.b)*r}return}let m=0,u=0,f=0,g=0,p=0,x=0,w=0;const y=b.search(c,s,8),k=this.curves[y>>3];switch(k){case 0:const t=c[y];m=c[y+1],u=c[y+2],f=c[y+3],g=c[y+4],p=c[y+5],x=c[y+6],w=c[y+7];const e=(s-t)/(c[y+8]-t);m+=(c[y+8+1]-m)*e,u+=(c[y+8+2]-u)*e,f+=(c[y+8+3]-f)*e,g+=(c[y+8+4]-g)*e,p+=(c[y+8+5]-p)*e,x+=(c[y+8+6]-x)*e,w+=(c[y+8+7]-w)*e;break;case 1:m=c[y+1],u=c[y+2],f=c[y+3],g=c[y+4],p=c[y+5],x=c[y+6],w=c[y+7];break;default:m=this.getBezierValue(s,y,1,k-2),u=this.getBezierValue(s,y,2,k+18-2),f=this.getBezierValue(s,y,3,k+36-2),g=this.getBezierValue(s,y,4,k+54-2),p=this.getBezierValue(s,y,5,k+72-2),x=this.getBezierValue(s,y,6,k+90-2),w=this.getBezierValue(s,y,7,k+108-2)}if(1==r)l.set(m,u,f,g),d.r=p,d.g=x,d.b=w;else{if(i==n.qU.setup){l.setFromColor(h.data.color);const t=h.data.darkColor;d.r=t.r,d.g=t.g,d.b=t.b}l.add((m-l.r)*r,(u-l.g)*r,(f-l.b)*r,(g-l.a)*r),d.r+=(p-d.r)*r,d.g+=(x-d.g)*r,d.b+=(w-d.b)*r}}}class D extends y{constructor(t,e,s){super(t,e,[`7|${s}`,`9|${s}`]),this.slotIndex=0,this.slotIndex=s}getFrameEntries(){return 7}setFrame(t,e,s,n,a,r,i,o){t*=7,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=a,this.frames[t+4]=r,this.frames[t+5]=i,this.frames[t+6]=o}apply(t,e,s,a,r,i,o){const h=t.slots[this.slotIndex];if(!h.bone.active)return;const c=this.frames,l=h.color,d=h.darkColor;if(s<c[0]){const t=h.data.color,e=h.data.darkColor;switch(i){case n.qU.setup:return l.r=t.r,l.g=t.g,l.b=t.b,d.r=e.r,d.g=e.g,void(d.b=e.b);case n.qU.first:l.r+=(t.r-l.r)*r,l.g+=(t.g-l.g)*r,l.b+=(t.b-l.b)*r,d.r+=(e.r-d.r)*r,d.g+=(e.g-d.g)*r,d.b+=(e.b-d.b)*r}return}let m=0,u=0,f=0,g=0,p=0,x=0;const w=b.search(c,s,7),y=this.curves[w/7];switch(y){case 0:const t=c[w];m=c[w+1],u=c[w+2],f=c[w+3],g=c[w+4],p=c[w+5],x=c[w+6];const e=(s-t)/(c[w+7]-t);m+=(c[w+7+1]-m)*e,u+=(c[w+7+2]-u)*e,f+=(c[w+7+3]-f)*e,g+=(c[w+7+4]-g)*e,p+=(c[w+7+5]-p)*e,x+=(c[w+7+6]-x)*e;break;case 1:m=c[w+1],u=c[w+2],f=c[w+3],g=c[w+4],p=c[w+5],x=c[w+6];break;default:m=this.getBezierValue(s,w,1,y-2),u=this.getBezierValue(s,w,2,y+18-2),f=this.getBezierValue(s,w,3,y+36-2),g=this.getBezierValue(s,w,4,y+54-2),p=this.getBezierValue(s,w,5,y+72-2),x=this.getBezierValue(s,w,6,y+90-2)}if(1==r)l.r=m,l.g=u,l.b=f,d.r=g,d.g=p,d.b=x;else{if(i==n.qU.setup){const t=h.data.color,e=h.data.darkColor;l.r=t.r,l.g=t.g,l.b=t.b,d.r=e.r,d.g=e.g,d.b=e.b}l.r+=(m-l.r)*r,l.g+=(u-l.g)*r,l.b+=(f-l.b)*r,d.r+=(g-d.r)*r,d.g+=(p-d.g)*r,d.b+=(x-d.b)*r}}}class V extends b{constructor(t,e){super(t,[`10|${e}`]),this.slotIndex=0,this.slotIndex=e,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.attachmentNames[t]=s}apply(t,e,s,a,r,i,o){const h=t.slots[this.slotIndex];h.bone.active&&(o!=n.mj.mixOut?s<this.frames[0]?i!=n.qU.setup&&i!=n.qU.first||this.setAttachment(t,h,h.data.attachmentName):this.setAttachment(t,h,this.attachmentNames[b.search1(this.frames,s)]):i==n.qU.setup&&this.setAttachment(t,h,h.data.attachmentName))}setAttachment(t,e,s){e.setAttachment(s?t.getAttachment(this.slotIndex,s):null)}}class j extends y{constructor(t,e,s,n){super(t,e,[`11|${s}|${n.id}`]),this.slotIndex=0,this.slotIndex=s,this.attachment=n,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.vertices[t]=s}setBezier(t,e,s,n,a,r,i,o,h,c,l){const d=this.curves;let m=this.getFrameCount()+18*t;0==s&&(d[e]=2+m);const u=.03*(n-2*r+o),f=.03*h-.06*i,g=.006*(3*(r-o)-n+c),p=.018*(i-h+.33333333);let x=2*u+g,w=2*f+p,b=.3*(r-n)+u+.16666667*g,y=.3*i+f+.16666667*p,k=n+b,A=y;for(let t=m+18;m<t;m+=2)d[m]=k,d[m+1]=A,b+=x,y+=w,x+=g,w+=p,k+=b,A+=y}getCurvePercent(t,e){const s=this.curves;let n=s[e];switch(n){case 0:const s=this.frames[e];return(t-s)/(this.frames[e+this.getFrameEntries()]-s);case 1:return 0}if(n-=2,s[n]>t){const a=this.frames[e];return s[n+1]*(t-a)/(s[n]-a)}const a=n+18;for(n+=2;n<a;n+=2)if(s[n]>=t){const e=s[n-2],a=s[n-1];return a+(t-e)/(s[n]-e)*(s[n+1]-a)}const r=s[a-2],i=s[a-1];return i+(1-i)*(t-r)/(this.frames[e+this.getFrameEntries()]-r)}apply(t,e,s,a,r,o,h){const c=t.slots[this.slotIndex];if(!c.bone.active)return;const l=c.getAttachment();if(!l)return;if(!(l instanceof i)||l.timelineAttachment!=this.attachment)return;const d=c.deform;0==d.length&&(o=n.qU.setup);const m=this.vertices,u=m[0].length,f=this.frames;if(s<f[0]){switch(o){case n.qU.setup:return void(d.length=0);case n.qU.first:if(1==r)return void(d.length=0);d.length=u;const t=l;if(t.bones){r=1-r;for(let t=0;t<u;t++)d[t]*=r}else{const e=t.vertices;for(let t=0;t<u;t++)d[t]+=(e[t]-d[t])*r}}return}if(d.length=u,s>=f[f.length-1]){const t=m[f.length-1];if(1==r)if(o==n.qU.add){const e=l;if(e.bones)for(let e=0;e<u;e++)d[e]+=t[e];else{const s=e.vertices;for(let e=0;e<u;e++)d[e]+=t[e]-s[e]}}else n.Aq.arrayCopy(t,0,d,0,u);else switch(o){case n.qU.setup:{const e=l;if(e.bones)for(let e=0;e<u;e++)d[e]=t[e]*r;else{const s=e.vertices;for(let e=0;e<u;e++){const n=s[e];d[e]=n+(t[e]-n)*r}}break}case n.qU.first:case n.qU.replace:for(let e=0;e<u;e++)d[e]+=(t[e]-d[e])*r;break;case n.qU.add:const e=l;if(e.bones)for(let e=0;e<u;e++)d[e]+=t[e]*r;else{const s=e.vertices;for(let e=0;e<u;e++)d[e]+=(t[e]-s[e])*r}}return}const g=b.search1(f,s),p=this.getCurvePercent(s,g),x=m[g],w=m[g+1];if(1==r)if(o==n.qU.add){const t=l;if(t.bones)for(let t=0;t<u;t++){const e=x[t];d[t]+=e+(w[t]-e)*p}else{const e=t.vertices;for(let t=0;t<u;t++){const s=x[t];d[t]+=s+(w[t]-s)*p-e[t]}}}else for(let t=0;t<u;t++){const e=x[t];d[t]=e+(w[t]-e)*p}else switch(o){case n.qU.setup:{const t=l;if(t.bones)for(let t=0;t<u;t++){const e=x[t];d[t]=(e+(w[t]-e)*p)*r}else{const e=t.vertices;for(let t=0;t<u;t++){const s=x[t],n=e[t];d[t]=n+(s+(w[t]-s)*p-n)*r}}break}case n.qU.first:case n.qU.replace:for(let t=0;t<u;t++){const e=x[t];d[t]+=(e+(w[t]-e)*p-d[t])*r}break;case n.qU.add:const t=l;if(t.bones)for(let t=0;t<u;t++){const e=x[t];d[t]+=(e+(w[t]-e)*p)*r}else{const e=t.vertices;for(let t=0;t<u;t++){const s=x[t];d[t]+=(s+(w[t]-s)*p-e[t])*r}}}}}const P=class extends b{constructor(t){super(t,P.propertyIds),this.events=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,s,n,a,r,i){if(!n)return;const o=this.frames,h=this.frames.length;if(e>s)this.apply(t,e,Number.MAX_VALUE,n,a,r,i),e=-1;else if(e>=o[h-1])return;if(s<o[0])return;let c=0;if(e<o[0])c=0;else{c=b.search1(o,e)+1;const t=o[c];for(;c>0&&o[c-1]==t;)c--}for(;c<h&&s>=o[c];c++)n.push(this.events[c])}};let L=P;L.propertyIds=["12"];const W=class extends b{constructor(t){super(t,W.propertyIds),this.drawOrders=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.drawOrders[t]=s}apply(t,e,s,a,r,i,o){if(o==n.mj.mixOut)return void(i==n.qU.setup&&n.Aq.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length));if(s<this.frames[0])return void(i!=n.qU.setup&&i!=n.qU.first||n.Aq.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length));const h=b.search1(this.frames,s),c=this.drawOrders[h];if(c){const e=t.drawOrder,s=t.slots;for(let t=0,n=c.length;t<n;t++)e[t]=s[c[t]]}else n.Aq.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length)}};let N=W;N.propertyIds=["13"];class $ extends y{constructor(t,e,s){super(t,e,[`14|${s}`]),this.ikConstraintIndex=0,this.ikConstraintIndex=s}getFrameEntries(){return 6}setFrame(t,e,s,n,a,r,i){t*=6,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=a,this.frames[t+4]=r?1:0,this.frames[t+5]=i?1:0}apply(t,e,s,a,r,i,o){const h=t.ikConstraints[this.ikConstraintIndex];if(!h.active)return;const c=this.frames;if(s<c[0]){switch(i){case n.qU.setup:return h.mix=h.data.mix,h.softness=h.data.softness,h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,void(h.stretch=h.data.stretch);case n.qU.first:h.mix+=(h.data.mix-h.mix)*r,h.softness+=(h.data.softness-h.softness)*r,h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,h.stretch=h.data.stretch}return}let l=0,d=0;const m=b.search(c,s,6),u=this.curves[m/6];switch(u){case 0:const t=c[m];l=c[m+1],d=c[m+2];const e=(s-t)/(c[m+6]-t);l+=(c[m+6+1]-l)*e,d+=(c[m+6+2]-d)*e;break;case 1:l=c[m+1],d=c[m+2];break;default:l=this.getBezierValue(s,m,1,u-2),d=this.getBezierValue(s,m,2,u+18-2)}i==n.qU.setup?(h.mix=h.data.mix+(l-h.data.mix)*r,h.softness=h.data.softness+(d-h.data.softness)*r,o==n.mj.mixOut?(h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,h.stretch=h.data.stretch):(h.bendDirection=c[m+3],h.compress=0!=c[m+4],h.stretch=0!=c[m+5])):(h.mix+=(l-h.mix)*r,h.softness+=(d-h.softness)*r,o==n.mj.mixIn&&(h.bendDirection=c[m+3],h.compress=0!=c[m+4],h.stretch=0!=c[m+5]))}}class _ extends y{constructor(t,e,s){super(t,e,[`15|${s}`]),this.transformConstraintIndex=0,this.transformConstraintIndex=s}getFrameEntries(){return 7}setFrame(t,e,s,n,a,r,i,o){const h=this.frames;h[t*=7]=e,h[t+1]=s,h[t+2]=n,h[t+3]=a,h[t+4]=r,h[t+5]=i,h[t+6]=o}apply(t,e,s,a,r,i,o){const h=t.transformConstraints[this.transformConstraintIndex];if(!h.active)return;const c=this.frames;if(s<c[0]){const t=h.data;switch(i){case n.qU.setup:return h.mixRotate=t.mixRotate,h.mixX=t.mixX,h.mixY=t.mixY,h.mixScaleX=t.mixScaleX,h.mixScaleY=t.mixScaleY,void(h.mixShearY=t.mixShearY);case n.qU.first:h.mixRotate+=(t.mixRotate-h.mixRotate)*r,h.mixX+=(t.mixX-h.mixX)*r,h.mixY+=(t.mixY-h.mixY)*r,h.mixScaleX+=(t.mixScaleX-h.mixScaleX)*r,h.mixScaleY+=(t.mixScaleY-h.mixScaleY)*r,h.mixShearY+=(t.mixShearY-h.mixShearY)*r}return}let l,d,m,u,f,g;const p=b.search(c,s,7),x=this.curves[p/7];switch(x){case 0:const t=c[p];l=c[p+1],d=c[p+2],m=c[p+3],u=c[p+4],f=c[p+5],g=c[p+6];const e=(s-t)/(c[p+7]-t);l+=(c[p+7+1]-l)*e,d+=(c[p+7+2]-d)*e,m+=(c[p+7+3]-m)*e,u+=(c[p+7+4]-u)*e,f+=(c[p+7+5]-f)*e,g+=(c[p+7+6]-g)*e;break;case 1:l=c[p+1],d=c[p+2],m=c[p+3],u=c[p+4],f=c[p+5],g=c[p+6];break;default:l=this.getBezierValue(s,p,1,x-2),d=this.getBezierValue(s,p,2,x+18-2),m=this.getBezierValue(s,p,3,x+36-2),u=this.getBezierValue(s,p,4,x+54-2),f=this.getBezierValue(s,p,5,x+72-2),g=this.getBezierValue(s,p,6,x+90-2)}if(i==n.qU.setup){const t=h.data;h.mixRotate=t.mixRotate+(l-t.mixRotate)*r,h.mixX=t.mixX+(d-t.mixX)*r,h.mixY=t.mixY+(m-t.mixY)*r,h.mixScaleX=t.mixScaleX+(u-t.mixScaleX)*r,h.mixScaleY=t.mixScaleY+(f-t.mixScaleY)*r,h.mixShearY=t.mixShearY+(g-t.mixShearY)*r}else h.mixRotate+=(l-h.mixRotate)*r,h.mixX+=(d-h.mixX)*r,h.mixY+=(m-h.mixY)*r,h.mixScaleX+=(u-h.mixScaleX)*r,h.mixScaleY+=(f-h.mixScaleY)*r,h.mixShearY+=(g-h.mixShearY)*r}}class O extends k{constructor(t,e,s){super(t,e,`16|${s}`),this.pathConstraintIndex=0,this.pathConstraintIndex=s}apply(t,e,s,a,r,i,o){const h=t.pathConstraints[this.pathConstraintIndex];if(!h.active)return;if(s<this.frames[0]){switch(i){case n.qU.setup:return void(h.position=h.data.position);case n.qU.first:h.position+=(h.data.position-h.position)*r}return}const c=this.getCurveValue(s);i==n.qU.setup?h.position=h.data.position+(c-h.data.position)*r:h.position+=(c-h.position)*r}}class z extends k{constructor(t,e,s){super(t,e,`17|${s}`),this.pathConstraintIndex=0,this.pathConstraintIndex=s}apply(t,e,s,a,r,i,o){const h=t.pathConstraints[this.pathConstraintIndex];if(!h.active)return;if(s<this.frames[0]){switch(i){case n.qU.setup:return void(h.spacing=h.data.spacing);case n.qU.first:h.spacing+=(h.data.spacing-h.spacing)*r}return}const c=this.getCurveValue(s);i==n.qU.setup?h.spacing=h.data.spacing+(c-h.data.spacing)*r:h.spacing+=(c-h.spacing)*r}}class Q extends y{constructor(t,e,s){super(t,e,[`18|${s}`]),this.pathConstraintIndex=0,this.pathConstraintIndex=s}getFrameEntries(){return 4}setFrame(t,e,s,n,a){const r=this.frames;r[t<<=2]=e,r[t+1]=s,r[t+2]=n,r[t+3]=a}apply(t,e,s,a,r,i,o){const h=t.pathConstraints[this.pathConstraintIndex];if(!h.active)return;const c=this.frames;if(s<c[0]){switch(i){case n.qU.setup:return h.mixRotate=h.data.mixRotate,h.mixX=h.data.mixX,void(h.mixY=h.data.mixY);case n.qU.first:h.mixRotate+=(h.data.mixRotate-h.mixRotate)*r,h.mixX+=(h.data.mixX-h.mixX)*r,h.mixY+=(h.data.mixY-h.mixY)*r}return}let l,d,m;const u=b.search(c,s,4),f=this.curves[u>>2];switch(f){case 0:const t=c[u];l=c[u+1],d=c[u+2],m=c[u+3];const e=(s-t)/(c[u+4]-t);l+=(c[u+4+1]-l)*e,d+=(c[u+4+2]-d)*e,m+=(c[u+4+3]-m)*e;break;case 1:l=c[u+1],d=c[u+2],m=c[u+3];break;default:l=this.getBezierValue(s,u,1,f-2),d=this.getBezierValue(s,u,2,f+18-2),m=this.getBezierValue(s,u,3,f+36-2)}if(i==n.qU.setup){const t=h.data;h.mixRotate=t.mixRotate+(l-t.mixRotate)*r,h.mixX=t.mixX+(d-t.mixX)*r,h.mixY=t.mixY+(m-t.mixY)*r}else h.mixRotate+=(l-h.mixRotate)*r,h.mixX+=(d-h.mixX)*r,h.mixY+=(m-h.mixY)*r}}const G=class extends b{constructor(t,e,s){super(t,[`19|${e}|${s.sequence.id}`]),this.slotIndex=e,this.attachment=s}getFrameEntries(){return G.ENTRIES}getSlotIndex(){return this.slotIndex}getAttachment(){return this.attachment}setFrame(t,e,s,n,a){const r=this.frames;r[t*=G.ENTRIES]=e,r[t+G.MODE]=s|n<<4,r[t+G.DELAY]=a}apply(t,e,s,a,r,o,h){const c=t.slots[this.slotIndex];if(!c.bone.active)return;const l=c.attachment,d=this.attachment;if(!(l==d||l instanceof i&&l.timelineAttachment==d))return;const m=this.frames;if(s<m[0])return void(o!=n.qU.setup&&o!=n.qU.first||(c.sequenceIndex=-1));const u=b.search(m,s,G.ENTRIES),f=m[u],g=m[u+G.MODE],w=m[u+G.DELAY];if(!this.attachment.sequence)return;let y=g>>4;const k=this.attachment.sequence.regions.length,A=x[15&g];if(A!=p.hold)switch(y+=(s-f)/w+1e-5|0,A){case p.once:y=Math.min(k-1,y);break;case p.loop:y%=k;break;case p.pingpong:{const t=(k<<1)-2;y=0==t?0:y%t,y>=k&&(y=t-y);break}case p.onceReverse:y=Math.max(k-1-y,0);break;case p.loopReverse:y=k-1-y%k;break;case p.pingpongReverse:{const t=(k<<1)-2;y=0==t?0:(y+k-1)%t,y>=k&&(y=t-y)}}c.sequenceIndex=y}};let H=G;H.ENTRIES=3,H.MODE=1,H.DELAY=2;const K=class{constructor(t){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new et(this),this.propertyIDs=new n.eE,this.animationsChanged=!1,this.trackEntryPool=new n.bC((()=>new tt)),this.data=t}static emptyAnimation(){return K._emptyAnimation}update(t){t*=this.timeScale;const e=this.tracks;for(let s=0,n=e.length;s<n;s++){const n=e[s];if(!n)continue;n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast;let a=t*n.timeScale;if(n.delay>0){if(n.delay-=a,n.delay>0)continue;a=-n.delay,n.delay=0}let r=n.next;if(r){const e=n.trackLast-r.delay;if(e>=0){for(r.delay=0,r.trackTime+=0==n.timeScale?0:(e/n.timeScale+t)*r.timeScale,n.trackTime+=a,this.setCurrent(s,r,!0);r.mixingFrom;)r.mixTime+=t,r=r.mixingFrom;continue}}else if(n.trackLast>=n.trackEnd&&!n.mixingFrom){e[s]=null,this.queue.end(n),this.clearNext(n);continue}if(n.mixingFrom&&this.updateMixingFrom(n,t)){let t=n.mixingFrom;for(n.mixingFrom=null,t&&(t.mixingTo=null);t;)this.queue.end(t),t=t.mixingFrom}n.trackTime+=a}this.queue.drain()}updateMixingFrom(t,e){const s=t.mixingFrom;if(!s)return!0;const n=this.updateMixingFrom(s,e);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?(0!=s.totalAlpha&&0!=t.mixDuration||(t.mixingFrom=s.mixingFrom,s.mixingFrom&&(s.mixingFrom.mixingTo=t),t.interruptAlpha=s.interruptAlpha,this.queue.end(s)),n):(s.trackTime+=e*s.timeScale,t.mixTime+=e,!1)}apply(t){if(!t)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const e=this.events,s=this.tracks;let a=!1;for(let r=0,i=s.length;r<i;r++){const i=s[r];if(!i||i.delay>0)continue;a=!0;const o=0==r?n.qU.first:i.mixBlend;let h=i.alpha;i.mixingFrom?h*=this.applyMixingFrom(i,t,o):i.trackTime>=i.trackEnd&&!i.next&&(h=0);const c=i.animationLast,l=i.getAnimationTime();let d=l,m=e;i.reverse&&(d=i.animation.duration-d,m=null);const u=i.animation.timelines,f=u.length;if(0==r&&1==h||o==n.qU.add)for(let e=0;e<f;e++){n.Aq.webkit602BugfixHelper(h,o);const s=u[e];s instanceof V?this.applyAttachmentTimeline(s,t,d,o,!0):s.apply(t,c,d,m,h,o,n.mj.mixIn)}else{const e=i.timelineMode,s=i.shortestRotation,a=!s&&i.timelinesRotation.length!=f<<1;a&&(i.timelinesRotation.length=f<<1);for(let r=0;r<f;r++){const l=u[r],f=e[r]==at?o:n.qU.setup;!s&&l instanceof S?this.applyRotateTimeline(l,t,d,h,f,i.timelinesRotation,r<<1,a):l instanceof V?this.applyAttachmentTimeline(l,t,d,o,!0):(n.Aq.webkit602BugfixHelper(h,o),l.apply(t,c,d,m,h,f,n.mj.mixIn))}}this.queueEvents(i,l),e.length=0,i.nextAnimationLast=l,i.nextTrackLast=i.trackTime}const r=this.unkeyedState+ct,i=t.slots;for(let e=0,s=t.slots.length;e<s;e++){const s=i[e];if(s.attachmentState==r){const e=s.data.attachmentName;s.setAttachment(e?t.getAttachment(s.data.index,e):null)}}return this.unkeyedState+=2,this.queue.drain(),a}applyMixingFrom(t,e,s){const a=t.mixingFrom;a.mixingFrom&&this.applyMixingFrom(a,e,s);let r=0;0==t.mixDuration?(r=1,s==n.qU.first&&(s=n.qU.setup)):(r=t.mixTime/t.mixDuration,r>1&&(r=1),s!=n.qU.first&&(s=a.mixBlend));const i=r<a.attachmentThreshold,o=r<a.drawOrderThreshold,h=a.animation.timelines,c=h.length,l=a.alpha*t.interruptAlpha,d=l*(1-r),m=a.animationLast,u=a.getAnimationTime();let f=u,g=null;if(a.reverse?f=a.animation.duration-f:r<a.eventThreshold&&(g=this.events),s==n.qU.add)for(let t=0;t<c;t++)h[t].apply(e,m,f,g,d,s,n.mj.mixOut);else{const t=a.timelineMode,r=a.timelineHoldMix,u=a.shortestRotation,p=!u&&a.timelinesRotation.length!=c<<1;p&&(a.timelinesRotation.length=c<<1),a.totalAlpha=0;for(let x=0;x<c;x++){const c=h[x];let w,b=n.mj.mixOut,y=0;switch(t[x]){case at:if(!o&&c instanceof N)continue;w=s,y=d;break;case rt:w=n.qU.setup,y=d;break;case it:w=s,y=l;break;case ot:w=n.qU.setup,y=l;break;default:w=n.qU.setup;const t=r[x];y=l*Math.max(0,1-t.mixTime/t.mixDuration)}a.totalAlpha+=y,!u&&c instanceof S?this.applyRotateTimeline(c,e,f,y,w,a.timelinesRotation,x<<1,p):c instanceof V?this.applyAttachmentTimeline(c,e,f,w,i):(n.Aq.webkit602BugfixHelper(y,s),o&&c instanceof N&&w==n.qU.setup&&(b=n.mj.mixIn),c.apply(e,m,f,g,y,w,b))}}return t.mixDuration>0&&this.queueEvents(a,u),this.events.length=0,a.nextAnimationLast=u,a.nextTrackLast=a.trackTime,r}applyAttachmentTimeline(t,e,s,a,r){const i=e.slots[t.slotIndex];i.bone.active&&(s<t.frames[0]?a!=n.qU.setup&&a!=n.qU.first||this.setAttachment(e,i,i.data.attachmentName,r):this.setAttachment(e,i,t.attachmentNames[b.search1(t.frames,s)],r),i.attachmentState<=this.unkeyedState&&(i.attachmentState=this.unkeyedState+ct))}setAttachment(t,e,s,n){e.setAttachment(s?t.getAttachment(e.data.index,s):null),n&&(e.attachmentState=this.unkeyedState+lt)}applyRotateTimeline(t,e,s,a,r,i,o,h){if(h&&(i[o]=0),1==a)return void t.apply(e,0,s,null,1,r,n.mj.mixIn);const c=e.bones[t.boneIndex];if(!c.active)return;let l=0,d=0;if(s<t.frames[0])switch(r){case n.qU.setup:c.rotation=c.data.rotation;default:return;case n.qU.first:l=c.rotation,d=c.data.rotation}else l=r==n.qU.setup?c.data.rotation:c.rotation,d=c.data.rotation+t.getCurveValue(s);let m=0,u=d-l;if(u-=360*(16384-(16384.499999999996-u/360|0)),0==u)m=i[o];else{let t=0,e=0;h?(t=0,e=u):(t=i[o],e=i[o+1]);const s=u>0;let a=t>=0;n.cj.signum(e)!=n.cj.signum(u)&&Math.abs(e)<=90&&(Math.abs(t)>180&&(t+=360*n.cj.signum(t)),a=s),m=u+t-t%360,a!=s&&(m+=360*n.cj.signum(t)),i[o]=m}i[o+1]=u,c.rotation=l+m*a}queueEvents(t,e){const s=t.animationStart,n=t.animationEnd,a=n-s,r=t.trackLast%a,i=this.events;let o=0;const h=i.length;for(;o<h;o++){const e=i[o];if(e.time<r)break;e.time>n||this.queue.event(t,e)}let c=!1;for(c=t.loop?0==a||r>t.trackTime%a:e>=n&&t.animationLast<n,c&&this.queue.complete(t);o<h;o++){const e=i[o];e.time<s||this.queue.event(t,e)}}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,e=this.tracks.length;t<e;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const e=this.tracks[t];if(!e)return;this.queue.end(e),this.clearNext(e);let s=e;for(;;){const t=s.mixingFrom;if(!t)break;this.queue.end(t),s.mixingFrom=null,s.mixingTo=null,s=t}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,s){const n=this.expandToIndex(t);this.tracks[t]=e,e.previous=null,n&&(s&&this.queue.interrupt(n),e.mixingFrom=n,n.mixingTo=e,e.mixTime=0,n.mixingFrom&&n.mixDuration>0&&(e.interruptAlpha*=Math.min(1,n.mixTime/n.mixDuration)),n.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,s=!1){const n=this.data.skeletonData.findAnimation(e);if(!n)throw new Error(`Animation not found: ${e}`);return this.setAnimationWith(t,n,s)}setAnimationWith(t,e,s=!1){if(!e)throw new Error("animation cannot be null.");let n=!0,a=this.expandToIndex(t);a&&(-1==a.nextTrackLast?(this.tracks[t]=a.mixingFrom,this.queue.interrupt(a),this.queue.end(a),this.clearNext(a),a=a.mixingFrom,n=!1):this.clearNext(a));const r=this.trackEntry(t,e,s,a);return this.setCurrent(t,r,n),this.queue.drain(),r}addAnimation(t,e,s=!1,n=0){const a=this.data.skeletonData.findAnimation(e);if(!a)throw new Error(`Animation not found: ${e}`);return this.addAnimationWith(t,a,s,n)}addAnimationWith(t,e,s=!1,n=0){if(!e)throw new Error("animation cannot be null.");let a=this.expandToIndex(t);if(a)for(;a.next;)a=a.next;const r=this.trackEntry(t,e,s,a);return a?(a.next=r,r.previous=a,n<=0&&(n+=a.getTrackComplete()-r.mixDuration)):(this.setCurrent(t,r,!0),this.queue.drain()),r.delay=n,r}setEmptyAnimation(t,e=0){const s=this.setAnimationWith(t,K.emptyAnimation(),!1);return s.mixDuration=e,s.trackEnd=e,s}addEmptyAnimation(t,e=0,s=0){const n=this.addAnimationWith(t,K.emptyAnimation(),!1,s);return s<=0&&(n.delay+=n.mixDuration-e),n.mixDuration=e,n.trackEnd=e,n}setEmptyAnimations(t=0){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,s=this.tracks.length;e<s;e++){const s=this.tracks[e];s&&this.setEmptyAnimation(s.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(n.Aq.ensureArrayCapacity(this.tracks,t+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,s,a){const r=this.trackEntryPool.obtain();return r.reset(),r.trackIndex=t,r.animation=e,r.loop=s,r.holdPrevious=!1,r.reverse=!1,r.shortestRotation=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=e.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.mixTime=0,r.mixDuration=a?this.data.getMix(a.animation,e):0,r.interruptAlpha=1,r.totalAlpha=0,r.mixBlend=n.qU.replace,r}clearNext(t){let e=t.next;for(;e;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const t=this.tracks;for(let e=0,s=t.length;e<s;e++){let s=t[e];if(s){for(;s.mixingFrom;)s=s.mixingFrom;do{s.mixingTo&&s.mixBlend==n.qU.add||this.computeHold(s),s=s.mixingTo}while(s)}}}computeHold(t){const e=t.mixingTo,s=t.animation.timelines,n=t.animation.timelines.length,a=t.timelineMode;a.length=n;const r=t.timelineHoldMix;r.length=0;const i=this.propertyIDs;if(e&&e.holdPrevious)for(let t=0;t<n;t++)a[t]=i.addAll(s[t].getPropertyIds())?ot:it;else t:for(let o=0;o<n;o++){const n=s[o],h=n.getPropertyIds();if(i.addAll(h))if(!e||n instanceof V||n instanceof N||n instanceof L||!e.animation.hasTimeline(h))a[o]=rt;else{for(let s=e.mixingTo;s;s=s.mixingTo)if(!s.animation.hasTimeline(h)){if(t.mixDuration>0){a[o]=ht,r[o]=s;continue t}break}a[o]=ot}else a[o]=at}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(!t)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,e,s){K.deprecatedWarning1||(K.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,e,s)}addAnimationByName(t,e,s,n){K.deprecatedWarning2||(K.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,e,s,n)}hasAnimation(t){return null!==this.data.skeletonData.findAnimation(t)}hasAnimationByName(t){return K.deprecatedWarning3||(K.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};let J=K;J._emptyAnimation=new w("<empty>",[],0),J.deprecatedWarning1=!1,J.deprecatedWarning2=!1,J.deprecatedWarning3=!1;const Z=class{constructor(){this.animation=null,this.previous=null,this.next=null,this.mixingFrom=null,this.mixingTo=null,this.listener=null,this.trackIndex=0,this.loop=!1,this.holdPrevious=!1,this.reverse=!1,this.shortestRotation=!1,this.eventThreshold=0,this.attachmentThreshold=0,this.drawOrderThreshold=0,this.animationStart=0,this.animationEnd=0,this.animationLast=0,this.nextAnimationLast=0,this.delay=0,this.trackTime=0,this.trackLast=0,this.nextTrackLast=0,this.trackEnd=0,this.timeScale=0,this.alpha=0,this.mixTime=0,this.mixDuration=0,this.interruptAlpha=0,this.totalAlpha=0,this.mixBlend=n.qU.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return 0==t?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const t=this.animationEnd-this.animationStart;if(0!=t){if(this.loop)return t*(1+(this.trackTime/t|0));if(this.trackTime<t)return t}return this.trackTime}get time(){return Z.deprecatedWarning1||(Z.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){Z.deprecatedWarning1||(Z.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return Z.deprecatedWarning2||(Z.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){Z.deprecatedWarning2||(Z.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let tt=Z;tt.deprecatedWarning1=!1,tt.deprecatedWarning2=!1;class et{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=t}start(t){this.objects.push(st.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(st.interrupt),this.objects.push(t)}end(t){this.objects.push(st.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(st.dispose),this.objects.push(t)}complete(t){this.objects.push(st.complete),this.objects.push(t)}event(t,e){this.objects.push(st.event),this.objects.push(t),this.objects.push(e)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,e=this.animState.listeners;for(let s=0;s<t.length;s+=2){const n=t[s],a=t[s+1];switch(n){case st.start:a.listener&&a.listener.start&&a.listener.start(a);for(let t=0;t<e.length;t++){const s=e[t];s.start&&s.start(a)}break;case st.interrupt:a.listener&&a.listener.interrupt&&a.listener.interrupt(a);for(let t=0;t<e.length;t++){const s=e[t];s.interrupt&&s.interrupt(a)}break;case st.end:a.listener&&a.listener.end&&a.listener.end(a);for(let t=0;t<e.length;t++){const s=e[t];s.end&&s.end(a)}case st.dispose:a.listener&&a.listener.dispose&&a.listener.dispose(a);for(let t=0;t<e.length;t++){const s=e[t];s.dispose&&s.dispose(a)}this.animState.trackEntryPool.free(a);break;case st.complete:a.listener&&a.listener.complete&&a.listener.complete(a);for(let t=0;t<e.length;t++){const s=e[t];s.complete&&s.complete(a)}break;case st.event:const n=t[2+s++];a.listener&&a.listener.event&&a.listener.event(a,n);for(let t=0;t<e.length;t++){const s=e[t];s.event&&s.event(a,n)}}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}}var st=(t=>(t[t.start=0]="start",t[t.interrupt=1]="interrupt",t[t.end=2]="end",t[t.dispose=3]="dispose",t[t.complete=4]="complete",t[t.event=5]="event",t))(st||{});class nt{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}}const at=0,rt=1,it=2,ot=3,ht=4,ct=1,lt=2;class dt{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,!t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,s){const n=this.skeletonData.findAnimation(t);if(!n)throw new Error(`Animation not found: ${t}`);const a=this.skeletonData.findAnimation(e);if(!a)throw new Error(`Animation not found: ${e}`);this.setMixWith(n,a,s)}setMixWith(t,e,s){if(!t)throw new Error("from cannot be null.");if(!e)throw new Error("to cannot be null.");const n=`${t.name}.${e.name}`;this.animationToMixTime[n]=s}getMix(t,e){const s=`${t.name}.${e.name}`,n=this.animationToMixTime[s];return void 0===n?this.defaultMix:n}}class mt{constructor(t){this.atlas=t}loadSequence(t,e,s){const n=s.regions;for(let a=0,r=n.length;a<r;a++){const r=s.getPath(e,a),i=this.atlas.findRegion(r);if(null==i)throw new Error(`Region not found in atlas: ${r} (sequence: ${t})`);n[a]=i,n[a].renderObject=n[a]}}newRegionAttachment(t,e,s,n){const a=new u(e,s);if(null!=n)this.loadSequence(e,s,n);else{const t=this.atlas.findRegion(s);if(!t)throw new Error(`Region not found in atlas: ${s} (region attachment: ${e})`);t.renderObject=t,a.region=t}return a}newMeshAttachment(t,e,s,n){const a=new c(e,s);if(null!=n)this.loadSequence(e,s,n);else{const t=this.atlas.findRegion(s);if(!t)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${e})`);t.renderObject=t,a.region=t}return a}newBoundingBoxAttachment(t,e){return new o(e)}newPathAttachment(t,e){return new l(e)}newPointAttachment(t,e){return new d(e)}newClippingAttachment(t,e){return new h(e)}}var ut=s("./node_modules/@pixi/core/lib/index.mjs");class ft{constructor(t,e,s){if(this.matrix=new ut.uq,this.parent=null,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.sorted=!1,this.active=!1,!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=s,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,s,a,r,i,o){this.ax=t,this.ay=e,this.arotation=s,this.ascaleX=a,this.ascaleY=r,this.ashearX=i,this.ashearY=o;const h=this.parent,c=this.matrix,l=this.skeleton.scaleX,d=n.W0.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(!h){const h=this.skeleton,m=s+90+o;return c.a=n.cj.cosDeg(s+i)*a*l,c.c=n.cj.cosDeg(m)*r*l,c.b=n.cj.sinDeg(s+i)*a*d,c.d=n.cj.sinDeg(m)*r*d,c.tx=t*l+h.x,void(c.ty=e*d+h.y)}let m=h.matrix.a,u=h.matrix.c,f=h.matrix.b,g=h.matrix.d;switch(c.tx=m*t+u*e+h.matrix.tx,c.ty=f*t+g*e+h.matrix.ty,this.data.transformMode){case n._C.Normal:{const t=s+90+o,e=n.cj.cosDeg(s+i)*a,h=n.cj.cosDeg(t)*r,l=n.cj.sinDeg(s+i)*a,d=n.cj.sinDeg(t)*r;return c.a=m*e+u*l,c.c=m*h+u*d,c.b=f*e+g*l,void(c.d=f*h+g*d)}case n._C.OnlyTranslation:{const t=s+90+o;c.a=n.cj.cosDeg(s+i)*a,c.c=n.cj.cosDeg(t)*r,c.b=n.cj.sinDeg(s+i)*a,c.d=n.cj.sinDeg(t)*r;break}case n._C.NoRotationOrReflection:{let t=m*m+f*f,e=0;t>1e-4?(t=Math.abs(m*g-u*f)/t,m/=l,f/=d,u=f*t,g=m*t,e=Math.atan2(f,m)*n.cj.radDeg):(m=0,f=0,e=90-Math.atan2(g,u)*n.cj.radDeg);const h=s+i-e,p=s+o-e+90,x=n.cj.cosDeg(h)*a,w=n.cj.cosDeg(p)*r,b=n.cj.sinDeg(h)*a,y=n.cj.sinDeg(p)*r;c.a=m*x-u*b,c.c=m*w-u*y,c.b=f*x+g*b,c.d=f*w+g*y;break}case n._C.NoScale:case n._C.NoScaleOrReflection:{const t=n.cj.cosDeg(s),e=n.cj.sinDeg(s);let h=(m*t+u*e)/l,p=(f*t+g*e)/d,x=Math.sqrt(h*h+p*p);x>1e-5&&(x=1/x),h*=x,p*=x,x=Math.sqrt(h*h+p*p),this.data.transformMode==n._C.NoScale&&m*g-u*f<0!=(l<0!=d<0)&&(x=-x);const w=Math.PI/2+Math.atan2(p,h),b=Math.cos(w)*x,y=Math.sin(w)*x,k=n.cj.cosDeg(i)*a,A=n.cj.cosDeg(90+o)*r,S=n.cj.sinDeg(i)*a,q=n.cj.sinDeg(90+o)*r;c.a=h*k+b*S,c.c=h*A+b*q,c.b=p*k+y*S,c.d=p*A+y*q;break}}c.a*=l,c.c*=l,c.b*=d,c.d*=d}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*n.cj.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*n.cj.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.b*t.b)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.c*t.c+t.d*t.d)}updateAppliedTransform(){const t=this.parent,e=this.matrix;if(!t)return this.ax=e.tx-this.skeleton.x,this.ay=e.ty-this.skeleton.y,this.arotation=Math.atan2(e.b,e.a)*n.cj.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,void(this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*n.cj.radDeg);const s=t.matrix,a=1/(s.a*s.d-s.b*s.c),r=e.tx-s.tx,i=e.ty-s.ty;this.ax=r*s.d*a-i*s.c*a,this.ay=i*s.a*a-r*s.b*a;const o=a*s.d,h=a*s.a,c=a*s.c,l=a*s.b,d=o*e.a-c*e.b,m=o*e.c-c*e.d,u=h*e.b-l*e.a,f=h*e.d-l*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(d*d+u*u),this.ascaleX>1e-4){const t=d*f-m*u;this.ascaleY=t/this.ascaleX,this.ashearY=Math.atan2(d*m+u*f,t)*n.cj.radDeg,this.arotation=Math.atan2(u,d)*n.cj.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(m*m+f*f),this.ashearY=0,this.arotation=90-Math.atan2(f,m)*n.cj.radDeg}worldToLocal(t){const e=this.matrix,s=e.a,n=e.c,a=e.b,r=e.d,i=1/(s*r-n*a),o=t.x-e.tx,h=t.y-e.ty;return t.x=o*r*i-h*n*i,t.y=h*s*i-o*a*i,t}localToWorld(t){const e=this.matrix,s=t.x,n=t.y;return t.x=s*e.a+n*e.c+e.tx,t.y=s*e.b+n*e.d+e.ty,t}worldToLocalRotation(t){const e=n.cj.sinDeg(t),s=n.cj.cosDeg(t),a=this.matrix;return Math.atan2(a.a*e-a.b*s,a.d*s-a.c*e)*n.cj.radDeg}localToWorldRotation(t){t-=this.rotation-this.shearX;const e=n.cj.sinDeg(t),s=n.cj.cosDeg(t),a=this.matrix;return Math.atan2(s*a.b+e*a.d,s*a.a+e*a.c)*n.cj.radDeg}rotateWorld(t){const e=this.matrix,s=e.a,a=e.c,r=e.b,i=e.d,o=n.cj.cosDeg(t),h=n.cj.sinDeg(t);e.a=o*s-h*r,e.c=o*a-h*i,e.b=h*s+o*r,e.d=h*a+o*i}}class gt{constructor(t,e,s){if(this.index=0,this.parent=null,this.length=0,this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=n._C.Normal,this.skinRequired=!1,this.color=new n.Q1,t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=s}}class pt{constructor(t,e,s){this.name=t,this.order=e,this.skinRequired=s}}class xt{constructor(t,e){if(this.intValue=0,this.floatValue=0,this.stringValue=null,this.time=0,this.volume=0,this.balance=0,!e)throw new Error("data cannot be null.");this.time=t,this.data=e}}class wt{constructor(t){this.intValue=0,this.floatValue=0,this.stringValue=null,this.audioPath=null,this.volume=0,this.balance=0,this.name=t}}class bt{constructor(t,e){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let s=0;s<t.bones.length;s++){const n=e.findBone(t.bones[s].name);if(!n)throw new Error(`Couldn't find bone ${t.bones[s].name}`);this.bones.push(n)}const s=e.findBone(t.target.name);if(!s)throw new Error(`Couldn't find bone ${t.target.name}`);this.target=s}isActive(){return this.active}update(){if(0==this.mix)return;const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix)}}apply1(t,e,s,a,r,i,o){const h=t.parent.matrix;if(!h)throw new Error("IK bone must have parent.");const c=h.a;let l=h.c;const d=h.b;let m=h.d,u=-t.ashearX-t.arotation,f=0,g=0;const p=t.skeleton.scaleX,x=n.W0.yDown?-t.skeleton.scaleY:t.skeleton.scaleY;switch(t.data.transformMode){case n._C.OnlyTranslation:f=(e-t.worldX)*n.cj.signum(p),g=(s-t.worldY)*n.cj.signum(x);break;case n._C.NoRotationOrReflection:const a=Math.abs(c*m-l*d)/(c*c+d*d),r=c/p,i=d/x;l=-i*a*p,m=r*a*x,u+=Math.atan2(i,r)*n.cj.radDeg;default:const o=e-h.tx,w=s-h.ty,b=c*m-l*d;f=(o*m-w*l)/b-t.ax,g=(w*c-o*d)/b-t.ay}u+=Math.atan2(g,f)*n.cj.radDeg,t.ascaleX<0&&(u+=180),u>180?u-=360:u<-180&&(u+=360);let w=t.ascaleX,b=t.ascaleY;if(a||r){switch(t.data.transformMode){case n._C.NoScale:case n._C.NoScaleOrReflection:f=e-t.worldX,g=s-t.worldY}const h=t.data.length*w,c=Math.sqrt(f*f+g*g);if(a&&c<h||r&&c>h&&h>1e-4){const t=(c/h-1)*o+1;w*=t,i&&(b*=t)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+u*o,w,b,t.ashearX,t.ashearY)}apply2(t,e,s,a,r,i,o,h,c){const l=t.ax,d=t.ay;let m=t.ascaleX,u=t.ascaleY,f=m,g=u,p=e.ascaleX;const x=t.matrix;let w=0,b=0,y=0;m<0?(m=-m,w=180,y=-1):(w=0,y=1),u<0&&(u=-u,y=-y),p<0?(p=-p,b=180):b=0;const k=e.ax;let A=0,S=0,q=0,I=x.a,v=x.c,F=x.b,Y=x.d;const C=Math.abs(m-u)<=1e-4;!C||i?(A=0,S=I*k+x.tx,q=F*k+x.ty):(A=e.ay,S=I*k+v*A+x.tx,q=F*k+Y*A+x.ty);const M=t.parent.matrix;if(!M)throw new Error("IK parent must itself have a parent.");I=M.a,v=M.c,F=M.b,Y=M.d;const X=1/(I*Y-v*F);let T=S-M.tx,B=q-M.ty;const E=(T*Y-B*v)*X-l,U=(B*I-T*F)*X-d,R=Math.sqrt(E*E+U*U);let D,V,j=e.data.length*p;if(R<1e-4)return this.apply1(t,s,a,!1,i,!1,c),void e.updateWorldTransformWith(k,A,0,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY);T=s-M.tx,B=a-M.ty;let P=(T*Y-B*v)*X-l,L=(B*I-T*F)*X-d,W=P*P+L*L;if(0!=h){h*=m*(p+1)*.5;const t=Math.sqrt(W),e=t-R-j*m+h;if(e>0){let s=Math.min(1,e/(2*h))-1;s=(e-h*(1-s*s))/t,P-=s*P,L-=s*L,W=P*P+L*L}}t:if(C){j*=m;let t=(W-R*R-j*j)/(2*R*j);t<-1?(t=-1,V=Math.PI*r):t>1?(t=1,V=0,i&&(I=(Math.sqrt(W)/(R+j)-1)*c+1,f*=I,o&&(g*=I))):V=Math.acos(t)*r,I=R+j*t,v=j*Math.sin(V),D=Math.atan2(L*I-P*v,P*I+L*v)}else{I=m*j,v=u*j;const t=I*I,e=v*v,s=Math.atan2(L,P);F=e*R*R+t*W-t*e;const a=-2*e*R,i=e-t;if(Y=a*a-4*i*F,Y>=0){let t=Math.sqrt(Y);a<0&&(t=-t),t=.5*-(a+t);const e=t/i,n=F/t,o=Math.abs(e)<Math.abs(n)?e:n;if(o*o<=W){B=Math.sqrt(W-o*o)*r,D=s-Math.atan2(B,o),V=Math.atan2(B/u,(o-R)/m);break t}}let o=n.cj.PI,h=R-I,c=h*h,l=0,d=0,f=R+I,g=f*f,p=0;F=-I*R/(t-e),F>=-1&&F<=1&&(F=Math.acos(F),T=I*Math.cos(F)+R,B=v*Math.sin(F),Y=T*T+B*B,Y<c&&(o=F,c=Y,h=T,l=B),Y>g&&(d=F,g=Y,f=T,p=B)),W<=.5*(c+g)?(D=s-Math.atan2(l*r,h),V=o*r):(D=s-Math.atan2(p*r,f),V=d*r)}const N=Math.atan2(A,k)*y;let $=t.arotation;D=(D-N)*n.cj.radDeg+w-$,D>180?D-=360:D<-180&&(D+=360),t.updateWorldTransformWith(l,d,$+D*c,f,g,0,0),$=e.arotation,V=((V+N)*n.cj.radDeg-e.ashearX)*y+b-$,V>180?V-=360:V<-180&&(V+=360),e.updateWorldTransformWith(k,A,$+V*c,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}}class yt extends pt{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class kt extends pt{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.positionMode=n.pw.Fixed,this.spacingMode=At.Fixed,this.rotateMode=n.Dr.Chain,this.offsetRotation=0,this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("SlotData not set.")}}var At=(t=>(t[t.Length=0]="Length",t[t.Fixed=1]="Fixed",t[t.Percent=2]="Percent",t[t.Proportional=3]="Proportional",t))(At||{});const St=class{constructor(t,e){if(this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let s=0,n=t.bones.length;s<n;s++){const n=e.findBone(t.bones[s].name);if(!n)throw new Error(`Couldn't find bone ${t.bones[s].name}.`);this.bones.push(n)}const s=e.findSlot(t.target.name);if(!s)throw new Error(`Couldn't find target bone ${t.target.name}`);this.target=s,this.position=t.position,this.spacing=t.spacing,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY}isActive(){return this.active}update(){const t=this.target.getAttachment();if(!(t instanceof l))return;const e=this.mixRotate,s=this.mixX,a=this.mixY;if(0==e&&0==s&&0==a)return;const r=this.data,i=r.rotateMode==n.Dr.Tangent,o=r.rotateMode==n.Dr.ChainScale,h=this.bones,c=h.length,d=i?c:c+1,m=n.Aq.setArraySize(this.spaces,d),u=o?this.lengths=n.Aq.setArraySize(this.lengths,c):[],f=this.spacing;switch(r.spacingMode){case At.Percent:if(o)for(let t=0,e=d-1;t<e;t++){const e=h[t],s=e.data.length;if(s<St.epsilon)u[t]=0;else{const n=s*e.matrix.a,a=s*e.matrix.b;u[t]=Math.sqrt(n*n+a*a)}}n.Aq.arrayFill(m,1,d,f);break;case At.Proportional:let t=0;for(let e=0,s=d-1;e<s;){const s=h[e],n=s.data.length;if(n<St.epsilon)o&&(u[e]=0),m[++e]=f;else{const a=n*s.matrix.a,r=n*s.matrix.b,i=Math.sqrt(a*a+r*r);o&&(u[e]=i),m[++e]=i,t+=i}}if(t>0){t=d/t*f;for(let e=1;e<d;e++)m[e]*=t}break;default:const e=r.spacingMode==At.Length;for(let t=0,s=d-1;t<s;){const s=h[t],n=s.data.length;if(n<St.epsilon)o&&(u[t]=0),m[++t]=f;else{const a=n*s.matrix.a,r=n*s.matrix.b,i=Math.sqrt(a*a+r*r);o&&(u[t]=i),m[++t]=(e?n+f:f)*i/n}}}const g=this.computeWorldPositions(t,d,i);let p=g[0],x=g[1],w=r.offsetRotation,b=!1;if(0==w)b=r.rotateMode==n.Dr.Chain;else{b=!1;const t=this.target.bone.matrix;w*=t.a*t.d-t.b*t.c>0?n.cj.degRad:-n.cj.degRad}for(let t=0,r=3;t<c;t++,r+=3){const c=h[t],l=c.matrix;l.tx+=(p-l.tx)*s,l.ty+=(x-l.ty)*a;const d=g[r],f=g[r+1],y=d-p,k=f-x;if(o){const s=u[t];if(0!=s){const t=(Math.sqrt(y*y+k*k)/s-1)*e+1;l.a*=t,l.b*=t}}if(p=d,x=f,e>0){const s=l.a,a=l.c,o=l.b,h=l.d;let d=0,u=0,f=0;if(d=i?g[r-1]:0==m[t+1]?g[r+2]:Math.atan2(k,y),d-=Math.atan2(o,s),b){u=Math.cos(d),f=Math.sin(d);const t=c.data.length;p+=(t*(u*s-f*o)-y)*e,x+=(t*(f*s+u*o)-k)*e}else d+=w;d>n.cj.PI?d-=n.cj.PI2:d<-n.cj.PI&&(d+=n.cj.PI2),d*=e,u=Math.cos(d),f=Math.sin(d),l.a=u*s-f*o,l.c=u*a-f*h,l.b=f*s+u*o,l.d=f*a+u*h}c.updateAppliedTransform()}}computeWorldPositions(t,e,s){const a=this.target;let r=this.position;const i=this.spaces,o=n.Aq.setArraySize(this.positions,3*e+2);let h=this.world;const c=t.closed;let l=t.worldVerticesLength,d=l/6,m=St.NONE;if(!t.constantSpeed){const u=t.lengths;d-=c?1:2;const f=u[d];let g;switch(this.data.positionMode==n.pw.Percent&&(r*=f),this.data.spacingMode){case At.Percent:g=f;break;case At.Proportional:g=f/e;break;default:g=1}h=n.Aq.setArraySize(this.world,8);for(let n=0,p=0,x=0;n<e;n++,p+=3){const e=i[n]*g;r+=e;let w=r;if(c)w%=f,w<0&&(w+=f),x=0;else{if(w<0){m!=St.BEFORE&&(m=St.BEFORE,t.computeWorldVertices(a,2,4,h,0,2)),this.addBeforePosition(w,h,0,o,p);continue}if(w>f){m!=St.AFTER&&(m=St.AFTER,t.computeWorldVertices(a,l-6,4,h,0,2)),this.addAfterPosition(w-f,h,0,o,p);continue}}for(;;x++){const t=u[x];if(!(w>t)){if(0==x)w/=t;else{const e=u[x-1];w=(w-e)/(t-e)}break}}x!=m&&(m=x,c&&x==d?(t.computeWorldVertices(a,l-4,4,h,0,2),t.computeWorldVertices(a,0,4,h,4,2)):t.computeWorldVertices(a,6*x+2,8,h,0,2)),this.addCurvePosition(w,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],o,p,s||n>0&&0==e)}return o}c?(l+=2,h=n.Aq.setArraySize(this.world,l),t.computeWorldVertices(a,2,l-4,h,0,2),t.computeWorldVertices(a,0,2,h,l-4,2),h[l-2]=h[0],h[l-1]=h[1]):(d--,l-=4,h=n.Aq.setArraySize(this.world,l),t.computeWorldVertices(a,2,l,h,0,2));const u=n.Aq.setArraySize(this.curves,d);let f,g=0,p=h[0],x=h[1],w=0,b=0,y=0,k=0,A=0,S=0,q=0,I=0,v=0,F=0,Y=0,C=0,M=0,X=0;for(let t=0,e=2;t<d;t++,e+=6)w=h[e],b=h[e+1],y=h[e+2],k=h[e+3],A=h[e+4],S=h[e+5],q=.1875*(p-2*w+y),I=.1875*(x-2*b+k),v=.09375*(3*(w-y)-p+A),F=.09375*(3*(b-k)-x+S),Y=2*q+v,C=2*I+F,M=.75*(w-p)+q+.16666667*v,X=.75*(b-x)+I+.16666667*F,g+=Math.sqrt(M*M+X*X),M+=Y,X+=C,Y+=v,C+=F,g+=Math.sqrt(M*M+X*X),M+=Y,X+=C,g+=Math.sqrt(M*M+X*X),M+=Y+v,X+=C+F,g+=Math.sqrt(M*M+X*X),u[t]=g,p=A,x=S;switch(this.data.positionMode==n.pw.Percent&&(r*=g),this.data.spacingMode){case At.Percent:f=g;break;case At.Proportional:f=g/e;break;default:f=1}const T=this.segments;let B=0;for(let t=0,n=0,a=0,d=0;t<e;t++,n+=3){const e=i[t]*f;r+=e;let E=r;if(c)E%=g,E<0&&(E+=g),a=0;else{if(E<0){this.addBeforePosition(E,h,0,o,n);continue}if(E>g){this.addAfterPosition(E-g,h,l-4,o,n);continue}}for(;;a++){const t=u[a];if(!(E>t)){if(0==a)E/=t;else{const e=u[a-1];E=(E-e)/(t-e)}break}}if(a!=m){m=a;let t=6*a;for(p=h[t],x=h[t+1],w=h[t+2],b=h[t+3],y=h[t+4],k=h[t+5],A=h[t+6],S=h[t+7],q=.03*(p-2*w+y),I=.03*(x-2*b+k),v=.006*(3*(w-y)-p+A),F=.006*(3*(b-k)-x+S),Y=2*q+v,C=2*I+F,M=.3*(w-p)+q+.16666667*v,X=.3*(b-x)+I+.16666667*F,B=Math.sqrt(M*M+X*X),T[0]=B,t=1;t<8;t++)M+=Y,X+=C,Y+=v,C+=F,B+=Math.sqrt(M*M+X*X),T[t]=B;M+=Y,X+=C,B+=Math.sqrt(M*M+X*X),T[8]=B,M+=Y+v,X+=C+F,B+=Math.sqrt(M*M+X*X),T[9]=B,d=0}for(E*=B;;d++){const t=T[d];if(!(E>t)){if(0==d)E/=t;else{const e=T[d-1];E=d+(E-e)/(t-e)}break}}this.addCurvePosition(.1*E,p,x,w,b,y,k,A,S,o,n,s||t>0&&0==e)}return o}addBeforePosition(t,e,s,n,a){const r=e[s],i=e[s+1],o=e[s+2]-r,h=e[s+3]-i,c=Math.atan2(h,o);n[a]=r+t*Math.cos(c),n[a+1]=i+t*Math.sin(c),n[a+2]=c}addAfterPosition(t,e,s,n,a){const r=e[s+2],i=e[s+3],o=r-e[s],h=i-e[s+1],c=Math.atan2(h,o);n[a]=r+t*Math.cos(c),n[a+1]=i+t*Math.sin(c),n[a+2]=c}addCurvePosition(t,e,s,n,a,r,i,o,h,c,l,d){if(0==t||isNaN(t))return c[l]=e,c[l+1]=s,void(c[l+2]=Math.atan2(a-s,n-e));const m=t*t,u=m*t,f=1-t,g=f*f,p=g*f,x=f*t,w=3*x,b=f*w,y=w*t,k=e*p+n*b+r*y+o*u,A=s*p+a*b+i*y+h*u;c[l]=k,c[l+1]=A,d&&(c[l+2]=t<.001?Math.atan2(a-s,n-e):Math.atan2(A-(s*g+a*x*2+i*m),k-(e*g+n*x*2+r*m)))}};let qt=St;qt.NONE=-1,qt.BEFORE=-2,qt.AFTER=-3,qt.epsilon=1e-5;class It{constructor(t,e){if(this.darkColor=null,this.attachment=null,this.attachmentState=0,this.sequenceIndex=-1,this.deform=new Array,!t)throw new Error("data cannot be null.");if(!e)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new n.Q1,this.darkColor=t.darkColor?new n.Q1:null,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(t instanceof i&&this.attachment instanceof i&&t.timelineAttachment==this.attachment.timelineAttachment||(this.deform.length=0),this.attachment=t,this.sequenceIndex=-1)}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName?(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName))):this.attachment=null}}class vt{constructor(t,e){if(this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.temp=new n.I9,this.active=!1,!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY,this.bones=new Array;for(let s=0;s<t.bones.length;s++){const n=e.findBone(t.bones[s].name);if(!n)throw new Error(`Couldn't find bone ${t.bones[s].name}.`);this.bones.push(n)}const s=e.findBone(t.target.name);if(!s)throw new Error(`Couldn't find target bone ${t.target.name}.`);this.target=s}isActive(){return this.active}update(){0==this.mixRotate&&0==this.mixX&&0==this.mixY&&0==this.mixScaleX&&0==this.mixScaleX&&0==this.mixShearY||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,e=this.mixX,s=this.mixY,a=this.mixScaleX,r=this.mixScaleY,i=this.mixShearY,o=0!=e||0!=s,h=this.target,c=h.matrix,l=c.a,d=c.c,m=c.b,u=c.d,f=l*u-d*m>0?n.cj.degRad:-n.cj.degRad,g=this.data.offsetRotation*f,p=this.data.offsetShearY*f,x=this.bones;for(let c=0,f=x.length;c<f;c++){const f=x[c],w=f.matrix;if(0!=t){const e=w.a,s=w.c,a=w.b,r=w.d;let i=Math.atan2(m,l)-Math.atan2(a,e)+g;i>n.cj.PI?i-=n.cj.PI2:i<-n.cj.PI&&(i+=n.cj.PI2),i*=t;const o=Math.cos(i),h=Math.sin(i);w.a=o*e-h*a,w.c=o*s-h*r,w.b=h*e+o*a,w.d=h*s+o*r}if(o){const t=this.temp;h.localToWorld(t.set(this.data.offsetX,this.data.offsetY)),w.tx+=(t.x-w.tx)*e,w.ty+=(t.y-w.ty)*s}if(0!=a){let t=Math.sqrt(w.a*w.a+w.b*w.b);0!=t&&(t=(t+(Math.sqrt(l*l+m*m)-t+this.data.offsetScaleX)*a)/t),w.a*=t,w.b*=t}if(0!=r){let t=Math.sqrt(w.c*w.c+w.d*w.d);0!=t&&(t=(t+(Math.sqrt(d*d+u*u)-t+this.data.offsetScaleY)*r)/t),w.c*=t,w.d*=t}if(i>0){const t=w.c,e=w.d,s=Math.atan2(e,t);let a=Math.atan2(u,d)-Math.atan2(m,l)-(s-Math.atan2(w.b,w.a));a>n.cj.PI?a-=n.cj.PI2:a<-n.cj.PI&&(a+=n.cj.PI2),a=s+(a+p)*i;const r=Math.sqrt(t*t+e*e);w.c=Math.cos(a)*r,w.d=Math.sin(a)*r}f.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,e=this.mixX,s=this.mixY,a=this.mixScaleX,r=this.mixScaleY,i=this.mixShearY,o=0!=e||0!=s,h=this.target,c=h.matrix,l=c.a,d=c.c,m=c.b,u=c.d,f=l*u-d*m>0?n.cj.degRad:-n.cj.degRad,g=this.data.offsetRotation*f,p=this.data.offsetShearY*f,x=this.bones;for(let c=0,f=x.length;c<f;c++){const f=x[c],w=f.matrix;if(0!=t){const e=w.a,s=w.c,a=w.b,r=w.d;let i=Math.atan2(m,l)+g;i>n.cj.PI?i-=n.cj.PI2:i<-n.cj.PI&&(i+=n.cj.PI2),i*=t;const o=Math.cos(i),h=Math.sin(i);w.a=o*e-h*a,w.c=o*s-h*r,w.b=h*e+o*a,w.d=h*s+o*r}if(o){const t=this.temp;h.localToWorld(t.set(this.data.offsetX,this.data.offsetY)),w.tx+=t.x*e,w.ty+=t.y*s}if(0!=a){const t=(Math.sqrt(l*l+m*m)-1+this.data.offsetScaleX)*a+1;w.a*=t,w.b*=t}if(0!=r){const t=(Math.sqrt(d*d+u*u)-1+this.data.offsetScaleY)*r+1;w.c*=t,w.d*=t}if(i>0){let t=Math.atan2(u,d)-Math.atan2(m,l);t>n.cj.PI?t-=n.cj.PI2:t<-n.cj.PI&&(t+=n.cj.PI2);const e=w.c,s=w.d;t=Math.atan2(s,e)+(t-n.cj.PI/2+p)*i;const a=Math.sqrt(e*e+s*s);w.c=Math.cos(t)*a,w.d=Math.sin(t)*a}f.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,a=this.mixScaleY,r=this.mixShearY,i=this.target,o=this.bones;for(let h=0,c=o.length;h<c;h++){const c=o[h];let l=c.arotation;if(0!=t){let e=i.arotation-l+this.data.offsetRotation;e-=360*(16384-(16384.499999999996-e/360|0)),l+=e*t}let d=c.ax,m=c.ay;d+=(i.ax-d+this.data.offsetX)*e,m+=(i.ay-m+this.data.offsetY)*s;let u=c.ascaleX,f=c.ascaleY;0!=n&&0!=u&&(u=(u+(i.ascaleX-u+this.data.offsetScaleX)*n)/u),0!=a&&0!=f&&(f=(f+(i.ascaleY-f+this.data.offsetScaleY)*a)/f);let g=c.ashearY;if(0!=r){let t=i.ashearY-g+this.data.offsetShearY;t-=360*(16384-(16384.499999999996-t/360|0)),g+=t*r}c.updateWorldTransformWith(d,m,l,u,f,c.ashearX,g)}}applyRelativeLocal(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,a=this.mixScaleY,r=this.mixShearY,i=this.target,o=this.bones;for(let h=0,c=o.length;h<c;h++){const c=o[h],l=c.arotation+(i.arotation+this.data.offsetRotation)*t,d=c.ax+(i.ax+this.data.offsetX)*e,m=c.ay+(i.ay+this.data.offsetY)*s,u=c.ascaleX*((i.ascaleX-1+this.data.offsetScaleX)*n+1),f=c.ascaleY*((i.ascaleY-1+this.data.offsetScaleY)*a+1),g=c.ashearY+(i.ashearY+this.data.offsetShearY)*r;c.updateWorldTransformWith(d,m,l,u,f,c.ashearX,g)}}}const Ft=class{constructor(t){if(this._updateCache=new Array,this.skin=null,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,!t)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){const s=t.bones[e];let n;if(s.parent){const t=this.bones[s.parent.index];n=new ft(s,this,t),t.children.push(n)}else n=new ft(s,this,null);this.bones.push(n)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){const s=t.slots[e],n=this.bones[s.boneData.index],a=new It(s,n);this.slots.push(a),this.drawOrder.push(a)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){const s=t.ikConstraints[e];this.ikConstraints.push(new bt(s,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){const s=t.transformConstraints[e];this.transformConstraints.push(new vt(s,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){const s=t.pathConstraints[e];this.pathConstraints.push(new qt(s,this))}this.color=new n.Q1(1,1,1,1),this.updateCache()}updateCache(){this._updateCache.length=0;const t=this.bones;for(let e=0,s=t.length;e<s;e++){const s=t[e];s.sorted=s.data.skinRequired,s.active=!s.sorted}if(this.skin){const t=this.skin.bones;for(let e=0,s=this.skin.bones.length;e<s;e++){let s=this.bones[t[e].index];do{s.sorted=!1,s.active=!0,s=s.parent}while(s)}}const e=this.ikConstraints,s=this.transformConstraints,n=this.pathConstraints,a=e.length,r=s.length,i=n.length,o=a+r+i;t:for(let t=0;t<o;t++){for(let s=0;s<a;s++){const n=e[s];if(n.data.order==t){this.sortIkConstraint(n);continue t}}for(let e=0;e<r;e++){const n=s[e];if(n.data.order==t){this.sortTransformConstraint(n);continue t}}for(let e=0;e<i;e++){const s=n[e];if(s.data.order==t){this.sortPathConstraint(s);continue t}}}for(let e=0,s=t.length;e<s;e++)this.sortBone(t[e])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&n.Aq.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target;this.sortBone(e);const s=t.bones,a=s[0];if(this.sortBone(a),1==s.length)this._updateCache.push(t),this.sortReset(a.children);else{const e=s[s.length-1];this.sortBone(e),this._updateCache.push(t),this.sortReset(a.children),e.sorted=!0}}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||this.skin&&n.Aq.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target,s=e.data.index,a=e.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,s,a),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,a);for(let t=0,e=this.data.skins.length;t<e;t++)this.sortPathConstraintAttachment(this.data.skins[t],s,a);const r=e.getAttachment();r instanceof l&&this.sortPathConstraintAttachmentWith(r,a);const i=t.bones,o=i.length;for(let t=0;t<o;t++)this.sortBone(i[t]);this._updateCache.push(t);for(let t=0;t<o;t++)this.sortReset(i[t].children);for(let t=0;t<o;t++)i[t].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&n.Aq.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);const e=t.bones,s=e.length;if(t.data.local)for(let t=0;t<s;t++){const s=e[t];this.sortBone(s.parent),this.sortBone(s)}else for(let t=0;t<s;t++)this.sortBone(e[t]);this._updateCache.push(t);for(let t=0;t<s;t++)this.sortReset(e[t].children);for(let t=0;t<s;t++)e[t].sorted=!0}sortPathConstraintAttachment(t,e,s){const n=t.attachments[e];if(n)for(const t in n)this.sortPathConstraintAttachmentWith(n[t],s)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof l))return;const s=t.bones;if(s){const t=this.bones;for(let e=0,n=s.length;e<n;){let n=s[e++];for(n+=e;e<n;)this.sortBone(t[s[e++]])}}else this.sortBone(e)}sortBone(t){if(!t)return;if(t.sorted)return;const e=t.parent;e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,s=t.length;e<s;e++){const s=t[e];s.active&&(s.sorted&&this.sortReset(s.children),s.sorted=!1)}}updateWorldTransform(){const t=this.bones;for(let e=0,s=t.length;e<s;e++){const s=t[e];s.ax=s.x,s.ay=s.y,s.arotation=s.rotation,s.ascaleX=s.scaleX,s.ascaleY=s.scaleY,s.ashearX=s.shearX,s.ashearY=s.shearY}const e=this._updateCache;for(let t=0,s=e.length;t<s;t++)e[t].update()}updateWorldTransformWith(t){const e=this.getRootBone(),s=t.matrix.a,a=t.matrix.c,r=t.matrix.b,i=t.matrix.d;e.matrix.tx=s*this.x+a*this.y+t.worldX,e.matrix.ty=r*this.x+i*this.y+t.worldY;const o=e.rotation+90+e.shearY,h=n.cj.cosDeg(e.rotation+e.shearX)*e.scaleX,c=n.cj.cosDeg(o)*e.scaleY,l=n.cj.sinDeg(e.rotation+e.shearX)*e.scaleX,d=n.cj.sinDeg(o)*e.scaleY,m=this.scaleX,u=n.W0.yDown?-this.scaleY:this.scaleY;e.matrix.a=(s*h+a*l)*m,e.matrix.c=(s*c+a*d)*m,e.matrix.b=(r*h+i*l)*u,e.matrix.d=(r*c+i*d)*u;const f=this._updateCache;for(let t=0,s=f.length;t<s;t++){const s=f[t];s!=e&&s.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let e=0,s=t.length;e<s;e++)t[e].setToSetupPose();const e=this.ikConstraints;for(let t=0,s=e.length;t<s;t++){const s=e[t];s.mix=s.data.mix,s.softness=s.data.softness,s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch}const s=this.transformConstraints;for(let t=0,e=s.length;t<e;t++){const e=s[t],n=e.data;e.mixRotate=n.mixRotate,e.mixX=n.mixX,e.mixY=n.mixY,e.mixScaleX=n.mixScaleX,e.mixScaleY=n.mixScaleY,e.mixShearY=n.mixShearY}const n=this.pathConstraints;for(let t=0,e=n.length;t<e;t++){const e=n[t],s=e.data;e.position=s.position,e.spacing=s.spacing,e.mixRotate=s.mixRotate,e.mixX=s.mixX,e.mixY=s.mixY}}setSlotsToSetupPose(){const t=this.slots;n.Aq.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,s=t.length;e<s;e++)t[e].setToSetupPose()}getRootBone(){return 0==this.bones.length?null:this.bones[0]}findBone(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const n=e[s];if(n.data.name==t)return n}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const n=e[s];if(n.data.name==t)return n}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}setSkinByName(t){const e=this.data.findSkin(t);if(!e)throw new Error(`Skin not found: ${t}`);this.setSkin(e)}setSkin(t){if(t!=this.skin){if(t)if(this.skin)t.attachAll(this,this.skin);else{const e=this.slots;for(let s=0,n=e.length;s<n;s++){const n=e[s],a=n.data.attachmentName;if(a){const e=t.getAttachment(s,a);e&&n.setAttachment(e)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,e){const s=this.data.findSlot(t);if(!s)throw new Error(`Can't find slot with name ${t}`);return this.getAttachment(s.index,e)}getAttachment(t,e){if(!e)throw new Error("attachmentName cannot be null.");if(this.skin){const s=this.skin.getAttachment(t,e);if(s)return s}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(!t)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,a=s.length;n<a;n++){const a=s[n];if(a.data.name==t){let s=null;if(e&&(s=this.getAttachment(n,e),!s))throw new Error(`Attachment not found: ${e}, for slot: ${t}`);return void a.setAttachment(s)}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const n=e[s];if(n.data.name==t)return n}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const n=e[s];if(n.data.name==t)return n}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const n=e[s];if(n.data.name==t)return n}return null}getBoundsRect(){const t=new n.I9,e=new n.I9;return this.getBounds(t,e),{x:t.x,y:t.y,width:e.x,height:e.y}}getBounds(t,e,s=new Array(2)){if(!t)throw new Error("offset cannot be null.");if(!e)throw new Error("size cannot be null.");const a=this.drawOrder;let r=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY,h=Number.NEGATIVE_INFINITY;for(let t=0,e=a.length;t<e;t++){const e=a[t];if(!e.bone.active)continue;let l=0,d=null;const m=e.getAttachment();if(m instanceof u)l=8,d=n.Aq.setArraySize(s,l,0),m.computeWorldVertices(e,d,0,2);else if(m instanceof c){const t=m;l=t.worldVerticesLength,d=n.Aq.setArraySize(s,l,0),t.computeWorldVertices(e,0,l,d,0,2)}if(d)for(let t=0,e=d.length;t<e;t+=2){const e=d[t],s=d[t+1];r=Math.min(r,e),i=Math.min(i,s),o=Math.max(o,e),h=Math.max(h,s)}}t.set(r,i),e.set(o-r,h-i)}get flipX(){return-1==this.scaleX}set flipX(t){Ft.deprecatedWarning1||(Ft.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return-1==this.scaleY}set flipY(t){Ft.deprecatedWarning1||(Ft.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};let Yt=Ft;Yt.deprecatedWarning1=!1;class Ct{constructor(){this.name=null,this.bones=new Array,this.slots=new Array,this.skins=new Array,this.defaultSkin=null,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.x=0,this.y=0,this.width=0,this.height=0,this.version=null,this.hash=null,this.fps=0,this.imagesPath=null,this.audioPath=null}findBone(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const n=e[s];if(n.name==t)return n}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const n=e[s];if(n.name==t)return n}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const e=this.skins;for(let s=0,n=e.length;s<n;s++){const n=e[s];if(n.name==t)return n}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const e=this.events;for(let s=0,n=e.length;s<n;s++){const n=e[s];if(n.name==t)return n}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const e=this.animations;for(let s=0,n=e.length;s<n;s++){const n=e[s];if(n.name==t)return n}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const n=e[s];if(n.name==t)return n}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const n=e[s];if(n.name==t)return n}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const n=e[s];if(n.name==t)return n}return null}findPathConstraintIndex(t){if(null==t)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}}class Mt{constructor(t,e,s){if(this.index=0,this.color=new n.Q1(1,1,1,1),this.darkColor=null,this.attachmentName=null,this.blendMode=ut.B9.NORMAL,t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");if(!s)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=s}}class Xt extends pt{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class Tt{constructor(t,e,s){this.slotIndex=t,this.name=e,this.attachment=s}}class Bt{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,e,s){if(!s)throw new Error("attachment cannot be null.");const n=this.attachments;t>=n.length&&(n.length=t+1),n[t]||(n[t]={}),n[t][e]=s}addSkin(t){for(let e=0;e<t.bones.length;e++){const s=t.bones[e];let n=!1;for(let t=0;t<this.bones.length;t++)if(this.bones[t]==s){n=!0;break}n||this.bones.push(s)}for(let e=0;e<t.constraints.length;e++){const s=t.constraints[e];let n=!1;for(let t=0;t<this.constraints.length;t++)if(this.constraints[t]==s){n=!0;break}n||this.constraints.push(s)}const e=t.getAttachments();for(let t=0;t<e.length;t++){const s=e[t];this.setAttachment(s.slotIndex,s.name,s.attachment)}}copySkin(t){for(let e=0;e<t.bones.length;e++){const s=t.bones[e];let n=!1;for(let t=0;t<this.bones.length;t++)if(this.bones[t]==s){n=!0;break}n||this.bones.push(s)}for(let e=0;e<t.constraints.length;e++){const s=t.constraints[e];let n=!1;for(let t=0;t<this.constraints.length;t++)if(this.constraints[t]==s){n=!0;break}n||this.constraints.push(s)}const e=t.getAttachments();for(let t=0;t<e.length;t++){const s=e[t];s.attachment&&(s.attachment instanceof c?(s.attachment=s.attachment.newLinkedMesh(),this.setAttachment(s.slotIndex,s.name,s.attachment)):(s.attachment=s.attachment.copy(),this.setAttachment(s.slotIndex,s.name,s.attachment)))}}getAttachment(t,e){const s=this.attachments[t];return s?s[e]:null}removeAttachment(t,e){const s=this.attachments[t];s&&delete s[e]}getAttachments(){const t=new Array;for(let e=0;e<this.attachments.length;e++){const s=this.attachments[e];if(s)for(const n in s){const a=s[n];a&&t.push(new Tt(e,n,a))}}return t}getAttachmentsForSlot(t,e){const s=this.attachments[t];if(s)for(const n in s){const a=s[n];a&&e.push(new Tt(t,n,a))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,e){let s=0;for(let n=0;n<t.slots.length;n++){const a=t.slots[n],r=a.getAttachment();if(r&&s<e.attachments.length){const t=e.attachments[s];for(const e in t)if(r==t[e]){const t=this.getAttachment(s,e);t&&a.setAttachment(t);break}}s++}}}class Et{constructor(t){this.ver40=!1,this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new Ct;s.name="";const a=new n.aG(t),r=a.readInt32(),i=a.readInt32();s.hash=0==i&&0==r?null:i.toString(16)+r.toString(16),s.version=a.readString();const o=s.version.substr(0,3);if("4.0"!==o&&"4.1"!==o){const t=`Spine 4.1 loader cant load version ${s.version}. Please configure your pixi-spine bundle`;console.error(t)}this.ver40="4.0"===o,s.x=a.readFloat(),s.y=a.readFloat(),s.width=a.readFloat(),s.height=a.readFloat();const h=a.readBoolean();h&&(s.fps=a.readFloat(),s.imagesPath=a.readString(),s.audioPath=a.readString());let c=0;c=a.readInt(!0);for(let t=0;t<c;t++){const t=a.readString();if(!t)throw new Error("String in string table must not be null.");a.strings.push(t)}c=a.readInt(!0);for(let t=0;t<c;t++){const r=a.readString();if(!r)throw new Error("Bone name must not be null.");const i=0==t?null:s.bones[a.readInt(!0)],o=new gt(t,r,i);o.rotation=a.readFloat(),o.x=a.readFloat()*e,o.y=a.readFloat()*e,o.scaleX=a.readFloat(),o.scaleY=a.readFloat(),o.shearX=a.readFloat(),o.shearY=a.readFloat(),o.length=a.readFloat()*e,o.transformMode=a.readInt(!0),o.skinRequired=a.readBoolean(),h&&n.Q1.rgba8888ToColor(o.color,a.readInt32()),s.bones.push(o)}c=a.readInt(!0);for(let t=0;t<c;t++){const e=a.readString();if(!e)throw new Error("Slot name must not be null.");const r=s.bones[a.readInt(!0)],i=new Mt(t,e,r);n.Q1.rgba8888ToColor(i.color,a.readInt32());const o=a.readInt32();-1!=o&&n.Q1.rgb888ToColor(i.darkColor=new n.Q1,o),i.attachmentName=a.readStringRef(),i.blendMode=a.readInt(!0),s.slots.push(i)}c=a.readInt(!0);for(let t,n=0;n<c;n++){const n=a.readString();if(!n)throw new Error("IK constraint data name must not be null.");const r=new yt(n);r.order=a.readInt(!0),r.skinRequired=a.readBoolean(),t=a.readInt(!0);for(let e=0;e<t;e++)r.bones.push(s.bones[a.readInt(!0)]);r.target=s.bones[a.readInt(!0)],r.mix=a.readFloat(),r.softness=a.readFloat()*e,r.bendDirection=a.readByte(),r.compress=a.readBoolean(),r.stretch=a.readBoolean(),r.uniform=a.readBoolean(),s.ikConstraints.push(r)}c=a.readInt(!0);for(let t,n=0;n<c;n++){const n=a.readString();if(!n)throw new Error("Transform constraint data name must not be null.");const r=new Xt(n);r.order=a.readInt(!0),r.skinRequired=a.readBoolean(),t=a.readInt(!0);for(let e=0;e<t;e++)r.bones.push(s.bones[a.readInt(!0)]);r.target=s.bones[a.readInt(!0)],r.local=a.readBoolean(),r.relative=a.readBoolean(),r.offsetRotation=a.readFloat(),r.offsetX=a.readFloat()*e,r.offsetY=a.readFloat()*e,r.offsetScaleX=a.readFloat(),r.offsetScaleY=a.readFloat(),r.offsetShearY=a.readFloat(),r.mixRotate=a.readFloat(),r.mixX=a.readFloat(),r.mixY=a.readFloat(),r.mixScaleX=a.readFloat(),r.mixScaleY=a.readFloat(),r.mixShearY=a.readFloat(),s.transformConstraints.push(r)}c=a.readInt(!0);for(let t,r=0;r<c;r++){const r=a.readString();if(!r)throw new Error("Path constraint data name must not be null.");const i=new kt(r);i.order=a.readInt(!0),i.skinRequired=a.readBoolean(),t=a.readInt(!0);for(let e=0;e<t;e++)i.bones.push(s.bones[a.readInt(!0)]);i.target=s.slots[a.readInt(!0)],i.positionMode=a.readInt(!0),i.spacingMode=a.readInt(!0),i.rotateMode=a.readInt(!0),i.offsetRotation=a.readFloat(),i.position=a.readFloat(),i.positionMode==n.pw.Fixed&&(i.position*=e),i.spacing=a.readFloat(),i.spacingMode!=At.Length&&i.spacingMode!=At.Fixed||(i.spacing*=e),i.mixRotate=a.readFloat(),i.mixX=a.readFloat(),i.mixY=a.readFloat(),s.pathConstraints.push(i)}const l=this.readSkin(a,s,!0,h);l&&(s.defaultSkin=l,s.skins.push(l));{let t=s.skins.length;for(n.Aq.setArraySize(s.skins,c=t+a.readInt(!0));t<c;t++){const e=this.readSkin(a,s,!1,h);if(!e)throw new Error("readSkin() should not have returned null.");s.skins[t]=e}}c=this.linkedMeshes.length;for(let t=0;t<c;t++){const e=this.linkedMeshes[t],n=e.skin?s.findSkin(e.skin):s.defaultSkin;if(!n)throw new Error("Not skin found for linked mesh.");if(!e.parent)throw new Error("Linked mesh parent must not be null");const a=n.getAttachment(e.slotIndex,e.parent);if(!a)throw new Error(`Parent mesh not found: ${e.parent}`);e.mesh.timelineAttachment=e.inheritTimeline?a:e.mesh,e.mesh.setParentMesh(a)}this.linkedMeshes.length=0,c=a.readInt(!0);for(let t=0;t<c;t++){const t=a.readStringRef();if(!t)throw new Error;const e=new wt(t);e.intValue=a.readInt(!1),e.floatValue=a.readFloat(),e.stringValue=a.readString(),e.audioPath=a.readString(),e.audioPath&&(e.volume=a.readFloat(),e.balance=a.readFloat()),s.events.push(e)}c=a.readInt(!0);for(let t=0;t<c;t++){const t=a.readString();if(!t)throw new Error("Animatio name must not be null.");s.animations.push(this.readAnimation(a,t,s))}return s}readSkin(t,e,s,n){let a=null,r=0;if(s){if(r=t.readInt(!0),0==r)return null;a=new Bt("default")}else{const s=t.readStringRef();if(!s)throw new Error("Skin name must not be null.");a=new Bt(s),a.bones.length=t.readInt(!0);for(let s=0,n=a.bones.length;s<n;s++)a.bones[s]=e.bones[t.readInt(!0)];for(let s=0,n=t.readInt(!0);s<n;s++)a.constraints.push(e.ikConstraints[t.readInt(!0)]);for(let s=0,n=t.readInt(!0);s<n;s++)a.constraints.push(e.transformConstraints[t.readInt(!0)]);for(let s=0,n=t.readInt(!0);s<n;s++)a.constraints.push(e.pathConstraints[t.readInt(!0)]);r=t.readInt(!0)}for(let s=0;s<r;s++){const s=t.readInt(!0);for(let r=0,i=t.readInt(!0);r<i;r++){const r=t.readStringRef();if(!r)throw new Error("Attachment name must not be null");const i=this.readAttachment(t,e,a,s,r,n);i&&a.setAttachment(s,r,i)}}return a}readAttachment(t,e,s,a,r,i){const o=this.scale;let h=t.readStringRef();switch(h||(h=r),t.readByte()){case n.wh.Region:{let e=t.readStringRef();const a=t.readFloat(),r=t.readFloat(),i=t.readFloat(),c=t.readFloat(),l=t.readFloat(),d=t.readFloat(),m=t.readFloat(),u=t.readInt32(),f=this.readSequence(t);e||(e=h);const g=this.attachmentLoader.newRegionAttachment(s,h,e,f);return g?(g.path=e,g.x=r*o,g.y=i*o,g.scaleX=c,g.scaleY=l,g.rotation=a,g.width=d*o,g.height=m*o,n.Q1.rgba8888ToColor(g.color,u),g.sequence=f,null==f&&g.updateRegion(),g):null}case n.wh.BoundingBox:{const e=t.readInt(!0),a=this.readVertices(t,e),r=i?t.readInt32():0,o=this.attachmentLoader.newBoundingBoxAttachment(s,h);return o?(o.worldVerticesLength=e<<1,o.vertices=a.vertices,o.bones=a.bones,i&&n.Q1.rgba8888ToColor(o.color,r),o):null}case n.wh.Mesh:{let e=t.readStringRef();const a=t.readInt32(),r=t.readInt(!0),c=this.readFloatArray(t,r<<1,1),l=this.readShortArray(t),d=this.readVertices(t,r),m=t.readInt(!0),u=this.readSequence(t);let f=[],g=0,p=0;i&&(f=this.readShortArray(t),g=t.readFloat(),p=t.readFloat()),e||(e=h);const x=this.attachmentLoader.newMeshAttachment(s,h,e,u);return x?(x.path=e,n.Q1.rgba8888ToColor(x.color,a),x.bones=d.bones,x.vertices=d.vertices,x.worldVerticesLength=r<<1,x.triangles=l,x.regionUVs=new Float32Array(c),x.hullLength=m<<1,x.sequence=u,i&&(x.edges=f,x.width=g*o,x.height=p*o),x):null}case n.wh.LinkedMesh:{let e=t.readStringRef();const r=t.readInt32(),c=t.readStringRef(),l=t.readStringRef(),d=t.readBoolean(),m=this.readSequence(t);let u=0,f=0;i&&(u=t.readFloat(),f=t.readFloat()),e||(e=h);const g=this.attachmentLoader.newMeshAttachment(s,h,e,m);return g?(g.path=e,n.Q1.rgba8888ToColor(g.color,r),g.sequence=m,i&&(g.width=u*o,g.height=f*o),this.linkedMeshes.push(new Ut(g,c,a,l,d)),g):null}case n.wh.Path:{const e=t.readBoolean(),a=t.readBoolean(),r=t.readInt(!0),c=this.readVertices(t,r),l=n.Aq.newArray(r/3,0);for(let e=0,s=l.length;e<s;e++)l[e]=t.readFloat()*o;const d=i?t.readInt32():0,m=this.attachmentLoader.newPathAttachment(s,h);return m?(m.closed=e,m.constantSpeed=a,m.worldVerticesLength=r<<1,m.vertices=c.vertices,m.bones=c.bones,m.lengths=l,i&&n.Q1.rgba8888ToColor(m.color,d),m):null}case n.wh.Point:{const e=t.readFloat(),a=t.readFloat(),r=t.readFloat(),c=i?t.readInt32():0,l=this.attachmentLoader.newPointAttachment(s,h);return l?(l.x=a*o,l.y=r*o,l.rotation=e,i&&n.Q1.rgba8888ToColor(l.color,c),l):null}case n.wh.Clipping:{const a=t.readInt(!0),r=t.readInt(!0),o=this.readVertices(t,r),c=i?t.readInt32():0,l=this.attachmentLoader.newClippingAttachment(s,h);return l?(l.endSlot=e.slots[a],l.worldVerticesLength=r<<1,l.vertices=o.vertices,l.bones=o.bones,i&&n.Q1.rgba8888ToColor(l.color,c),l):null}}return null}readSequence(t){if(this.ver40||!t.readBoolean())return null;const e=new g(t.readInt(!0));return e.start=t.readInt(!0),e.digits=t.readInt(!0),e.setupIndex=t.readInt(!0),e}readDeformTimelineType(t){return this.ver40?se:t.readByte()}readVertices(t,e){const s=this.scale,a=e<<1,r=new Rt;if(!t.readBoolean())return r.vertices=this.readFloatArray(t,a,s),r;const i=new Array,o=new Array;for(let n=0;n<e;n++){const e=t.readInt(!0);o.push(e);for(let n=0;n<e;n++)o.push(t.readInt(!0)),i.push(t.readFloat()*s),i.push(t.readFloat()*s),i.push(t.readFloat())}return r.vertices=n.Aq.toFloatArray(i),r.bones=o,r}readFloatArray(t,e,s){const n=new Array(e);if(1==s)for(let s=0;s<e;s++)n[s]=t.readFloat();else for(let a=0;a<e;a++)n[a]=t.readFloat()*s;return n}readShortArray(t){const e=t.readInt(!0),s=new Array(e);for(let n=0;n<e;n++)s[n]=t.readShort();return s}readAnimation(t,e,s){t.readInt(!0);const a=new Array,r=this.scale;for(let e=0,s=t.readInt(!0);e<s;e++){const e=t.readInt(!0);for(let s=0,n=t.readInt(!0);s<n;s++){const s=t.readByte(),n=t.readInt(!0),r=n-1;switch(s){case Ht:{const s=new V(n,e);for(let e=0;e<n;e++)s.setFrame(e,t.readFloat(),t.readStringRef());a.push(s);break}case Kt:{const s=t.readInt(!0),i=new B(n,s,e);let o=t.readFloat(),h=t.readUnsignedByte()/255,c=t.readUnsignedByte()/255,l=t.readUnsignedByte()/255,d=t.readUnsignedByte()/255;for(let e=0,s=0;i.setFrame(e,o,h,c,l,d),e!=r;e++){const n=t.readFloat(),a=t.readUnsignedByte()/255,r=t.readUnsignedByte()/255,m=t.readUnsignedByte()/255,u=t.readUnsignedByte()/255;switch(t.readByte()){case oe:i.setStepped(e);break;case he:jt(t,i,s++,e,0,o,n,h,a,1),jt(t,i,s++,e,1,o,n,c,r,1),jt(t,i,s++,e,2,o,n,l,m,1),jt(t,i,s++,e,3,o,n,d,u,1)}o=n,h=a,c=r,l=m,d=u}a.push(i);break}case Jt:{const s=t.readInt(!0),i=new E(n,s,e);let o=t.readFloat(),h=t.readUnsignedByte()/255,c=t.readUnsignedByte()/255,l=t.readUnsignedByte()/255;for(let e=0,s=0;i.setFrame(e,o,h,c,l),e!=r;e++){const n=t.readFloat(),a=t.readUnsignedByte()/255,r=t.readUnsignedByte()/255,d=t.readUnsignedByte()/255;switch(t.readByte()){case oe:i.setStepped(e);break;case he:jt(t,i,s++,e,0,o,n,h,a,1),jt(t,i,s++,e,1,o,n,c,r,1),jt(t,i,s++,e,2,o,n,l,d,1)}o=n,h=a,c=r,l=d}a.push(i);break}case Zt:{const s=t.readInt(!0),i=new R(n,s,e);let o=t.readFloat(),h=t.readUnsignedByte()/255,c=t.readUnsignedByte()/255,l=t.readUnsignedByte()/255,d=t.readUnsignedByte()/255,m=t.readUnsignedByte()/255,u=t.readUnsignedByte()/255,f=t.readUnsignedByte()/255;for(let e=0,s=0;i.setFrame(e,o,h,c,l,d,m,u,f),e!=r;e++){const n=t.readFloat(),a=t.readUnsignedByte()/255,r=t.readUnsignedByte()/255,g=t.readUnsignedByte()/255,p=t.readUnsignedByte()/255,x=t.readUnsignedByte()/255,w=t.readUnsignedByte()/255,b=t.readUnsignedByte()/255;switch(t.readByte()){case oe:i.setStepped(e);break;case he:jt(t,i,s++,e,0,o,n,h,a,1),jt(t,i,s++,e,1,o,n,c,r,1),jt(t,i,s++,e,2,o,n,l,g,1),jt(t,i,s++,e,3,o,n,d,p,1),jt(t,i,s++,e,4,o,n,m,x,1),jt(t,i,s++,e,5,o,n,u,w,1),jt(t,i,s++,e,6,o,n,f,b,1)}o=n,h=a,c=r,l=g,d=p,m=x,u=w,f=b}a.push(i);break}case te:{const s=t.readInt(!0),i=new D(n,s,e);let o=t.readFloat(),h=t.readUnsignedByte()/255,c=t.readUnsignedByte()/255,l=t.readUnsignedByte()/255,d=t.readUnsignedByte()/255,m=t.readUnsignedByte()/255,u=t.readUnsignedByte()/255;for(let e=0,s=0;i.setFrame(e,o,h,c,l,d,m,u),e!=r;e++){const n=t.readFloat(),a=t.readUnsignedByte()/255,r=t.readUnsignedByte()/255,f=t.readUnsignedByte()/255,g=t.readUnsignedByte()/255,p=t.readUnsignedByte()/255,x=t.readUnsignedByte()/255;switch(t.readByte()){case oe:i.setStepped(e);break;case he:jt(t,i,s++,e,0,o,n,h,a,1),jt(t,i,s++,e,1,o,n,c,r,1),jt(t,i,s++,e,2,o,n,l,f,1),jt(t,i,s++,e,3,o,n,d,g,1),jt(t,i,s++,e,4,o,n,m,p,1),jt(t,i,s++,e,5,o,n,u,x,1)}o=n,h=a,c=r,l=f,d=g,m=p,u=x}a.push(i);break}case ee:{const s=new U(n,t.readInt(!0),e);let i=t.readFloat(),o=t.readUnsignedByte()/255;for(let e=0,n=0;s.setFrame(e,i,o),e!=r;e++){const a=t.readFloat(),r=t.readUnsignedByte()/255;switch(t.readByte()){case oe:s.setStepped(e);break;case he:jt(t,s,n++,e,0,i,a,o,r,1)}i=a,o=r}a.push(s)}}}}for(let e=0,s=t.readInt(!0);e<s;e++){const e=t.readInt(!0);for(let s=0,n=t.readInt(!0);s<n;s++){const s=t.readByte(),n=t.readInt(!0),i=t.readInt(!0);switch(s){case Pt:a.push(Dt(t,new S(n,i,e),1));break;case Lt:a.push(Vt(t,new q(n,i,e),r));break;case Wt:a.push(Dt(t,new I(n,i,e),r));break;case Nt:a.push(Dt(t,new v(n,i,e),r));break;case $t:a.push(Vt(t,new F(n,i,e),1));break;case _t:a.push(Dt(t,new Y(n,i,e),1));break;case Ot:a.push(Dt(t,new C(n,i,e),1));break;case zt:a.push(Vt(t,new M(n,i,e),1));break;case Qt:a.push(Dt(t,new X(n,i,e),1));break;case Gt:a.push(Dt(t,new T(n,i,e),1))}}}for(let e=0,s=t.readInt(!0);e<s;e++){const e=t.readInt(!0),s=t.readInt(!0),n=s-1,i=new $(s,t.readInt(!0),e);let o=t.readFloat(),h=t.readFloat(),c=t.readFloat()*r;for(let e=0,s=0;i.setFrame(e,o,h,c,t.readByte(),t.readBoolean(),t.readBoolean()),e!=n;e++){const n=t.readFloat(),a=t.readFloat(),l=t.readFloat()*r;switch(t.readByte()){case oe:i.setStepped(e);break;case he:jt(t,i,s++,e,0,o,n,h,a,1),jt(t,i,s++,e,1,o,n,c,l,r)}o=n,h=a,c=l}a.push(i)}for(let e=0,s=t.readInt(!0);e<s;e++){const e=t.readInt(!0),s=t.readInt(!0),n=s-1,r=new _(s,t.readInt(!0),e);let i=t.readFloat(),o=t.readFloat(),h=t.readFloat(),c=t.readFloat(),l=t.readFloat(),d=t.readFloat(),m=t.readFloat();for(let e=0,s=0;r.setFrame(e,i,o,h,c,l,d,m),e!=n;e++){const n=t.readFloat(),a=t.readFloat(),u=t.readFloat(),f=t.readFloat(),g=t.readFloat(),p=t.readFloat(),x=t.readFloat();switch(t.readByte()){case oe:r.setStepped(e);break;case he:jt(t,r,s++,e,0,i,n,o,a,1),jt(t,r,s++,e,1,i,n,h,u,1),jt(t,r,s++,e,2,i,n,c,f,1),jt(t,r,s++,e,3,i,n,l,g,1),jt(t,r,s++,e,4,i,n,d,p,1),jt(t,r,s++,e,5,i,n,m,x,1)}i=n,o=a,h=u,c=f,l=g,d=p,m=x}a.push(r)}for(let e=0,i=t.readInt(!0);e<i;e++){const e=t.readInt(!0),i=s.pathConstraints[e];for(let s=0,o=t.readInt(!0);s<o;s++)switch(t.readByte()){case ae:a.push(Dt(t,new O(t.readInt(!0),t.readInt(!0),e),i.positionMode==n.pw.Fixed?r:1));break;case re:a.push(Dt(t,new z(t.readInt(!0),t.readInt(!0),e),i.spacingMode==At.Length||i.spacingMode==At.Fixed?r:1));break;case ie:const s=new Q(t.readInt(!0),t.readInt(!0),e);let o=t.readFloat(),h=t.readFloat(),c=t.readFloat(),l=t.readFloat();for(let e=0,n=0,a=s.getFrameCount()-1;s.setFrame(e,o,h,c,l),e!=a;e++){const a=t.readFloat(),r=t.readFloat(),i=t.readFloat(),d=t.readFloat();switch(t.readByte()){case oe:s.setStepped(e);break;case he:jt(t,s,n++,e,0,o,a,h,r,1),jt(t,s,n++,e,1,o,a,c,i,1),jt(t,s,n++,e,2,o,a,l,d,1)}o=a,h=r,c=i,l=d}a.push(s)}}for(let e=0,i=t.readInt(!0);e<i;e++){const e=s.skins[t.readInt(!0)];for(let s=0,i=t.readInt(!0);s<i;s++){const s=t.readInt(!0);for(let i=0,o=t.readInt(!0);i<o;i++){const i=t.readStringRef();if(!i)throw new Error("attachmentName must not be null.");const o=e.getAttachment(s,i),h=this.readDeformTimelineType(t),c=t.readInt(!0),l=c-1;switch(h){case se:{const e=o,i=e.bones,h=e.vertices,d=i?h.length/3*2:h.length,m=t.readInt(!0),u=new j(c,m,s,e);let f=t.readFloat();for(let e=0,s=0;;e++){let a,o=t.readInt(!0);if(0==o)a=i?n.Aq.newFloatArray(d):h;else{a=n.Aq.newFloatArray(d);const e=t.readInt(!0);if(o+=e,1==r)for(let s=e;s<o;s++)a[s]=t.readFloat();else for(let s=e;s<o;s++)a[s]=t.readFloat()*r;if(!i)for(let t=0,e=a.length;t<e;t++)a[t]+=h[t]}if(u.setFrame(e,f,a),e==l)break;const c=t.readFloat();switch(t.readByte()){case oe:u.setStepped(e);break;case he:jt(t,u,s++,e,0,f,c,0,1,1)}f=c}a.push(u);break}case ne:{const e=new H(c,s,o);for(let s=0;s<c;s++){const n=t.readFloat(),a=t.readInt32();e.setFrame(s,n,x[15&a],a>>4,t.readFloat())}a.push(e);break}}}}}const i=t.readInt(!0);if(i>0){const e=new N(i),r=s.slots.length;for(let s=0;s<i;s++){const a=t.readFloat(),i=t.readInt(!0),o=n.Aq.newArray(r,0);for(let t=r-1;t>=0;t--)o[t]=-1;const h=n.Aq.newArray(r-i,0);let c=0,l=0;for(let e=0;e<i;e++){const e=t.readInt(!0);for(;c!=e;)h[l++]=c++;o[c+t.readInt(!0)]=c++}for(;c<r;)h[l++]=c++;for(let t=r-1;t>=0;t--)-1==o[t]&&(o[t]=h[--l]);e.setFrame(s,a,o)}a.push(e)}const o=t.readInt(!0);if(o>0){const e=new L(o);for(let n=0;n<o;n++){const a=t.readFloat(),r=s.events[t.readInt(!0)],i=new xt(a,r);i.intValue=t.readInt(!1),i.floatValue=t.readFloat(),i.stringValue=t.readBoolean()?t.readString():r.stringValue,i.data.audioPath&&(i.volume=t.readFloat(),i.balance=t.readFloat()),e.setFrame(n,i)}a.push(e)}let h=0;for(let t=0,e=a.length;t<e;t++)h=Math.max(h,a[t].getDuration());return new w(e,a,h)}}Et.BlendModeValues=[ut.B9.NORMAL,ut.B9.ADD,ut.B9.MULTIPLY,ut.B9.SCREEN];class Ut{constructor(t,e,s,n,a){this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritTimeline=a}}class Rt{constructor(t=null,e=null){this.bones=t,this.vertices=e}}function Dt(t,e,s){let n=t.readFloat(),a=t.readFloat()*s;for(let r=0,i=0,o=e.getFrameCount()-1;e.setFrame(r,n,a),r!=o;r++){const o=t.readFloat(),h=t.readFloat()*s;switch(t.readByte()){case oe:e.setStepped(r);break;case he:jt(t,e,i++,r,0,n,o,a,h,s)}n=o,a=h}return e}function Vt(t,e,s){let n=t.readFloat(),a=t.readFloat()*s,r=t.readFloat()*s;for(let i=0,o=0,h=e.getFrameCount()-1;e.setFrame(i,n,a,r),i!=h;i++){const h=t.readFloat(),c=t.readFloat()*s,l=t.readFloat()*s;switch(t.readByte()){case oe:e.setStepped(i);break;case he:jt(t,e,o++,i,0,n,h,a,c,s),jt(t,e,o++,i,1,n,h,r,l,s)}n=h,a=c,r=l}return e}function jt(t,e,s,n,a,r,i,o,h,c){e.setBezier(s,n,a,r,o,t.readFloat(),t.readFloat()*c,t.readFloat(),t.readFloat()*c,i,h)}const Pt=0,Lt=1,Wt=2,Nt=3,$t=4,_t=5,Ot=6,zt=7,Qt=8,Gt=9,Ht=0,Kt=1,Jt=2,Zt=3,te=4,ee=5,se=0,ne=1,ae=0,re=1,ie=2,oe=1,he=2;class ce extends n.S3{}class le{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new Ct,a="string"==typeof t?JSON.parse(t):t,r=a.skeleton;if(r){s.hash=r.hash,s.version=r.spine;const t=s.version.substr(0,3);if("4.0"!==t&&"4.1"!==t){const t=`Spine 4.1 loader cant load version ${r.spine}. Please configure your pixi-spine bundle`;console.error(t)}s.x=r.x,s.y=r.y,s.width=r.width,s.height=r.height,s.fps=r.fps,s.imagesPath=r.images}if(a.bones)for(let t=0;t<a.bones.length;t++){const r=a.bones[t];let i=null;const o=ge(r,"parent",null);if(null!=o&&(i=s.findBone(o),null==i))throw new Error(`Parent bone not found: ${o}`);const h=new gt(s.bones.length,r.name,i);h.length=ge(r,"length",0)*e,h.x=ge(r,"x",0)*e,h.y=ge(r,"y",0)*e,h.rotation=ge(r,"rotation",0),h.scaleX=ge(r,"scaleX",1),h.scaleY=ge(r,"scaleY",1),h.shearX=ge(r,"shearX",0),h.shearY=ge(r,"shearY",0),h.transformMode=n.Aq.enumValue(n._C,ge(r,"transform","Normal")),h.skinRequired=ge(r,"skin",!1);const c=ge(r,"color",null);c&&h.color.setFromString(c),s.bones.push(h)}if(a.slots)for(let t=0;t<a.slots.length;t++){const e=a.slots[t],r=s.findBone(e.bone);if(!r)throw new Error(`Couldn't find bone ${e.bone} for slot ${e.name}`);const i=new Mt(s.slots.length,e.name,r),o=ge(e,"color",null);o&&i.color.setFromString(o);const h=ge(e,"dark",null);h&&(i.darkColor=n.Q1.fromString(h)),i.attachmentName=ge(e,"attachment",null),i.blendMode=le.blendModeFromString(ge(e,"blend","normal")),s.slots.push(i)}if(a.ik)for(let t=0;t<a.ik.length;t++){const n=a.ik[t],r=new yt(n.name);r.order=ge(n,"order",0),r.skinRequired=ge(n,"skin",!1);for(let t=0;t<n.bones.length;t++){const e=n.bones[t],a=s.findBone(e);if(null==a)throw new Error(`IK bone not found: ${e}`);r.bones.push(a)}r.target=s.findBone(n.target),r.mix=ge(n,"mix",1),r.softness=ge(n,"softness",0)*e,r.bendDirection=ge(n,"bendPositive",!0)?1:-1,r.compress=ge(n,"compress",!1),r.stretch=ge(n,"stretch",!1),r.uniform=ge(n,"uniform",!1),s.ikConstraints.push(r)}if(a.transform)for(let t=0;t<a.transform.length;t++){const n=a.transform[t],r=new Xt(n.name);r.order=ge(n,"order",0),r.skinRequired=ge(n,"skin",!1);for(let t=0;t<n.bones.length;t++){const e=n.bones[t],a=s.findBone(e);if(!a)throw new Error(`Couldn't find bone ${e} for transform constraint ${n.name}.`);r.bones.push(a)}const i=n.target,o=s.findBone(i);if(!o)throw new Error(`Couldn't find target bone ${i} for transform constraint ${n.name}.`);r.target=o,r.local=ge(n,"local",!1),r.relative=ge(n,"relative",!1),r.offsetRotation=ge(n,"rotation",0),r.offsetX=ge(n,"x",0)*e,r.offsetY=ge(n,"y",0)*e,r.offsetScaleX=ge(n,"scaleX",0),r.offsetScaleY=ge(n,"scaleY",0),r.offsetShearY=ge(n,"shearY",0),r.mixRotate=ge(n,"mixRotate",1),r.mixX=ge(n,"mixX",1),r.mixY=ge(n,"mixY",r.mixX),r.mixScaleX=ge(n,"mixScaleX",1),r.mixScaleY=ge(n,"mixScaleY",r.mixScaleX),r.mixShearY=ge(n,"mixShearY",1),s.transformConstraints.push(r)}if(a.path)for(let t=0;t<a.path.length;t++){const r=a.path[t],i=new kt(r.name);i.order=ge(r,"order",0),i.skinRequired=ge(r,"skin",!1);for(let t=0;t<r.bones.length;t++){const e=r.bones[t],n=s.findBone(e);if(!n)throw new Error(`Couldn't find bone ${e} for path constraint ${r.name}.`);i.bones.push(n)}const o=r.target,h=s.findSlot(o);if(!h)throw new Error(`Couldn't find target slot ${o} for path constraint ${r.name}.`);i.target=h,i.positionMode=n.Aq.enumValue(n.pw,ge(r,"positionMode","Percent")),i.spacingMode=n.Aq.enumValue(At,ge(r,"spacingMode","Length")),i.rotateMode=n.Aq.enumValue(n.Dr,ge(r,"rotateMode","Tangent")),i.offsetRotation=ge(r,"rotation",0),i.position=ge(r,"position",0),i.positionMode==n.pw.Fixed&&(i.position*=e),i.spacing=ge(r,"spacing",0),i.spacingMode!=At.Length&&i.spacingMode!=At.Fixed||(i.spacing*=e),i.mixRotate=ge(r,"mixRotate",1),i.mixX=ge(r,"mixX",1),i.mixY=ge(r,"mixY",i.mixX),s.pathConstraints.push(i)}if(a.skins)for(let t=0;t<a.skins.length;t++){const e=a.skins[t],n=new Bt(e.name);if(e.bones)for(let t=0;t<e.bones.length;t++){const a=e.bones[t],r=s.findBone(a);if(!r)throw new Error(`Couldn't find bone ${a} for skin ${e.name}.`);n.bones.push(r)}if(e.ik)for(let t=0;t<e.ik.length;t++){const a=e.ik[t],r=s.findIkConstraint(a);if(!r)throw new Error(`Couldn't find IK constraint ${a} for skin ${e.name}.`);n.constraints.push(r)}if(e.transform)for(let t=0;t<e.transform.length;t++){const a=e.transform[t],r=s.findTransformConstraint(a);if(!r)throw new Error(`Couldn't find transform constraint ${a} for skin ${e.name}.`);n.constraints.push(r)}if(e.path)for(let t=0;t<e.path.length;t++){const a=e.path[t],r=s.findPathConstraint(a);if(!r)throw new Error(`Couldn't find path constraint ${a} for skin ${e.name}.`);n.constraints.push(r)}for(const t in e.attachments){const a=s.findSlot(t);if(!a)throw new Error(`Couldn't find slot ${t} for skin ${e.name}.`);const r=e.attachments[t];for(const t in r){const e=this.readAttachment(r[t],n,a.index,t,s);e&&n.setAttachment(a.index,t,e)}}s.skins.push(n),"default"==n.name&&(s.defaultSkin=n)}for(let t=0,e=this.linkedMeshes.length;t<e;t++){const e=this.linkedMeshes[t],n=e.skin?s.findSkin(e.skin):s.defaultSkin;if(!n)throw new Error(`Skin not found: ${e.skin}`);const a=n.getAttachment(e.slotIndex,e.parent);if(!a)throw new Error(`Parent mesh not found: ${e.parent}`);e.mesh.timelineAttachment=e.inheritTimeline?a:e.mesh,e.mesh.setParentMesh(a)}if(this.linkedMeshes.length=0,a.events)for(const t in a.events){const e=a.events[t],n=new wt(t);n.intValue=ge(e,"int",0),n.floatValue=ge(e,"float",0),n.stringValue=ge(e,"string",""),n.audioPath=ge(e,"audio",null),n.audioPath&&(n.volume=ge(e,"volume",1),n.balance=ge(e,"balance",0)),s.events.push(n)}if(a.animations)for(const t in a.animations){const e=a.animations[t];this.readAnimation(e,t,s)}return s}readAttachment(t,e,s,a,r){const i=this.scale;switch(a=ge(t,"name",a),ge(t,"type","region")){case"region":{const s=ge(t,"path",a),n=this.readSequence(ge(t,"sequence",null)),r=this.attachmentLoader.newRegionAttachment(e,a,s,n);if(!r)return null;r.path=s,r.x=ge(t,"x",0)*i,r.y=ge(t,"y",0)*i,r.scaleX=ge(t,"scaleX",1),r.scaleY=ge(t,"scaleY",1),r.rotation=ge(t,"rotation",0),r.width=t.width*i,r.height=t.height*i,r.sequence=n;const o=ge(t,"color",null);return o&&r.color.setFromString(o),r}case"boundingbox":{const s=this.attachmentLoader.newBoundingBoxAttachment(e,a);if(!s)return null;this.readVertices(t,s,t.vertexCount<<1);const n=ge(t,"color",null);return n&&s.color.setFromString(n),s}case"mesh":case"linkedmesh":{const n=ge(t,"path",a),r=this.readSequence(ge(t,"sequence",null)),o=this.attachmentLoader.newMeshAttachment(e,a,n,r);if(!o)return null;o.path=n;const h=ge(t,"color",null);h&&o.color.setFromString(h),o.width=ge(t,"width",0)*i,o.height=ge(t,"height",0)*i,o.sequence=r;const c=ge(t,"parent",null);if(c)return this.linkedMeshes.push(new de(o,ge(t,"skin",null),s,c,ge(t,"timelines",!0))),o;const l=t.uvs;return this.readVertices(t,o,l.length),o.triangles=t.triangles,o.regionUVs=new Float32Array(l),o.edges=ge(t,"edges",null),o.hullLength=2*ge(t,"hull",0),o}case"path":{const s=this.attachmentLoader.newPathAttachment(e,a);if(!s)return null;s.closed=ge(t,"closed",!1),s.constantSpeed=ge(t,"constantSpeed",!0);const r=t.vertexCount;this.readVertices(t,s,r<<1);const o=n.Aq.newArray(r/3,0);for(let e=0;e<t.lengths.length;e++)o[e]=t.lengths[e]*i;s.lengths=o;const h=ge(t,"color",null);return h&&s.color.setFromString(h),s}case"point":{const s=this.attachmentLoader.newPointAttachment(e,a);if(!s)return null;s.x=ge(t,"x",0)*i,s.y=ge(t,"y",0)*i,s.rotation=ge(t,"rotation",0);const n=ge(t,"color",null);return n&&s.color.setFromString(n),s}case"clipping":{const s=this.attachmentLoader.newClippingAttachment(e,a);if(!s)return null;const n=ge(t,"end",null);if(null!=n){const t=r.findSlot(n);if(null==t)throw new Error(`Clipping end slot not found: ${n}`);s.endSlot=t}const i=t.vertexCount;this.readVertices(t,s,i<<1);const o=ge(t,"color",null);return o&&s.color.setFromString(o),s}}return null}readSequence(t){if(null==t)return null;const e=new g(ge(t,"count",0));return e.start=ge(t,"start",1),e.digits=ge(t,"digits",0),e.setupIndex=ge(t,"setup",0),e}readVertices(t,e,s){const a=this.scale;e.worldVerticesLength=s;const r=t.vertices;if(s==r.length){const t=n.Aq.toFloatArray(r);if(1!=a)for(let e=0,s=r.length;e<s;e++)t[e]*=a;return void(e.vertices=t)}const i=new Array,o=new Array;for(let t=0,e=r.length;t<e;){const e=r[t++];o.push(e);for(let s=t+4*e;t<s;t+=4)o.push(r[t]),i.push(r[t+1]*a),i.push(r[t+2]*a),i.push(r[t+3])}e.bones=o,e.vertices=n.Aq.toFloatArray(i)}readAnimation(t,e,s){const a=this.scale,r=new Array;if(t.slots)for(const e in t.slots){const a=t.slots[e],i=s.findSlot(e);if(!i)throw new Error(`Slot not found: ${e}`);const o=i.index;for(const t in a){const e=a[t];if(!e)continue;const s=e.length;if("attachment"==t){const t=new V(s,o);for(let n=0;n<s;n++){const s=e[n];t.setFrame(n,ge(s,"time",0),ge(s,"name",null))}r.push(t)}else if("rgba"==t){const t=new B(s,s<<2,o);let a=e[0],i=ge(a,"time",0),h=n.Q1.fromString(a.color);for(let s=0,r=0;;s++){t.setFrame(s,i,h.r,h.g,h.b,h.a);const o=e[s+1];if(!o){t.shrink(r);break}const c=ge(o,"time",0),l=n.Q1.fromString(o.color),d=a.curve;d&&(r=fe(d,t,r,s,0,i,c,h.r,l.r,1),r=fe(d,t,r,s,1,i,c,h.g,l.g,1),r=fe(d,t,r,s,2,i,c,h.b,l.b,1),r=fe(d,t,r,s,3,i,c,h.a,l.a,1)),i=c,h=l,a=o}r.push(t)}else if("rgb"==t){const t=new E(s,3*s,o);let a=e[0],i=ge(a,"time",0),h=n.Q1.fromString(a.color);for(let s=0,r=0;;s++){t.setFrame(s,i,h.r,h.g,h.b);const o=e[s+1];if(!o){t.shrink(r);break}const c=ge(o,"time",0),l=n.Q1.fromString(o.color),d=a.curve;d&&(r=fe(d,t,r,s,0,i,c,h.r,l.r,1),r=fe(d,t,r,s,1,i,c,h.g,l.g,1),r=fe(d,t,r,s,2,i,c,h.b,l.b,1)),i=c,h=l,a=o}r.push(t)}else if("alpha"==t)r.push(me(e,new U(s,s,o),0,1));else if("rgba2"==t){const t=new R(s,7*s,o);let a=e[0],i=ge(a,"time",0),h=n.Q1.fromString(a.light),c=n.Q1.fromString(a.dark);for(let s=0,r=0;;s++){t.setFrame(s,i,h.r,h.g,h.b,h.a,c.r,c.g,c.b);const o=e[s+1];if(!o){t.shrink(r);break}const l=ge(o,"time",0),d=n.Q1.fromString(o.light),m=n.Q1.fromString(o.dark),u=a.curve;u&&(r=fe(u,t,r,s,0,i,l,h.r,d.r,1),r=fe(u,t,r,s,1,i,l,h.g,d.g,1),r=fe(u,t,r,s,2,i,l,h.b,d.b,1),r=fe(u,t,r,s,3,i,l,h.a,d.a,1),r=fe(u,t,r,s,4,i,l,c.r,m.r,1),r=fe(u,t,r,s,5,i,l,c.g,m.g,1),r=fe(u,t,r,s,6,i,l,c.b,m.b,1)),i=l,h=d,c=m,a=o}r.push(t)}else if("rgb2"==t){const t=new D(s,6*s,o);let a=e[0],i=ge(a,"time",0),h=n.Q1.fromString(a.light),c=n.Q1.fromString(a.dark);for(let s=0,r=0;;s++){t.setFrame(s,i,h.r,h.g,h.b,c.r,c.g,c.b);const o=e[s+1];if(!o){t.shrink(r);break}const l=ge(o,"time",0),d=n.Q1.fromString(o.light),m=n.Q1.fromString(o.dark),u=a.curve;u&&(r=fe(u,t,r,s,0,i,l,h.r,d.r,1),r=fe(u,t,r,s,1,i,l,h.g,d.g,1),r=fe(u,t,r,s,2,i,l,h.b,d.b,1),r=fe(u,t,r,s,3,i,l,c.r,m.r,1),r=fe(u,t,r,s,4,i,l,c.g,m.g,1),r=fe(u,t,r,s,5,i,l,c.b,m.b,1)),i=l,h=d,c=m,a=o}r.push(t)}}}if(t.bones)for(const e in t.bones){const n=t.bones[e],i=s.findBone(e);if(!i)throw new Error(`Bone not found: ${e}`);const o=i.index;for(const t in n){const e=n[t],s=e.length;if(0!=s)if("rotate"===t)r.push(me(e,new S(s,s,o),0,1));else if("translate"===t){const t=new q(s,s<<1,o);r.push(ue(e,t,"x","y",0,a))}else if("translatex"===t){const t=new I(s,s,o);r.push(me(e,t,0,a))}else if("translatey"===t){const t=new v(s,s,o);r.push(me(e,t,0,a))}else if("scale"===t){const t=new F(s,s<<1,o);r.push(ue(e,t,"x","y",1,1))}else if("scalex"===t){const t=new Y(s,s,o);r.push(me(e,t,1,1))}else if("scaley"===t){const t=new C(s,s,o);r.push(me(e,t,1,1))}else if("shear"===t){const t=new M(s,s<<1,o);r.push(ue(e,t,"x","y",0,1))}else if("shearx"===t){const t=new X(s,s,o);r.push(me(e,t,0,1))}else if("sheary"===t){const t=new T(s,s,o);r.push(me(e,t,0,1))}}}if(t.ik)for(const e in t.ik){const n=t.ik[e];let i=n[0];if(!i)continue;const o=s.findIkConstraint(e);if(!o)throw new Error(`IK Constraint not found: ${e}`);const h=s.ikConstraints.indexOf(o),c=new $(n.length,n.length<<1,h);let l=ge(i,"time",0),d=ge(i,"mix",1),m=ge(i,"softness",0)*a;for(let t=0,e=0;;t++){c.setFrame(t,l,d,m,ge(i,"bendPositive",!0)?1:-1,ge(i,"compress",!1),ge(i,"stretch",!1));const s=n[t+1];if(!s){c.shrink(e);break}const r=ge(s,"time",0),o=ge(s,"mix",1),h=ge(s,"softness",0)*a,u=i.curve;u&&(e=fe(u,c,e,t,0,l,r,d,o,1),e=fe(u,c,e,t,1,l,r,m,h,a)),l=r,d=o,m=h,i=s}r.push(c)}if(t.transform)for(const e in t.transform){const n=t.transform[e];let a=n[0];if(!a)continue;const i=s.findTransformConstraint(e);if(!i)throw new Error(`Transform constraint not found: ${e}`);const o=s.transformConstraints.indexOf(i),h=new _(n.length,6*n.length,o);let c=ge(a,"time",0),l=ge(a,"mixRotate",1),d=ge(a,"mixX",1),m=ge(a,"mixY",d),u=ge(a,"mixScaleX",1),f=ge(a,"mixScaleY",u);const g=ge(a,"mixShearY",1);for(let t=0,e=0;;t++){h.setFrame(t,c,l,d,m,u,f,g);const s=n[t+1];if(!s){h.shrink(e);break}const r=ge(s,"time",0),i=ge(s,"mixRotate",1),o=ge(s,"mixX",1),p=ge(s,"mixY",o),x=ge(s,"mixScaleX",1),w=ge(s,"mixScaleY",x),b=ge(s,"mixShearY",1),y=a.curve;y&&(e=fe(y,h,e,t,0,c,r,l,i,1),e=fe(y,h,e,t,1,c,r,d,o,1),e=fe(y,h,e,t,2,c,r,m,p,1),e=fe(y,h,e,t,3,c,r,u,x,1),e=fe(y,h,e,t,4,c,r,f,w,1),e=fe(y,h,e,t,5,c,r,g,b,1)),c=r,l=i,d=o,m=p,u=x,f=w,u=x,a=s}r.push(h)}if(t.path)for(const e in t.path){const i=t.path[e],o=s.findPathConstraint(e);if(!o)throw new Error(`Path constraint not found: ${e}`);const h=s.pathConstraints.indexOf(o);for(const t in i){const e=i[t];let s=e[0];if(!s)continue;const c=e.length;if("position"===t){const t=new O(c,c,h);r.push(me(e,t,0,o.positionMode==n.pw.Fixed?a:1))}else if("spacing"===t){const t=new z(c,c,h);r.push(me(e,t,0,o.spacingMode==At.Length||o.spacingMode==At.Fixed?a:1))}else if("mix"===t){const t=new Q(c,3*c,h);let n=ge(s,"time",0),a=ge(s,"mixRotate",1),i=ge(s,"mixX",1),o=ge(s,"mixY",i);for(let r=0,h=0;;r++){t.setFrame(r,n,a,i,o);const c=e[r+1];if(!c){t.shrink(h);break}const l=ge(c,"time",0),d=ge(c,"mixRotate",1),m=ge(c,"mixX",1),u=ge(c,"mixY",m),f=s.curve;f&&(h=fe(f,t,h,r,0,n,l,a,d,1),h=fe(f,t,h,r,1,n,l,i,m,1),h=fe(f,t,h,r,2,n,l,o,u,1)),n=l,a=d,i=m,o=u,s=c}r.push(t)}}}if(t.deform){t.attachments={};for(const e in t.deform){const s=t.deform[e],n=t.attachments[e]={};for(const t in s){const e=s[t],a=n[t]={};for(const t in e)a[t]={deform:e[t]}}}}if(t.attachments)for(const e in t.attachments){const i=t.attachments[e],o=s.findSkin(e);if(null!=o)for(const t in i){const e=i[t],h=s.findSlot(t);if(!h)throw new Error(`Slot not found: ${t}`);const c=h.index;for(const t in e){const s=e[t],i=o.getAttachment(c,t);for(const t in s){const e=s[t];let o=e[0];if(o)if("deform"==t){const t=i.bones,s=i.vertices,h=t?s.length/3*2:s.length,l=new j(e.length,e.length,c,i);let d=ge(o,"time",0);for(let r=0,i=0;;r++){let c;const m=ge(o,"vertices",null);if(m){c=n.Aq.newFloatArray(h);const e=ge(o,"offset",0);if(n.Aq.arrayCopy(m,0,c,e,m.length),1!=a)for(let t=e,s=t+m.length;t<s;t++)c[t]*=a;if(!t)for(let t=0;t<h;t++)c[t]+=s[t]}else c=t?n.Aq.newFloatArray(h):s;l.setFrame(r,d,c);const u=e[r+1];if(!u){l.shrink(i);break}const f=ge(u,"time",0),g=o.curve;g&&(i=fe(g,l,i,r,0,d,f,0,1,1)),d=f,o=u}r.push(l)}else if("sequence"==t){const t=new H(e.length,c,i);let s=0;for(let n=0;n<e.length;n++){const a=ge(o,"delay",s),r=ge(o,"time",0),i=p[ge(o,"mode","hold")],h=ge(o,"index",0);t.setFrame(n,r,i,h,a),s=a,o=e[n+1]}r.push(t)}}}}else if(n.W0.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${e}`)}if(t.drawOrder){const e=new N(t.drawOrder.length),a=s.slots.length;let i=0;for(let r=0;r<t.drawOrder.length;r++,i++){const o=t.drawOrder[r];let h=null;const c=ge(o,"offsets",null);if(c){h=n.Aq.newArray(a,-1);const t=n.Aq.newArray(a-c.length,0);let e=0,r=0;for(let n=0;n<c.length;n++){const a=c[n],i=s.findSlot(a.slot);if(!i)throw new Error(`Slot not found: ${i}`);const o=i.index;for(;e!=o;)t[r++]=e++;h[e+a.offset]=e++}for(;e<a;)t[r++]=e++;for(let e=a-1;e>=0;e--)-1==h[e]&&(h[e]=t[--r])}e.setFrame(i,ge(o,"time",0),h)}r.push(e)}if(t.events){const e=new L(t.events.length);let a=0;for(let r=0;r<t.events.length;r++,a++){const i=t.events[r],o=s.findEvent(i.name);if(!o)throw new Error(`Event not found: ${i.name}`);const h=new xt(n.Aq.toSinglePrecision(ge(i,"time",0)),o);h.intValue=ge(i,"int",o.intValue),h.floatValue=ge(i,"float",o.floatValue),h.stringValue=ge(i,"string",o.stringValue),h.data.audioPath&&(h.volume=ge(i,"volume",1),h.balance=ge(i,"balance",0)),e.setFrame(a,h)}r.push(e)}let i=0;for(let t=0,e=r.length;t<e;t++)i=Math.max(i,r[t].getDuration());if(isNaN(i))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new w(e,r,i))}static blendModeFromString(t){if("normal"==(t=t.toLowerCase()))return ut.B9.NORMAL;if("additive"==t)return ut.B9.ADD;if("multiply"==t)return ut.B9.MULTIPLY;if("screen"==t)return ut.B9.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}}class de{constructor(t,e,s,n,a){this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritTimeline=a}}function me(t,e,s,n){let a=t[0],r=ge(a,"time",0),i=ge(a,"value",s)*n,o=0;for(let h=0;;h++){e.setFrame(h,r,i);const c=t[h+1];if(!c)return e.shrink(o),e;const l=ge(c,"time",0),d=ge(c,"value",s)*n;a.curve&&(o=fe(a.curve,e,o,h,0,r,l,i,d,n)),r=l,i=d,a=c}}function ue(t,e,s,n,a,r){let i=t[0],o=ge(i,"time",0),h=ge(i,s,a)*r,c=ge(i,n,a)*r,l=0;for(let d=0;;d++){e.setFrame(d,o,h,c);const m=t[d+1];if(!m)return e.shrink(l),e;const u=ge(m,"time",0),f=ge(m,s,a)*r,g=ge(m,n,a)*r,p=i.curve;p&&(l=fe(p,e,l,d,0,o,u,h,f,r),l=fe(p,e,l,d,1,o,u,c,g,r)),o=u,h=f,c=g,i=m}}function fe(t,e,s,n,a,r,i,o,h,c){if("stepped"==t)return e.setStepped(n),s;const l=a<<2,d=t[l],m=t[l+1]*c,u=t[l+2],f=t[l+3]*c;return e.setBezier(s,n,a,r,o,d,m,u,f,i,h),s+1}function ge(t,e,s){return void 0!==t[e]?t[e]:s}class pe extends n.bJ{createSkeleton(t){this.skeleton=new Yt(t),this.skeleton.updateWorldTransform(),this.stateData=new dt(t),this.state=new J(this.stateData)}}}}]);