"use strict";(self.webpackChunkfederation_clients=self.webpackChunkfederation_clients||[]).push([["vendors-node_modules_pixi-spine_lib_index_mjs"],{"./node_modules/pixi-spine/lib/index.mjs":(t,e,n)=>{n.r(e),n.d(e,{AttachmentType:()=>r.wh,BinaryInput:()=>r.aG,Color:()=>r.Q1,DebugUtils:()=>r.lw,IntSet:()=>r.ON,Interpolation:()=>r.lc,MathUtils:()=>r.cj,MixBlend:()=>r.qU,MixDirection:()=>r.mj,Pool:()=>r.bC,PositionMode:()=>r.pw,Pow:()=>r.py,PowOut:()=>r.Ff,RotateMode:()=>r.Dr,SkeletonBounds:()=>an.SkeletonBounds,SkeletonBoundsBase:()=>r.S3,Spine:()=>dn,SpineBase:()=>r.bJ,SpineDebugRenderer:()=>r.Go,SpineMesh:()=>r.BO,SpineSprite:()=>r.pK,StringSet:()=>r.eE,TextureAtlas:()=>r.Lw,TextureAtlasPage:()=>r.gB,TextureAtlasRegion:()=>r.TE,TextureFilter:()=>r.O$,TextureRegion:()=>r.QL,TextureWrap:()=>r.w3,TimeKeeper:()=>r.oM,TransformMode:()=>r._C,Utils:()=>r.Aq,Vector2:()=>r.I9,WindowedMean:()=>r.p0,filterFromString:()=>r.ki,settings:()=>r.W0,wrapFromString:()=>r.iG});var s={};n.r(s),n.d(s,{Animation:()=>y,AnimationState:()=>et,AnimationStateAdapter:()=>ot,AnimationStateData:()=>ht,AtlasAttachmentLoader:()=>ct,Attachment:()=>u,AttachmentTimeline:()=>O,Bone:()=>dt,BoneData:()=>ut,BoundingBoxAttachment:()=>p,ClippingAttachment:()=>g,ColorTimeline:()=>D,ConstraintData:()=>mt,CurveTimeline:()=>V,DeformTimeline:()=>L,DrawOrderTimeline:()=>j,Event:()=>ft,EventData:()=>pt,EventQueue:()=>rt,EventTimeline:()=>U,EventType:()=>it,IkConstraint:()=>gt,IkConstraintData:()=>Et,IkConstraintTimeline:()=>$,JitterEffect:()=>M,MeshAttachment:()=>E,PathAttachment:()=>x,PathConstraint:()=>St,PathConstraintData:()=>xt,PathConstraintMixTimeline:()=>K,PathConstraintPositionTimeline:()=>Z,PathConstraintSpacingTimeline:()=>z,PointAttachment:()=>w,RegionAttachment:()=>b,RotateTimeline:()=>P,ScaleTimeline:()=>q,ShearTimeline:()=>F,Skeleton:()=>Tt,SkeletonBinary:()=>Pt,SkeletonBounds:()=>qt,SkeletonData:()=>Rt,SkeletonJson:()=>Ft,Skin:()=>Vt,SkinEntry:()=>Ct,Slot:()=>A,SlotData:()=>yt,SpacingMode:()=>wt,Spine:()=>Dt,SwirlEffect:()=>R,TimelineType:()=>I,TrackEntry:()=>st,TransformConstraint:()=>bt,TransformConstraintData:()=>It,TransformConstraintTimeline:()=>Q,TranslateTimeline:()=>v,TwoColorTimeline:()=>Y,VertexAttachment:()=>f});var a={};n.r(a),n.d(a,{Animation:()=>Jt,AnimationState:()=>Ie,AnimationStateAdapter2:()=>ve,AnimationStateData:()=>Fe,AtlasAttachmentLoader:()=>_e,Attachment:()=>Xt,AttachmentTimeline:()=>ue,Bone:()=>De,BoneData:()=>Xe,BoundingBoxAttachment:()=>Bt,ClippingAttachment:()=>Lt,ColorTimeline:()=>he,CurveTimeline:()=>ee,DeformTimeline:()=>fe,DrawOrderTimeline:()=>ge,Event:()=>Ye,EventData:()=>Oe,EventQueue:()=>Pe,EventTimeline:()=>pe,EventType:()=>Ne,IkConstraint:()=>Be,IkConstraintData:()=>Le,IkConstraintTimeline:()=>xe,JitterEffect:()=>Gt,MeshAttachment:()=>Ut,PathAttachment:()=>jt,PathConstraint:()=>$e,PathConstraintData:()=>Ue,PathConstraintMixTimeline:()=>Re,PathConstraintPositionTimeline:()=>be,PathConstraintSpacingTimeline:()=>Me,PointAttachment:()=>Wt,RegionAttachment:()=>Qt,RotateTimeline:()=>se,ScaleTimeline:()=>ie,ShearTimeline:()=>oe,Skeleton:()=>Ge,SkeletonBounds:()=>Ze,SkeletonData:()=>ze,SkeletonJson:()=>en,Skin:()=>tn,Slot:()=>$t,SlotData:()=>Je,SpacingMode:()=>je,Spine:()=>sn,SwirlEffect:()=>zt,TimelineType:()=>Kt,TrackEntry:()=>Ve,TransformConstraint:()=>He,TransformConstraintData:()=>Ke,TransformConstraintTimeline:()=>Ae,TranslateTimeline:()=>re,TwoColorTimeline:()=>de,VertexAttachment:()=>Ot});var r=n("./node_modules/@pixi-spine/base/lib/index.mjs"),i=n("./node_modules/@pixi/assets/lib/index.mjs"),o=n("./node_modules/@pixi/core/lib/index.mjs");const l={extension:o.Ag.Asset,loader:{extension:{type:o.Ag.LoadParser,priority:i.T9.Normal},test:t=>(0,i.WO)(t,".atlas"),async load(t){const e=await o.W0.ADAPTER.fetch(t);return await e.text()},testParse(t,e){const n=(0,i.WO)(e.src,".atlas"),s="string"==typeof t;return Promise.resolve(n&&s)},async parse(t,e,n){const s=e.data;let a=o.Wp.path.dirname(e.src);a&&a.lastIndexOf("/")!==a.length-1&&(a+="/");let i=null,l=null;const c=new Promise(((t,e)=>{i=t,l=e}));let d;const u=t=>{t||l("Something went terribly wrong loading a spine .atlas file\nMost likely your texture failed to load."),i(d)};if(s.image||s.images){const e=Object.assign(s.image?{default:s.image}:{},s.images);d=new r.Lw(t,((t,n)=>{const s=e[t]||e.default;s&&s.baseTexture?n(s.baseTexture):n(s)}),u)}else d=new r.Lw(t,h(n,a,s.imageMetadata),u);return await c},unload(t){t.dispose()}}},h=(t,e,n)=>async(s,a)=>{try{const r=o.Wp.path.normalize([...e.split(o.Wp.path.sep),s].join(o.Wp.path.sep));a((await t.load({src:r,data:n})).baseTexture)}catch(t){r.W0.REPORT_TEXTURE_LOADER_ERROR&&console.error("Spine: error in texture loader",t),a(null)}};function c(t){return t.hasOwnProperty("bones")}o.XO.add(l);class d{constructor(){}installLoader(){const t=this,e={extension:o.Ag.Asset,loader:{extension:{type:o.Ag.LoadParser,priority:i.T9.Normal},test:t=>(0,i.WO)(t,".skel"),async load(t){const e=await o.W0.ADAPTER.fetch(t);return await e.arrayBuffer()},testParse(t,e){const n=(0,i.WO)(e.src,".json")&&c(t),s=(0,i.WO)(e.src,".skel")&&t instanceof ArrayBuffer,a=!1===e.data?.spineAtlas;return Promise.resolve(n&&!a||s)},async parse(e,n,s){const a=o.Wp.path.extname(n.src).toLowerCase(),l=o.Wp.path.basename(n.src,a);let d=o.Wp.path.dirname(n.src);d&&d.lastIndexOf("/")!==d.length-1&&(d+="/");let u=null,m=e;(0,i.WO)(n.src,".json")&&c(e)?u=t.createJsonParser():(u=t.createBinaryParser(),m=new Uint8Array(e));const f=n.data||{},p=f?.spineSkeletonScale??null;p&&(u.scale=p);const g=f.spineAtlas;if(g&&g.pages)return t.parseData(u,g,m);const E=f.atlasRawData;if(E){let e=null,n=null;const a=new Promise(((t,s)=>{e=t,n=s})),i=new r.Lw(E,h(s,d,f.imageMetadata),(t=>{t||n("Something went terribly wrong loading a spine .atlas file\nMost likely your texture failed to load."),e(i)})),o=await a;return t.parseData(u,o,m)}let x=f.spineAtlasFile;x||(x=`${d+l}.atlas`);const w=await s.load({src:x,data:f,alias:f.spineAtlasAlias});return t.parseData(u,w,m)}}};return o.XO.add(e),e}}class u{constructor(t){if(null==t)throw new Error("name cannot be null.");this.name=t}}const m=class extends u{constructor(t){super(t),this.id=(65535&m.nextID++)<<11,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(t,e){this.computeWorldVertices(t,0,this.worldVerticesLength,e,0,2)}computeWorldVertices(t,e,n,s,a,r){n=a+(n>>1)*r;const i=t.bone.skeleton,o=t.deform;let l=this.vertices;const h=this.bones;if(null==h){o.length>0&&(l=o);const i=t.bone.matrix,h=i.tx,c=i.ty,d=i.a,u=i.c,m=i.b,f=i.d;for(let t=e,i=a;i<n;t+=2,i+=r){const e=l[t],n=l[t+1];s[i]=e*d+n*u+h,s[i+1]=e*m+n*f+c}return}let c=0,d=0;for(let t=0;t<e;t+=2){const t=h[c];c+=t+1,d+=t}const u=i.bones;if(0==o.length)for(let t=a,e=3*d;t<n;t+=r){let n=0,a=0,r=h[c++];for(r+=c;c<r;c++,e+=3){const t=u[h[c]].matrix,s=l[e],r=l[e+1],i=l[e+2];n+=(s*t.a+r*t.c+t.tx)*i,a+=(s*t.b+r*t.d+t.ty)*i}s[t]=n,s[t+1]=a}else{const t=o;for(let e=a,i=3*d,o=d<<1;e<n;e+=r){let n=0,a=0,r=h[c++];for(r+=c;c<r;c++,i+=3,o+=2){const e=u[h[c]].matrix,s=l[i]+t[o],r=l[i+1]+t[o+1],d=l[i+2];n+=(s*e.a+r*e.c+e.tx)*d,a+=(s*e.b+r*e.d+e.ty)*d}s[e]=n,s[e+1]=a}}}copyTo(t){null!=this.bones?(t.bones=new Array(this.bones.length),r.Aq.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,null!=this.vertices?(t.vertices=r.Aq.newFloatArray(this.vertices.length),r.Aq.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)):t.vertices=null,t.worldVerticesLength=this.worldVerticesLength,t.deformAttachment=this.deformAttachment}};let f=m;f.nextID=0;class p extends f{constructor(t){super(t),this.type=r.wh.BoundingBox,this.color=new r.Q1(1,1,1,1)}copy(){const t=new p(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class g extends f{constructor(t){super(t),this.type=r.wh.Clipping,this.color=new r.Q1(.2275,.2275,.8078,1)}copy(){const t=new g(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class E extends f{constructor(t){super(t),this.type=r.wh.Mesh,this.color=new r.Q1(1,1,1,1),this.tempColor=new r.Q1(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,null!=t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(null!=this.parentMesh)return this.newLinkedMesh();const t=new E(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),r.Aq.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),r.Aq.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,null!=this.edges&&(t.edges=new Array(this.edges.length),r.Aq.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new E(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(null!=this.parentMesh?this.parentMesh:this),t}}class x extends f{constructor(t){super(t),this.type=r.wh.Path,this.closed=!1,this.constantSpeed=!1,this.color=new r.Q1(1,1,1,1)}copy(){const t=new x(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),r.Aq.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class w extends f{constructor(t){super(t),this.type=r.wh.Point,this.color=new r.Q1(.38,.94,0,1)}computeWorldPosition(t,e){const n=t.matrix;return e.x=this.x*n.a+this.y*n.c+t.worldX,e.y=this.x*n.b+this.y*n.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,n=r.cj.cosDeg(this.rotation),s=r.cj.sinDeg(this.rotation),a=n*e.a+s*e.c,i=n*e.b+s*e.d;return Math.atan2(i,a)*r.cj.radDeg}copy(){const t=new w(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}class A{constructor(t,e){if(this.deform=new Array,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new r.Q1,this.darkColor=null==t.darkColor?null:new r.Q1,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),null!=this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),null==this.data.attachmentName?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const S=class extends u{constructor(t){super(t),this.type=r.wh.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new r.Q1(1,1,1,1),this.offset=r.Aq.newFloatArray(8),this.uvs=r.Aq.newFloatArray(8),this.tempColor=new r.Q1(1,1,1,1)}updateOffset(){const t=this.width/this.region.originalWidth*this.scaleX,e=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*t,s=-this.height/2*this.scaleY+this.region.offsetY*e,a=n+this.region.width*t,r=s+this.region.height*e,i=this.rotation*Math.PI/180,o=Math.cos(i),l=Math.sin(i),h=n*o+this.x,c=n*l,d=s*o+this.y,u=s*l,m=a*o+this.x,f=a*l,p=r*o+this.y,g=r*l,E=this.offset;E[S.OX1]=h-u,E[S.OY1]=d+c,E[S.OX2]=h-g,E[S.OY2]=p+c,E[S.OX3]=m-g,E[S.OY3]=p+f,E[S.OX4]=m-u,E[S.OY4]=d+f}setRegion(t){this.region=t;const e=this.uvs;t.rotate?(e[2]=t.u,e[3]=t.v2,e[4]=t.u,e[5]=t.v,e[6]=t.u2,e[7]=t.v,e[0]=t.u2,e[1]=t.v2):(e[0]=t.u,e[1]=t.v2,e[2]=t.u,e[3]=t.v,e[4]=t.u2,e[5]=t.v,e[6]=t.u2,e[7]=t.v2)}computeWorldVertices(t,e,n,s){const a=this.offset,r=t instanceof A?t.bone.matrix:t.matrix,i=r.tx,o=r.ty,l=r.a,h=r.c,c=r.b,d=r.d;let u=0,m=0;u=a[S.OX1],m=a[S.OY1],e[n]=u*l+m*h+i,e[n+1]=u*c+m*d+o,n+=s,u=a[S.OX2],m=a[S.OY2],e[n]=u*l+m*h+i,e[n+1]=u*c+m*d+o,n+=s,u=a[S.OX3],m=a[S.OY3],e[n]=u*l+m*h+i,e[n+1]=u*c+m*d+o,n+=s,u=a[S.OX4],m=a[S.OY4],e[n]=u*l+m*h+i,e[n+1]=u*c+m*d+o}copy(){const t=new S(this.name);return t.region=this.region,t.rendererObject=this.rendererObject,t.path=this.path,t.x=this.x,t.y=this.y,t.scaleX=this.scaleX,t.scaleY=this.scaleY,t.rotation=this.rotation,t.width=this.width,t.height=this.height,r.Aq.arrayCopy(this.uvs,0,t.uvs,0,8),r.Aq.arrayCopy(this.offset,0,t.offset,0,8),t.color.setFromColor(this.color),t}};let b=S;b.OX1=0,b.OY1=1,b.OX2=2,b.OY2=3,b.OX3=4,b.OY3=5,b.OX4=6,b.OY4=7,b.X1=0,b.Y1=1,b.C1R=2,b.C1G=3,b.C1B=4,b.C1A=5,b.U1=6,b.V1=7,b.X2=8,b.Y2=9,b.C2R=10,b.C2G=11,b.C2B=12,b.C2A=13,b.U2=14,b.V2=15,b.X3=16,b.Y3=17,b.C3R=18,b.C3G=19,b.C3B=20,b.C3A=21,b.U3=22,b.V3=23,b.X4=24,b.Y4=25,b.C4R=26,b.C4G=27,b.C4B=28,b.C4A=29,b.U4=30,b.V4=31;class M{constructor(t,e){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=e}begin(t){}transform(t,e,n,s){t.x+=r.cj.randomTriangular(-this.jitterX,this.jitterY),t.y+=r.cj.randomTriangular(-this.jitterX,this.jitterY)}end(){}}const T=class{constructor(t){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=t}begin(t){this.worldX=t.x+this.centerX,this.worldY=t.y+this.centerY}transform(t,e,n,s){const a=this.angle*r.cj.degreesToRadians,i=t.x-this.worldX,o=t.y-this.worldY,l=Math.sqrt(i*i+o*o);if(l<this.radius){const e=T.interpolation.apply(0,a,(this.radius-l)/this.radius),n=Math.cos(e),s=Math.sin(e);t.x=n*i-s*o+this.worldX,t.y=s*i+n*o+this.worldY}}end(){}};let R=T;R.interpolation=new r.Ff(2);class y{constructor(t,e,n){if(null==t)throw new Error("name cannot be null.");if(null==e)throw new Error("timelines cannot be null.");this.name=t,this.timelines=e,this.timelineIds=[];for(let t=0;t<e.length;t++)this.timelineIds[e[t].getPropertyId()]=!0;this.duration=n}hasTimeline(t){return 1==this.timelineIds[t]}apply(t,e,n,s,a,r,i,o){if(null==t)throw new Error("skeleton cannot be null.");s&&0!=this.duration&&(n%=this.duration,e>0&&(e%=this.duration));const l=this.timelines;for(let s=0,h=l.length;s<h;s++)l[s].apply(t,e,n,a,r,i,o)}static binarySearch(t,e,n=1){let s=0,a=t.length/n-2;if(0==a)return n;let r=a>>>1;for(;;){if(t[(r+1)*n]<=e?s=r+1:a=r,s==a)return(s+1)*n;r=s+a>>>1}}static linearSearch(t,e,n){for(let s=0,a=t.length-n;s<=a;s+=n)if(t[s]>e)return s;return-1}}var I=(t=>(t[t.rotate=0]="rotate",t[t.translate=1]="translate",t[t.scale=2]="scale",t[t.shear=3]="shear",t[t.attachment=4]="attachment",t[t.color=5]="color",t[t.deform=6]="deform",t[t.event=7]="event",t[t.drawOrder=8]="drawOrder",t[t.ikConstraint=9]="ikConstraint",t[t.transformConstraint=10]="transformConstraint",t[t.pathConstraintPosition=11]="pathConstraintPosition",t[t.pathConstraintSpacing=12]="pathConstraintSpacing",t[t.pathConstraintMix=13]="pathConstraintMix",t[t.twoColor=14]="twoColor",t))(I||{});const C=class{constructor(t){if(t<=0)throw new Error(`frameCount must be > 0: ${t}`);this.curves=r.Aq.newFloatArray((t-1)*C.BEZIER_SIZE)}getFrameCount(){return this.curves.length/C.BEZIER_SIZE+1}setLinear(t){this.curves[t*C.BEZIER_SIZE]=C.LINEAR}setStepped(t){this.curves[t*C.BEZIER_SIZE]=C.STEPPED}getCurveType(t){const e=t*C.BEZIER_SIZE;if(e==this.curves.length)return C.LINEAR;const n=this.curves[e];return n==C.LINEAR?C.LINEAR:n==C.STEPPED?C.STEPPED:C.BEZIER}setCurve(t,e,n,s,a){const r=.03*(2*-e+s),i=.03*(2*-n+a),o=.006*(3*(e-s)+1),l=.006*(3*(n-a)+1);let h=2*r+o,c=2*i+l,d=.3*e+r+.16666667*o,u=.3*n+i+.16666667*l,m=t*C.BEZIER_SIZE;const f=this.curves;f[m++]=C.BEZIER;let p=d,g=u;for(let t=m+C.BEZIER_SIZE-1;m<t;m+=2)f[m]=p,f[m+1]=g,d+=h,u+=c,h+=o,c+=l,p+=d,g+=u}getCurvePercent(t,e){e=r.cj.clamp(e,0,1);const n=this.curves;let s=t*C.BEZIER_SIZE;const a=n[s];if(a==C.LINEAR)return e;if(a==C.STEPPED)return 0;s++;let i=0;for(let t=s,a=s+C.BEZIER_SIZE-1;s<a;s+=2)if(i=n[s],i>=e){let a,r;return s==t?(a=0,r=0):(a=n[s-2],r=n[s-1]),r+(n[s+1]-r)*(e-a)/(i-a)}const o=n[s-1];return o+(1-o)*(e-i)/(1-i)}};let V=C;V.LINEAR=0,V.STEPPED=1,V.BEZIER=2,V.BEZIER_SIZE=19;const k=class extends V{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t<<1)}getPropertyId(){return 0+this.boneIndex}setFrame(t,e,n){t<<=1,this.frames[t]=e,this.frames[t+k.ROTATION]=n}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.bones[this.boneIndex];if(!h.active)return;if(n<l[0]){switch(i){case r.qU.setup:return void(h.rotation=h.data.rotation);case r.qU.first:const t=h.data.rotation-h.rotation;h.rotation+=(t-360*(16384-(16384.499999999996-t/360|0)))*a}return}if(n>=l[l.length-k.ENTRIES]){let t=l[l.length+k.PREV_ROTATION];switch(i){case r.qU.setup:h.rotation=h.data.rotation+t*a;break;case r.qU.first:case r.qU.replace:t+=h.data.rotation-h.rotation,t-=360*(16384-(16384.499999999996-t/360|0));case r.qU.add:h.rotation+=t*a}return}const c=y.binarySearch(l,n,k.ENTRIES),d=l[c+k.PREV_ROTATION],u=l[c],m=this.getCurvePercent((c>>1)-1,1-(n-u)/(l[c+k.PREV_TIME]-u));let f=l[c+k.ROTATION]-d;switch(f=d+(f-360*(16384-(16384.499999999996-f/360|0)))*m,i){case r.qU.setup:h.rotation=h.data.rotation+(f-360*(16384-(16384.499999999996-f/360|0)))*a;break;case r.qU.first:case r.qU.replace:f+=h.data.rotation-h.rotation;case r.qU.add:h.rotation+=(f-360*(16384-(16384.499999999996-f/360|0)))*a}}};let P=k;P.ENTRIES=2,P.PREV_TIME=-2,P.PREV_ROTATION=-1,P.ROTATION=1;const N=class extends V{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t*N.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(t,e,n,s){t*=N.ENTRIES,this.frames[t]=e,this.frames[t+N.X]=n,this.frames[t+N.Y]=s}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.bones[this.boneIndex];if(!h.active)return;if(n<l[0]){switch(i){case r.qU.setup:return h.x=h.data.x,void(h.y=h.data.y);case r.qU.first:h.x+=(h.data.x-h.x)*a,h.y+=(h.data.y-h.y)*a}return}let c=0,d=0;if(n>=l[l.length-N.ENTRIES])c=l[l.length+N.PREV_X],d=l[l.length+N.PREV_Y];else{const t=y.binarySearch(l,n,N.ENTRIES);c=l[t+N.PREV_X],d=l[t+N.PREV_Y];const e=l[t],s=this.getCurvePercent(t/N.ENTRIES-1,1-(n-e)/(l[t+N.PREV_TIME]-e));c+=(l[t+N.X]-c)*s,d+=(l[t+N.Y]-d)*s}switch(i){case r.qU.setup:h.x=h.data.x+c*a,h.y=h.data.y+d*a;break;case r.qU.first:case r.qU.replace:h.x+=(h.data.x+c-h.x)*a,h.y+=(h.data.y+d-h.y)*a;break;case r.qU.add:h.x+=c*a,h.y+=d*a}}};let v=N;v.ENTRIES=3,v.PREV_TIME=-3,v.PREV_X=-2,v.PREV_Y=-1,v.X=1,v.Y=2;class q extends v{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.bones[this.boneIndex];if(!h.active)return;if(n<l[0]){switch(i){case r.qU.setup:return h.scaleX=h.data.scaleX,void(h.scaleY=h.data.scaleY);case r.qU.first:h.scaleX+=(h.data.scaleX-h.scaleX)*a,h.scaleY+=(h.data.scaleY-h.scaleY)*a}return}let c=0,d=0;if(n>=l[l.length-q.ENTRIES])c=l[l.length+q.PREV_X]*h.data.scaleX,d=l[l.length+q.PREV_Y]*h.data.scaleY;else{const t=y.binarySearch(l,n,q.ENTRIES);c=l[t+q.PREV_X],d=l[t+q.PREV_Y];const e=l[t],s=this.getCurvePercent(t/q.ENTRIES-1,1-(n-e)/(l[t+q.PREV_TIME]-e));c=(c+(l[t+q.X]-c)*s)*h.data.scaleX,d=(d+(l[t+q.Y]-d)*s)*h.data.scaleY}if(1==a)i==r.qU.add?(h.scaleX+=c-h.data.scaleX,h.scaleY+=d-h.data.scaleY):(h.scaleX=c,h.scaleY=d);else{let t=0,e=0;if(o==r.mj.mixOut)switch(i){case r.qU.setup:t=h.data.scaleX,e=h.data.scaleY,h.scaleX=t+(Math.abs(c)*r.cj.signum(t)-t)*a,h.scaleY=e+(Math.abs(d)*r.cj.signum(e)-e)*a;break;case r.qU.first:case r.qU.replace:t=h.scaleX,e=h.scaleY,h.scaleX=t+(Math.abs(c)*r.cj.signum(t)-t)*a,h.scaleY=e+(Math.abs(d)*r.cj.signum(e)-e)*a;break;case r.qU.add:t=h.scaleX,e=h.scaleY,h.scaleX=t+(Math.abs(c)*r.cj.signum(t)-h.data.scaleX)*a,h.scaleY=e+(Math.abs(d)*r.cj.signum(e)-h.data.scaleY)*a}else switch(i){case r.qU.setup:t=Math.abs(h.data.scaleX)*r.cj.signum(c),e=Math.abs(h.data.scaleY)*r.cj.signum(d),h.scaleX=t+(c-t)*a,h.scaleY=e+(d-e)*a;break;case r.qU.first:case r.qU.replace:t=Math.abs(h.scaleX)*r.cj.signum(c),e=Math.abs(h.scaleY)*r.cj.signum(d),h.scaleX=t+(c-t)*a,h.scaleY=e+(d-e)*a;break;case r.qU.add:t=r.cj.signum(c),e=r.cj.signum(d),h.scaleX=Math.abs(h.scaleX)*t+(c-Math.abs(h.data.scaleX)*t)*a,h.scaleY=Math.abs(h.scaleY)*e+(d-Math.abs(h.data.scaleY)*e)*a}}}}class F extends v{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.bones[this.boneIndex];if(!h.active)return;if(n<l[0]){switch(i){case r.qU.setup:return h.shearX=h.data.shearX,void(h.shearY=h.data.shearY);case r.qU.first:h.shearX+=(h.data.shearX-h.shearX)*a,h.shearY+=(h.data.shearY-h.shearY)*a}return}let c=0,d=0;if(n>=l[l.length-F.ENTRIES])c=l[l.length+F.PREV_X],d=l[l.length+F.PREV_Y];else{const t=y.binarySearch(l,n,F.ENTRIES);c=l[t+F.PREV_X],d=l[t+F.PREV_Y];const e=l[t],s=this.getCurvePercent(t/F.ENTRIES-1,1-(n-e)/(l[t+F.PREV_TIME]-e));c+=(l[t+F.X]-c)*s,d+=(l[t+F.Y]-d)*s}switch(i){case r.qU.setup:h.shearX=h.data.shearX+c*a,h.shearY=h.data.shearY+d*a;break;case r.qU.first:case r.qU.replace:h.shearX+=(h.data.shearX+c-h.shearX)*a,h.shearY+=(h.data.shearY+d-h.shearY)*a;break;case r.qU.add:h.shearX+=c*a,h.shearY+=d*a}}}const _=class extends V{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t*_.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(t,e,n,s,a,r){t*=_.ENTRIES,this.frames[t]=e,this.frames[t+_.R]=n,this.frames[t+_.G]=s,this.frames[t+_.B]=a,this.frames[t+_.A]=r}apply(t,e,n,s,a,i,o){const l=t.slots[this.slotIndex];if(!l.bone.active)return;const h=this.frames;if(n<h[0]){switch(i){case r.qU.setup:return void l.color.setFromColor(l.data.color);case r.qU.first:const t=l.color,e=l.data.color;t.add((e.r-t.r)*a,(e.g-t.g)*a,(e.b-t.b)*a,(e.a-t.a)*a)}return}let c=0,d=0,u=0,m=0;if(n>=h[h.length-_.ENTRIES]){const t=h.length;c=h[t+_.PREV_R],d=h[t+_.PREV_G],u=h[t+_.PREV_B],m=h[t+_.PREV_A]}else{const t=y.binarySearch(h,n,_.ENTRIES);c=h[t+_.PREV_R],d=h[t+_.PREV_G],u=h[t+_.PREV_B],m=h[t+_.PREV_A];const e=h[t],s=this.getCurvePercent(t/_.ENTRIES-1,1-(n-e)/(h[t+_.PREV_TIME]-e));c+=(h[t+_.R]-c)*s,d+=(h[t+_.G]-d)*s,u+=(h[t+_.B]-u)*s,m+=(h[t+_.A]-m)*s}if(1==a)l.color.set(c,d,u,m);else{const t=l.color;i==r.qU.setup&&t.setFromColor(l.data.color),t.add((c-t.r)*a,(d-t.g)*a,(u-t.b)*a,(m-t.a)*a)}}};let D=_;D.ENTRIES=5,D.PREV_TIME=-5,D.PREV_R=-4,D.PREV_G=-3,D.PREV_B=-2,D.PREV_A=-1,D.R=1,D.G=2,D.B=3,D.A=4;const X=class extends V{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t*X.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(t,e,n,s,a,r,i,o,l){t*=X.ENTRIES,this.frames[t]=e,this.frames[t+X.R]=n,this.frames[t+X.G]=s,this.frames[t+X.B]=a,this.frames[t+X.A]=r,this.frames[t+X.R2]=i,this.frames[t+X.G2]=o,this.frames[t+X.B2]=l}apply(t,e,n,s,a,i,o){const l=t.slots[this.slotIndex];if(!l.bone.active)return;const h=this.frames;if(n<h[0]){switch(i){case r.qU.setup:return l.color.setFromColor(l.data.color),void l.darkColor.setFromColor(l.data.darkColor);case r.qU.first:const t=l.color,e=l.darkColor,n=l.data.color,s=l.data.darkColor;t.add((n.r-t.r)*a,(n.g-t.g)*a,(n.b-t.b)*a,(n.a-t.a)*a),e.add((s.r-e.r)*a,(s.g-e.g)*a,(s.b-e.b)*a,0)}return}let c=0,d=0,u=0,m=0,f=0,p=0,g=0;if(n>=h[h.length-X.ENTRIES]){const t=h.length;c=h[t+X.PREV_R],d=h[t+X.PREV_G],u=h[t+X.PREV_B],m=h[t+X.PREV_A],f=h[t+X.PREV_R2],p=h[t+X.PREV_G2],g=h[t+X.PREV_B2]}else{const t=y.binarySearch(h,n,X.ENTRIES);c=h[t+X.PREV_R],d=h[t+X.PREV_G],u=h[t+X.PREV_B],m=h[t+X.PREV_A],f=h[t+X.PREV_R2],p=h[t+X.PREV_G2],g=h[t+X.PREV_B2];const e=h[t],s=this.getCurvePercent(t/X.ENTRIES-1,1-(n-e)/(h[t+X.PREV_TIME]-e));c+=(h[t+X.R]-c)*s,d+=(h[t+X.G]-d)*s,u+=(h[t+X.B]-u)*s,m+=(h[t+X.A]-m)*s,f+=(h[t+X.R2]-f)*s,p+=(h[t+X.G2]-p)*s,g+=(h[t+X.B2]-g)*s}if(1==a)l.color.set(c,d,u,m),l.darkColor.set(f,p,g,1);else{const t=l.color,e=l.darkColor;i==r.qU.setup&&(t.setFromColor(l.data.color),e.setFromColor(l.data.darkColor)),t.add((c-t.r)*a,(d-t.g)*a,(u-t.b)*a,(m-t.a)*a),e.add((f-e.r)*a,(p-e.g)*a,(g-e.b)*a,0)}}};let Y=X;Y.ENTRIES=8,Y.PREV_TIME=-8,Y.PREV_R=-7,Y.PREV_G=-6,Y.PREV_B=-5,Y.PREV_A=-4,Y.PREV_R2=-3,Y.PREV_G2=-2,Y.PREV_B2=-1,Y.R=1,Y.G=2,Y.B=3,Y.A=4,Y.R2=5,Y.G2=6,Y.B2=7;class O{constructor(t){this.frames=r.Aq.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,e,n){this.frames[t]=e,this.attachmentNames[t]=n}apply(t,e,n,s,a,i,o){const l=t.slots[this.slotIndex];if(!l.bone.active)return;if(o==r.mj.mixOut)return void(i==r.qU.setup&&this.setAttachment(t,l,l.data.attachmentName));const h=this.frames;if(n<h[0])return void(i!=r.qU.setup&&i!=r.qU.first||this.setAttachment(t,l,l.data.attachmentName));let c=0;c=n>=h[h.length-1]?h.length-1:y.binarySearch(h,n,1)-1;const d=this.attachmentNames[c];t.slots[this.slotIndex].setAttachment(null==d?null:t.getAttachment(this.slotIndex,d))}setAttachment(t,e,n){e.setAttachment(null==n?null:t.getAttachment(this.slotIndex,n))}}let B=null;class L extends V{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t),this.frameVertices=new Array(t),null==B&&(B=r.Aq.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,e,n){this.frames[t]=e,this.frameVertices[t]=n}apply(t,e,n,s,a,i,o){const l=t.slots[this.slotIndex];if(!l.bone.active)return;const h=l.getAttachment();if(!(h instanceof f)||h.deformAttachment!=this.attachment)return;const c=l.deform;0==c.length&&(i=r.qU.setup);const d=this.frameVertices,u=d[0].length,m=this.frames;if(n<m[0]){const t=h;switch(i){case r.qU.setup:return void(c.length=0);case r.qU.first:if(1==a){c.length=0;break}const e=r.Aq.setArraySize(c,u);if(null==t.bones){const n=t.vertices;for(let t=0;t<u;t++)e[t]+=(n[t]-e[t])*a}else{a=1-a;for(let t=0;t<u;t++)e[t]*=a}}return}const p=r.Aq.setArraySize(c,u);if(n>=m[m.length-1]){const t=d[m.length-1];if(1==a)if(i==r.qU.add){const e=h;if(null==e.bones){const n=e.vertices;for(let e=0;e<u;e++)p[e]+=t[e]-n[e]}else for(let e=0;e<u;e++)p[e]+=t[e]}else r.Aq.arrayCopy(t,0,p,0,u);else switch(i){case r.qU.setup:{const e=h;if(null==e.bones){const n=e.vertices;for(let e=0;e<u;e++){const s=n[e];p[e]=s+(t[e]-s)*a}}else for(let e=0;e<u;e++)p[e]=t[e]*a;break}case r.qU.first:case r.qU.replace:for(let e=0;e<u;e++)p[e]+=(t[e]-p[e])*a;break;case r.qU.add:const e=h;if(null==e.bones){const n=e.vertices;for(let e=0;e<u;e++)p[e]+=(t[e]-n[e])*a}else for(let e=0;e<u;e++)p[e]+=t[e]*a}return}const g=y.binarySearch(m,n),E=d[g-1],x=d[g],w=m[g],A=this.getCurvePercent(g-1,1-(n-w)/(m[g-1]-w));if(1==a)if(i==r.qU.add){const t=h;if(null==t.bones){const e=t.vertices;for(let t=0;t<u;t++){const n=E[t];p[t]+=n+(x[t]-n)*A-e[t]}}else for(let t=0;t<u;t++){const e=E[t];p[t]+=e+(x[t]-e)*A}}else for(let t=0;t<u;t++){const e=E[t];p[t]=e+(x[t]-e)*A}else switch(i){case r.qU.setup:{const t=h;if(null==t.bones){const e=t.vertices;for(let t=0;t<u;t++){const n=E[t],s=e[t];p[t]=s+(n+(x[t]-n)*A-s)*a}}else for(let t=0;t<u;t++){const e=E[t];p[t]=(e+(x[t]-e)*A)*a}break}case r.qU.first:case r.qU.replace:for(let t=0;t<u;t++){const e=E[t];p[t]+=(e+(x[t]-e)*A-p[t])*a}break;case r.qU.add:const t=h;if(null==t.bones){const e=t.vertices;for(let t=0;t<u;t++){const n=E[t];p[t]+=(n+(x[t]-n)*A-e[t])*a}}else for(let t=0;t<u;t++){const e=E[t];p[t]+=(e+(x[t]-e)*A)*a}}}}class U{constructor(t){this.frames=r.Aq.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,n,s,a,r,i){if(null==s)return;const o=this.frames,l=this.frames.length;if(e>n)this.apply(t,e,Number.MAX_VALUE,s,a,r,i),e=-1;else if(e>=o[l-1])return;if(n<o[0])return;let h=0;if(e<o[0])h=0;else{h=y.binarySearch(o,e);const t=o[h];for(;h>0&&o[h-1]==t;)h--}for(;h<l&&n>=o[h];h++)s.push(this.events[h])}}class j{constructor(t){this.frames=r.Aq.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,e,n){this.frames[t]=e,this.drawOrders[t]=n}apply(t,e,n,s,a,i,o){const l=t.drawOrder,h=t.slots;if(o==r.mj.mixOut&&i==r.qU.setup)return void r.Aq.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);const c=this.frames;if(n<c[0])return void(i!=r.qU.setup&&i!=r.qU.first||r.Aq.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length));let d=0;d=n>=c[c.length-1]?c.length-1:y.binarySearch(c,n)-1;const u=this.drawOrders[d];if(null==u)r.Aq.arrayCopy(h,0,l,0,h.length);else for(let t=0,e=u.length;t<e;t++)l[t]=h[u[t]]}}const W=class extends V{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t*W.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(t,e,n,s,a,r,i){t*=W.ENTRIES,this.frames[t]=e,this.frames[t+W.MIX]=n,this.frames[t+W.SOFTNESS]=s,this.frames[t+W.BEND_DIRECTION]=a,this.frames[t+W.COMPRESS]=r?1:0,this.frames[t+W.STRETCH]=i?1:0}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.ikConstraints[this.ikConstraintIndex];if(!h.active)return;if(n<l[0]){switch(i){case r.qU.setup:return h.mix=h.data.mix,h.softness=h.data.softness,h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,void(h.stretch=h.data.stretch);case r.qU.first:h.mix+=(h.data.mix-h.mix)*a,h.softness+=(h.data.softness-h.softness)*a,h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,h.stretch=h.data.stretch}return}if(n>=l[l.length-W.ENTRIES])return void(i==r.qU.setup?(h.mix=h.data.mix+(l[l.length+W.PREV_MIX]-h.data.mix)*a,h.softness=h.data.softness+(l[l.length+W.PREV_SOFTNESS]-h.data.softness)*a,o==r.mj.mixOut?(h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,h.stretch=h.data.stretch):(h.bendDirection=l[l.length+W.PREV_BEND_DIRECTION],h.compress=0!=l[l.length+W.PREV_COMPRESS],h.stretch=0!=l[l.length+W.PREV_STRETCH])):(h.mix+=(l[l.length+W.PREV_MIX]-h.mix)*a,h.softness+=(l[l.length+W.PREV_SOFTNESS]-h.softness)*a,o==r.mj.mixIn&&(h.bendDirection=l[l.length+W.PREV_BEND_DIRECTION],h.compress=0!=l[l.length+W.PREV_COMPRESS],h.stretch=0!=l[l.length+W.PREV_STRETCH])));const c=y.binarySearch(l,n,W.ENTRIES),d=l[c+W.PREV_MIX],u=l[c+W.PREV_SOFTNESS],m=l[c],f=this.getCurvePercent(c/W.ENTRIES-1,1-(n-m)/(l[c+W.PREV_TIME]-m));i==r.qU.setup?(h.mix=h.data.mix+(d+(l[c+W.MIX]-d)*f-h.data.mix)*a,h.softness=h.data.softness+(u+(l[c+W.SOFTNESS]-u)*f-h.data.softness)*a,o==r.mj.mixOut?(h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,h.stretch=h.data.stretch):(h.bendDirection=l[c+W.PREV_BEND_DIRECTION],h.compress=0!=l[c+W.PREV_COMPRESS],h.stretch=0!=l[c+W.PREV_STRETCH])):(h.mix+=(d+(l[c+W.MIX]-d)*f-h.mix)*a,h.softness+=(u+(l[c+W.SOFTNESS]-u)*f-h.softness)*a,o==r.mj.mixIn&&(h.bendDirection=l[c+W.PREV_BEND_DIRECTION],h.compress=0!=l[c+W.PREV_COMPRESS],h.stretch=0!=l[c+W.PREV_STRETCH]))}};let $=W;$.ENTRIES=6,$.PREV_TIME=-6,$.PREV_MIX=-5,$.PREV_SOFTNESS=-4,$.PREV_BEND_DIRECTION=-3,$.PREV_COMPRESS=-2,$.PREV_STRETCH=-1,$.MIX=1,$.SOFTNESS=2,$.BEND_DIRECTION=3,$.COMPRESS=4,$.STRETCH=5;const H=class extends V{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t*H.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(t,e,n,s,a,r){t*=H.ENTRIES,this.frames[t]=e,this.frames[t+H.ROTATE]=n,this.frames[t+H.TRANSLATE]=s,this.frames[t+H.SCALE]=a,this.frames[t+H.SHEAR]=r}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.transformConstraints[this.transformConstraintIndex];if(!h.active)return;if(n<l[0]){const t=h.data;switch(i){case r.qU.setup:return h.rotateMix=t.rotateMix,h.translateMix=t.translateMix,h.scaleMix=t.scaleMix,void(h.shearMix=t.shearMix);case r.qU.first:h.rotateMix+=(t.rotateMix-h.rotateMix)*a,h.translateMix+=(t.translateMix-h.translateMix)*a,h.scaleMix+=(t.scaleMix-h.scaleMix)*a,h.shearMix+=(t.shearMix-h.shearMix)*a}return}let c=0,d=0,u=0,m=0;if(n>=l[l.length-H.ENTRIES]){const t=l.length;c=l[t+H.PREV_ROTATE],d=l[t+H.PREV_TRANSLATE],u=l[t+H.PREV_SCALE],m=l[t+H.PREV_SHEAR]}else{const t=y.binarySearch(l,n,H.ENTRIES);c=l[t+H.PREV_ROTATE],d=l[t+H.PREV_TRANSLATE],u=l[t+H.PREV_SCALE],m=l[t+H.PREV_SHEAR];const e=l[t],s=this.getCurvePercent(t/H.ENTRIES-1,1-(n-e)/(l[t+H.PREV_TIME]-e));c+=(l[t+H.ROTATE]-c)*s,d+=(l[t+H.TRANSLATE]-d)*s,u+=(l[t+H.SCALE]-u)*s,m+=(l[t+H.SHEAR]-m)*s}if(i==r.qU.setup){const t=h.data;h.rotateMix=t.rotateMix+(c-t.rotateMix)*a,h.translateMix=t.translateMix+(d-t.translateMix)*a,h.scaleMix=t.scaleMix+(u-t.scaleMix)*a,h.shearMix=t.shearMix+(m-t.shearMix)*a}else h.rotateMix+=(c-h.rotateMix)*a,h.translateMix+=(d-h.translateMix)*a,h.scaleMix+=(u-h.scaleMix)*a,h.shearMix+=(m-h.shearMix)*a}};let Q=H;Q.ENTRIES=5,Q.PREV_TIME=-5,Q.PREV_ROTATE=-4,Q.PREV_TRANSLATE=-3,Q.PREV_SCALE=-2,Q.PREV_SHEAR=-1,Q.ROTATE=1,Q.TRANSLATE=2,Q.SCALE=3,Q.SHEAR=4;const G=class extends V{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t*G.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(t,e,n){t*=G.ENTRIES,this.frames[t]=e,this.frames[t+G.VALUE]=n}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.pathConstraints[this.pathConstraintIndex];if(!h.active)return;if(n<l[0]){switch(i){case r.qU.setup:return void(h.position=h.data.position);case r.qU.first:h.position+=(h.data.position-h.position)*a}return}let c=0;if(n>=l[l.length-G.ENTRIES])c=l[l.length+G.PREV_VALUE];else{const t=y.binarySearch(l,n,G.ENTRIES);c=l[t+G.PREV_VALUE];const e=l[t],s=this.getCurvePercent(t/G.ENTRIES-1,1-(n-e)/(l[t+G.PREV_TIME]-e));c+=(l[t+G.VALUE]-c)*s}i==r.qU.setup?h.position=h.data.position+(c-h.data.position)*a:h.position+=(c-h.position)*a}};let Z=G;Z.ENTRIES=2,Z.PREV_TIME=-2,Z.PREV_VALUE=-1,Z.VALUE=1;class z extends Z{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.pathConstraints[this.pathConstraintIndex];if(!h.active)return;if(n<l[0]){switch(i){case r.qU.setup:return void(h.spacing=h.data.spacing);case r.qU.first:h.spacing+=(h.data.spacing-h.spacing)*a}return}let c=0;if(n>=l[l.length-z.ENTRIES])c=l[l.length+z.PREV_VALUE];else{const t=y.binarySearch(l,n,z.ENTRIES);c=l[t+z.PREV_VALUE];const e=l[t],s=this.getCurvePercent(t/z.ENTRIES-1,1-(n-e)/(l[t+z.PREV_TIME]-e));c+=(l[t+z.VALUE]-c)*s}i==r.qU.setup?h.spacing=h.data.spacing+(c-h.data.spacing)*a:h.spacing+=(c-h.spacing)*a}}const J=class extends V{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t*J.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(t,e,n,s){t*=J.ENTRIES,this.frames[t]=e,this.frames[t+J.ROTATE]=n,this.frames[t+J.TRANSLATE]=s}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.pathConstraints[this.pathConstraintIndex];if(!h.active)return;if(n<l[0]){switch(i){case r.qU.setup:return h.rotateMix=h.data.rotateMix,void(h.translateMix=h.data.translateMix);case r.qU.first:h.rotateMix+=(h.data.rotateMix-h.rotateMix)*a,h.translateMix+=(h.data.translateMix-h.translateMix)*a}return}let c=0,d=0;if(n>=l[l.length-J.ENTRIES])c=l[l.length+J.PREV_ROTATE],d=l[l.length+J.PREV_TRANSLATE];else{const t=y.binarySearch(l,n,J.ENTRIES);c=l[t+J.PREV_ROTATE],d=l[t+J.PREV_TRANSLATE];const e=l[t],s=this.getCurvePercent(t/J.ENTRIES-1,1-(n-e)/(l[t+J.PREV_TIME]-e));c+=(l[t+J.ROTATE]-c)*s,d+=(l[t+J.TRANSLATE]-d)*s}i==r.qU.setup?(h.rotateMix=h.data.rotateMix+(c-h.data.rotateMix)*a,h.translateMix=h.data.translateMix+(d-h.data.translateMix)*a):(h.rotateMix+=(c-h.rotateMix)*a,h.translateMix+=(d-h.translateMix)*a)}};let K=J;K.ENTRIES=3,K.PREV_TIME=-3,K.PREV_ROTATE=-2,K.PREV_TRANSLATE=-1,K.ROTATE=1,K.TRANSLATE=2;const tt=class{constructor(t){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new rt(this),this.propertyIDs=new r.ON,this.animationsChanged=!1,this.trackEntryPool=new r.bC((()=>new st)),this.data=t}update(t){t*=this.timeScale;const e=this.tracks;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(null==s)continue;s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast;let a=t*s.timeScale;if(s.delay>0){if(s.delay-=a,s.delay>0)continue;a=-s.delay,s.delay=0}let r=s.next;if(null!=r){const e=s.trackLast-r.delay;if(e>=0){for(r.delay=0,r.trackTime+=0==s.timeScale?0:(e/s.timeScale+t)*r.timeScale,s.trackTime+=a,this.setCurrent(n,r,!0);null!=r.mixingFrom;)r.mixTime+=t,r=r.mixingFrom;continue}}else if(s.trackLast>=s.trackEnd&&null==s.mixingFrom){e[n]=null,this.queue.end(s),this.disposeNext(s);continue}if(null!=s.mixingFrom&&this.updateMixingFrom(s,t)){let t=s.mixingFrom;for(s.mixingFrom=null,null!=t&&(t.mixingTo=null);null!=t;)this.queue.end(t),t=t.mixingFrom}s.trackTime+=a}this.queue.drain()}updateMixingFrom(t,e){const n=t.mixingFrom;if(null==n)return!0;const s=this.updateMixingFrom(n,e);return n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?(0!=n.totalAlpha&&0!=t.mixDuration||(t.mixingFrom=n.mixingFrom,null!=n.mixingFrom&&(n.mixingFrom.mixingTo=t),t.interruptAlpha=n.interruptAlpha,this.queue.end(n)),s):(n.trackTime+=e*n.timeScale,t.mixTime+=e,!1)}apply(t){if(null==t)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const e=this.events,n=this.tracks;let s=!1;for(let a=0,i=n.length;a<i;a++){const i=n[a];if(null==i||i.delay>0)continue;s=!0;const o=0==a?r.qU.first:i.mixBlend;let l=i.alpha;null!=i.mixingFrom?l*=this.applyMixingFrom(i,t,o):i.trackTime>=i.trackEnd&&null==i.next&&(l=0);const h=i.animationLast,c=i.getAnimationTime(),d=i.animation.timelines.length,u=i.animation.timelines;if(0==a&&1==l||o==r.qU.add)for(let n=0;n<d;n++){r.Aq.webkit602BugfixHelper(l,o);const s=u[n];s instanceof O?this.applyAttachmentTimeline(s,t,c,o,!0):s.apply(t,h,c,e,l,o,r.mj.mixIn)}else{const n=i.timelineMode,s=0==i.timelinesRotation.length;s&&r.Aq.setArraySize(i.timelinesRotation,d<<1,null);const a=i.timelinesRotation;for(let i=0;i<d;i++){const d=u[i],m=n[i]==tt.SUBSEQUENT?o:r.qU.setup;d instanceof P?this.applyRotateTimeline(d,t,c,l,m,a,i<<1,s):d instanceof O?this.applyAttachmentTimeline(d,t,c,o,!0):(r.Aq.webkit602BugfixHelper(l,o),d.apply(t,h,c,e,l,m,r.mj.mixIn))}}this.queueEvents(i,c),e.length=0,i.nextAnimationLast=c,i.nextTrackLast=i.trackTime}const a=this.unkeyedState+tt.SETUP,i=t.slots;for(let e=0,n=t.slots.length;e<n;e++){const n=i[e];if(n.attachmentState==a){const e=n.data.attachmentName;n.setAttachment(null==e?null:t.getAttachment(n.data.index,e))}}return this.unkeyedState+=2,this.queue.drain(),s}applyMixingFrom(t,e,n){const s=t.mixingFrom;null!=s.mixingFrom&&this.applyMixingFrom(s,e,n);let a=0;0==t.mixDuration?(a=1,n==r.qU.first&&(n=r.qU.setup)):(a=t.mixTime/t.mixDuration,a>1&&(a=1),n!=r.qU.first&&(n=s.mixBlend));const i=a<s.eventThreshold?this.events:null,o=a<s.attachmentThreshold,l=a<s.drawOrderThreshold,h=s.animationLast,c=s.getAnimationTime(),d=s.animation.timelines.length,u=s.animation.timelines,m=s.alpha*t.interruptAlpha,f=m*(1-a);if(n==r.qU.add)for(let t=0;t<d;t++)u[t].apply(e,h,c,i,f,n,r.mj.mixOut);else{const t=s.timelineMode,a=s.timelineHoldMix,p=0==s.timelinesRotation.length;p&&r.Aq.setArraySize(s.timelinesRotation,d<<1,null);const g=s.timelinesRotation;s.totalAlpha=0;for(let E=0;E<d;E++){const d=u[E];let x,w=r.mj.mixOut,A=0;switch(t[E]){case tt.SUBSEQUENT:if(!l&&d instanceof j)continue;x=n,A=f;break;case tt.FIRST:x=r.qU.setup,A=f;break;case tt.HOLD_SUBSEQUENT:x=n,A=m;break;case tt.HOLD_FIRST:x=r.qU.setup,A=m;break;default:x=r.qU.setup;const t=a[E];A=m*Math.max(0,1-t.mixTime/t.mixDuration)}s.totalAlpha+=A,d instanceof P?this.applyRotateTimeline(d,e,c,A,x,g,E<<1,p):d instanceof O?this.applyAttachmentTimeline(d,e,c,x,o):(r.Aq.webkit602BugfixHelper(A,n),l&&d instanceof j&&x==r.qU.setup&&(w=r.mj.mixIn),d.apply(e,h,c,i,A,x,w))}}return t.mixDuration>0&&this.queueEvents(s,c),this.events.length=0,s.nextAnimationLast=c,s.nextTrackLast=s.trackTime,a}applyAttachmentTimeline(t,e,n,s,a){const i=e.slots[t.slotIndex];if(!i.bone.active)return;const o=t.frames;if(n<o[0])s!=r.qU.setup&&s!=r.qU.first||this.setAttachment(e,i,i.data.attachmentName,a);else{let s;s=n>=o[o.length-1]?o.length-1:y.binarySearch(o,n)-1,this.setAttachment(e,i,t.attachmentNames[s],a)}i.attachmentState<=this.unkeyedState&&(i.attachmentState=this.unkeyedState+tt.SETUP)}setAttachment(t,e,n,s){e.setAttachment(null==n?null:t.getAttachment(e.data.index,n)),s&&(e.attachmentState=this.unkeyedState+tt.CURRENT)}applyRotateTimeline(t,e,n,s,a,i,o,l){if(l&&(i[o]=0),1==s)return void t.apply(e,0,n,null,1,a,r.mj.mixIn);const h=t,c=h.frames,d=e.bones[h.boneIndex];if(!d.active)return;let u=0,m=0;if(n<c[0])switch(a){case r.qU.setup:d.rotation=d.data.rotation;default:return;case r.qU.first:u=d.rotation,m=d.data.rotation}else if(u=a==r.qU.setup?d.data.rotation:d.rotation,n>=c[c.length-P.ENTRIES])m=d.data.rotation+c[c.length+P.PREV_ROTATION];else{const t=y.binarySearch(c,n,P.ENTRIES),e=c[t+P.PREV_ROTATION],s=c[t],a=h.getCurvePercent((t>>1)-1,1-(n-s)/(c[t+P.PREV_TIME]-s));m=c[t+P.ROTATION]-e,m-=360*(16384-(16384.499999999996-m/360|0)),m=e+m*a+d.data.rotation,m-=360*(16384-(16384.499999999996-m/360|0))}let f=0,p=m-u;if(p-=360*(16384-(16384.499999999996-p/360|0)),0==p)f=i[o];else{let t=0,e=0;l?(t=0,e=p):(t=i[o],e=i[o+1]);const n=p>0;let s=t>=0;r.cj.signum(e)!=r.cj.signum(p)&&Math.abs(e)<=90&&(Math.abs(t)>180&&(t+=360*r.cj.signum(t)),s=n),f=p+t-t%360,s!=n&&(f+=360*r.cj.signum(t)),i[o]=f}i[o+1]=p,u+=f*s,d.rotation=u-360*(16384-(16384.499999999996-u/360|0))}queueEvents(t,e){const n=t.animationStart,s=t.animationEnd,a=s-n,r=t.trackLast%a,i=this.events;let o=0;const l=i.length;for(;o<l;o++){const e=i[o];if(e.time<r)break;e.time>s||this.queue.event(t,e)}let h=!1;for(h=t.loop?0==a||r>t.trackTime%a:e>=s&&t.animationLast<s,h&&this.queue.complete(t);o<l;o++)i[o].time<n||this.queue.event(t,i[o])}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,e=this.tracks.length;t<e;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const e=this.tracks[t];if(null==e)return;this.queue.end(e),this.disposeNext(e);let n=e;for(;;){const t=n.mixingFrom;if(null==t)break;this.queue.end(t),n.mixingFrom=null,n.mixingTo=null,n=t}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,n){const s=this.expandToIndex(t);this.tracks[t]=e,null!=s&&(n&&this.queue.interrupt(s),e.mixingFrom=s,s.mixingTo=e,e.mixTime=0,null!=s.mixingFrom&&s.mixDuration>0&&(e.interruptAlpha*=Math.min(1,s.mixTime/s.mixDuration)),s.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,n){const s=this.data.skeletonData.findAnimation(e);if(null==s)throw new Error(`Animation not found: ${e}`);return this.setAnimationWith(t,s,n)}setAnimationWith(t,e,n){if(null==e)throw new Error("animation cannot be null.");let s=!0,a=this.expandToIndex(t);null!=a&&(-1==a.nextTrackLast?(this.tracks[t]=a.mixingFrom,this.queue.interrupt(a),this.queue.end(a),this.disposeNext(a),a=a.mixingFrom,s=!1):this.disposeNext(a));const r=this.trackEntry(t,e,n,a);return this.setCurrent(t,r,s),this.queue.drain(),r}addAnimation(t,e,n,s){const a=this.data.skeletonData.findAnimation(e);if(null==a)throw new Error(`Animation not found: ${e}`);return this.addAnimationWith(t,a,n,s)}addAnimationWith(t,e,n,s){if(null==e)throw new Error("animation cannot be null.");let a=this.expandToIndex(t);if(null!=a)for(;null!=a.next;)a=a.next;const r=this.trackEntry(t,e,n,a);if(null==a)this.setCurrent(t,r,!0),this.queue.drain();else if(a.next=r,s<=0){const t=a.animationEnd-a.animationStart;0!=t?(a.loop?s+=t*(1+(a.trackTime/t|0)):s+=Math.max(t,a.trackTime),s-=this.data.getMix(a.animation,e)):s=a.trackTime}return r.delay=s,r}setEmptyAnimation(t,e){const n=this.setAnimationWith(t,tt.emptyAnimation,!1);return n.mixDuration=e,n.trackEnd=e,n}addEmptyAnimation(t,e,n){n<=0&&(n-=e);const s=this.addAnimationWith(t,tt.emptyAnimation,!1,n);return s.mixDuration=e,s.trackEnd=e,s}setEmptyAnimations(t){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,n=this.tracks.length;e<n;e++){const n=this.tracks[e];null!=n&&this.setEmptyAnimation(n.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(r.Aq.ensureArrayCapacity(this.tracks,t+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,n,s){const a=this.trackEntryPool.obtain();return a.trackIndex=t,a.animation=e,a.loop=n,a.holdPrevious=!1,a.eventThreshold=0,a.attachmentThreshold=0,a.drawOrderThreshold=0,a.animationStart=0,a.animationEnd=e.duration,a.animationLast=-1,a.nextAnimationLast=-1,a.delay=0,a.trackTime=0,a.trackLast=-1,a.nextTrackLast=-1,a.trackEnd=Number.MAX_VALUE,a.timeScale=1,a.alpha=1,a.interruptAlpha=1,a.mixTime=0,a.mixDuration=null==s?0:this.data.getMix(s.animation,e),a.mixBlend=r.qU.replace,a}disposeNext(t){let e=t.next;for(;null!=e;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let t=0,e=this.tracks.length;t<e;t++){let e=this.tracks[t];if(null!=e){for(;null!=e.mixingFrom;)e=e.mixingFrom;do{null!=e.mixingFrom&&e.mixBlend==r.qU.add||this.computeHold(e),e=e.mixingTo}while(null!=e)}}}computeHold(t){const e=t.mixingTo,n=t.animation.timelines,s=t.animation.timelines.length,a=r.Aq.setArraySize(t.timelineMode,s);t.timelineHoldMix.length=0;const i=r.Aq.setArraySize(t.timelineHoldMix,s),o=this.propertyIDs;if(null!=e&&e.holdPrevious)for(let t=0;t<s;t++)a[t]=o.add(n[t].getPropertyId())?tt.HOLD_FIRST:tt.HOLD_SUBSEQUENT;else t:for(let r=0;r<s;r++){const s=n[r],l=s.getPropertyId();if(o.add(l))if(null==e||s instanceof O||s instanceof j||s instanceof U||!e.animation.hasTimeline(l))a[r]=tt.FIRST;else{for(let n=e.mixingTo;null!=n;n=n.mixingTo)if(!n.animation.hasTimeline(l)){if(t.mixDuration>0){a[r]=tt.HOLD_MIX,i[r]=n;continue t}break}a[r]=tt.HOLD_FIRST}else a[r]=tt.SUBSEQUENT}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(null==t)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,e,n){tt.deprecatedWarning1||(tt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,e,n)}addAnimationByName(t,e,n,s){tt.deprecatedWarning2||(tt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,e,n,s)}hasAnimation(t){return null!==this.data.skeletonData.findAnimation(t)}hasAnimationByName(t){return tt.deprecatedWarning3||(tt.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};let et=tt;et.emptyAnimation=new y("<empty>",[],0),et.SUBSEQUENT=0,et.FIRST=1,et.HOLD_SUBSEQUENT=2,et.HOLD_FIRST=3,et.HOLD_MIX=4,et.SETUP=1,et.CURRENT=2,et.deprecatedWarning1=!1,et.deprecatedWarning2=!1,et.deprecatedWarning3=!1;const nt=class{constructor(){this.mixBlend=r.qU.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return 0==t?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return nt.deprecatedWarning1||(nt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){nt.deprecatedWarning1||(nt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return nt.deprecatedWarning2||(nt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){nt.deprecatedWarning2||(nt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let st=nt;st.deprecatedWarning1=!1,st.deprecatedWarning2=!1;const at=class{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=t}start(t){this.objects.push(it.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(it.interrupt),this.objects.push(t)}end(t){this.objects.push(it.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(it.dispose),this.objects.push(t)}complete(t){this.objects.push(it.complete),this.objects.push(t)}event(t,e){this.objects.push(it.event),this.objects.push(t),this.objects.push(e)}deprecateStuff(){return at.deprecatedWarning1||(at.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,e=this.animState.listeners;for(let n=0;n<t.length;n+=2){const s=t[n],a=t[n+1];switch(s){case it.start:null!=a.listener&&a.listener.start&&a.listener.start(a);for(let t=0;t<e.length;t++)e[t].start&&e[t].start(a);a.onStart&&this.deprecateStuff()&&a.onStart(a.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(a.trackIndex);break;case it.interrupt:null!=a.listener&&a.listener.interrupt&&a.listener.interrupt(a);for(let t=0;t<e.length;t++)e[t].interrupt&&e[t].interrupt(a);break;case it.end:null!=a.listener&&a.listener.end&&a.listener.end(a);for(let t=0;t<e.length;t++)e[t].end&&e[t].end(a);a.onEnd&&this.deprecateStuff()&&a.onEnd(a.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(a.trackIndex);case it.dispose:null!=a.listener&&a.listener.dispose&&a.listener.dispose(a);for(let t=0;t<e.length;t++)e[t].dispose&&e[t].dispose(a);this.animState.trackEntryPool.free(a);break;case it.complete:null!=a.listener&&a.listener.complete&&a.listener.complete(a);for(let t=0;t<e.length;t++)e[t].complete&&e[t].complete(a);const s=r.cj.toInt(a.loopsCount());a.onComplete&&this.deprecateStuff()&&a.onComplete(a.trackIndex,s),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(a.trackIndex,s);break;case it.event:const i=t[2+n++];null!=a.listener&&a.listener.event&&a.listener.event(a,i);for(let t=0;t<e.length;t++)e[t].event&&e[t].event(a,i);a.onEvent&&this.deprecateStuff()&&a.onEvent(a.trackIndex,i),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(a.trackIndex,i)}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let rt=at;rt.deprecatedWarning1=!1;var it=(t=>(t[t.start=0]="start",t[t.interrupt=1]="interrupt",t[t.end=2]="end",t[t.dispose=3]="dispose",t[t.complete=4]="complete",t[t.event=5]="event",t))(it||{});class ot{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}}const lt=class{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,null==t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,n){const s=this.skeletonData.findAnimation(t);if(null==s)throw new Error(`Animation not found: ${t}`);const a=this.skeletonData.findAnimation(e);if(null==a)throw new Error(`Animation not found: ${e}`);this.setMixWith(s,a,n)}setMixByName(t,e,n){lt.deprecatedWarning1||(lt.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(t,e,n)}setMixWith(t,e,n){if(null==t)throw new Error("from cannot be null.");if(null==e)throw new Error("to cannot be null.");const s=`${t.name}.${e.name}`;this.animationToMixTime[s]=n}getMix(t,e){const n=`${t.name}.${e.name}`,s=this.animationToMixTime[n];return void 0===s?this.defaultMix:s}};let ht=lt;ht.deprecatedWarning1=!1;class ct{constructor(t){this.atlas=t}newRegionAttachment(t,e,n){const s=this.atlas.findRegion(n);if(null==s)throw new Error(`Region not found in atlas: ${n} (region attachment: ${e})`);const a=new b(e);return a.region=s,a}newMeshAttachment(t,e,n){const s=this.atlas.findRegion(n);if(null==s)throw new Error(`Region not found in atlas: ${n} (mesh attachment: ${e})`);const a=new E(e);return a.region=s,a}newBoundingBoxAttachment(t,e){return new p(e)}newPathAttachment(t,e){return new x(e)}newPointAttachment(t,e){return new w(e)}newClippingAttachment(t,e){return new g(e)}}class dt{constructor(t,e,n){if(this.matrix=new o.uq,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!1,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=n,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,n,s,a,i,o){this.ax=t,this.ay=e,this.arotation=n,this.ascaleX=s,this.ascaleY=a,this.ashearX=i,this.ashearY=o,this.appliedValid=!0;const l=this.parent,h=this.matrix,c=this.skeleton.scaleX,d=r.W0.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(null==l){const l=this.skeleton,u=n+90+o;return h.a=r.cj.cosDeg(n+i)*s*c,h.c=r.cj.cosDeg(u)*a*c,h.b=r.cj.sinDeg(n+i)*s*d,h.d=r.cj.sinDeg(u)*a*d,h.tx=t*c+l.x,void(h.ty=e*d+l.y)}let u=l.matrix.a,m=l.matrix.c,f=l.matrix.b,p=l.matrix.d;switch(h.tx=u*t+m*e+l.matrix.tx,h.ty=f*t+p*e+l.matrix.ty,this.data.transformMode){case r._C.Normal:{const t=n+90+o,e=r.cj.cosDeg(n+i)*s,l=r.cj.cosDeg(t)*a,c=r.cj.sinDeg(n+i)*s,d=r.cj.sinDeg(t)*a;return h.a=u*e+m*c,h.c=u*l+m*d,h.b=f*e+p*c,void(h.d=f*l+p*d)}case r._C.OnlyTranslation:{const t=n+90+o;h.a=r.cj.cosDeg(n+i)*s,h.c=r.cj.cosDeg(t)*a,h.b=r.cj.sinDeg(n+i)*s,h.d=r.cj.sinDeg(t)*a;break}case r._C.NoRotationOrReflection:{let t=u*u+f*f,e=0;t>1e-4?(t=Math.abs(u*p-m*f)/t,u/=this.skeleton.scaleX,f/=this.skeleton.scaleY,m=f*t,p=u*t,e=Math.atan2(f,u)*r.cj.radDeg):(u=0,f=0,e=90-Math.atan2(p,m)*r.cj.radDeg);const l=n+i-e,c=n+o-e+90,d=r.cj.cosDeg(l)*s,g=r.cj.cosDeg(c)*a,E=r.cj.sinDeg(l)*s,x=r.cj.sinDeg(c)*a;h.a=u*d-m*E,h.c=u*g-m*x,h.b=f*d+p*E,h.d=f*g+p*x;break}case r._C.NoScale:case r._C.NoScaleOrReflection:{const t=r.cj.cosDeg(n),e=r.cj.sinDeg(n);let l=(u*t+m*e)/c,g=(f*t+p*e)/d,E=Math.sqrt(l*l+g*g);E>1e-5&&(E=1/E),l*=E,g*=E,E=Math.sqrt(l*l+g*g),this.data.transformMode==r._C.NoScale&&u*p-m*f<0!=(r.W0.yDown?this.skeleton.scaleX<0!=this.skeleton.scaleY>0:this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(E=-E);const x=Math.PI/2+Math.atan2(g,l),w=Math.cos(x)*E,A=Math.sin(x)*E,S=r.cj.cosDeg(i)*s,b=r.cj.cosDeg(90+o)*a,M=r.cj.sinDeg(i)*s,T=r.cj.sinDeg(90+o)*a;h.a=l*S+w*M,h.c=l*b+w*T,h.b=g*S+A*M,h.d=g*b+A*T;break}}h.a*=c,h.c*=c,h.b*=d,h.d*=d}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*r.cj.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*r.cj.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,e=this.matrix;if(null==t)return this.ax=e.tx,this.ay=e.ty,this.arotation=Math.atan2(e.b,e.a)*r.cj.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,void(this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*r.cj.radDeg);const n=t.matrix,s=1/(n.a*n.d-n.b*n.c),a=e.tx-n.tx,i=e.ty-n.ty;this.ax=a*n.d*s-i*n.c*s,this.ay=i*n.a*s-a*n.b*s;const o=s*n.d,l=s*n.a,h=s*n.c,c=s*n.b,d=o*e.a-h*e.b,u=o*e.c-h*e.d,m=l*e.b-c*e.a,f=l*e.d-c*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(d*d+m*m),this.ascaleX>1e-4){const t=d*f-u*m;this.ascaleY=t/this.ascaleX,this.ashearY=Math.atan2(d*u+m*f,t)*r.cj.radDeg,this.arotation=Math.atan2(m,d)*r.cj.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(u*u+f*f),this.ashearY=0,this.arotation=90-Math.atan2(f,u)*r.cj.radDeg}worldToLocal(t){const e=this.matrix,n=e.a,s=e.c,a=e.b,r=e.d,i=1/(n*r-s*a),o=t.x-e.tx,l=t.y-e.ty;return t.x=o*r*i-l*s*i,t.y=l*n*i-o*a*i,t}localToWorld(t){const e=this.matrix,n=t.x,s=t.y;return t.x=n*e.a+s*e.c+e.tx,t.y=n*e.b+s*e.d+e.ty,t}worldToLocalRotation(t){const e=r.cj.sinDeg(t),n=r.cj.cosDeg(t),s=this.matrix;return Math.atan2(s.a*e-s.b*n,s.d*n-s.c*e)*r.cj.radDeg}localToWorldRotation(t){const e=r.cj.sinDeg(t),n=r.cj.cosDeg(t),s=this.matrix;return Math.atan2(n*s.b+e*s.d,n*s.a+e*s.c)*r.cj.radDeg}rotateWorld(t){const e=this.matrix,n=e.a,s=e.c,a=e.b,i=e.d,o=r.cj.cosDeg(t),l=r.cj.sinDeg(t);e.a=o*n-l*a,e.c=o*s-l*i,e.b=l*n+o*a,e.d=l*s+o*i,this.appliedValid=!1}}class ut{constructor(t,e,n){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=r._C.Normal,this.skinRequired=!1,this.color=new r.Q1,t<0)throw new Error("index must be >= 0.");if(null==e)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=n}}class mt{constructor(t,e,n){this.name=t,this.order=e,this.skinRequired=n}}class ft{constructor(t,e){if(null==e)throw new Error("data cannot be null.");this.time=t,this.data=e}}class pt{constructor(t){this.name=t}}class gt{constructor(t,e){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.softness,this.mix)}}apply1(t,e,n,s,a,i,o){t.appliedValid||t.updateAppliedTransform();const l=t.parent.matrix,h=l.a;let c=l.c;const d=l.b;let u=l.d,m=-t.ashearX-t.arotation,f=0,p=0;switch(t.data.transformMode){case r._C.OnlyTranslation:f=e-t.worldX,p=n-t.worldY;break;case r._C.NoRotationOrReflection:const s=Math.abs(h*u-c*d)/(h*h+d*d),a=h/t.skeleton.scaleX,i=d/t.skeleton.scaleY;c=-i*s*t.skeleton.scaleX,u=a*s*t.skeleton.scaleY,m+=Math.atan2(i,a)*r.cj.radDeg;default:const o=e-l.tx,g=n-l.ty,E=h*u-c*d;f=(o*u-g*c)/E-t.ax,p=(g*h-o*d)/E-t.ay}m+=Math.atan2(p,f)*r.cj.radDeg,t.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let g=t.ascaleX,E=t.ascaleY;if(s||a){switch(t.data.transformMode){case r._C.NoScale:case r._C.NoScaleOrReflection:f=e-t.worldX,p=n-t.worldY}const l=t.data.length*g,h=Math.sqrt(f*f+p*p);if(s&&h<l||a&&h>l&&l>1e-4){const t=(h/l-1)*o+1;g*=t,i&&(E*=t)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+m*o,g,E,t.ashearX,t.ashearY)}apply2(t,e,n,s,a,i,o,l){if(0==l)return void e.updateWorldTransform();t.appliedValid||t.updateAppliedTransform(),e.appliedValid||e.updateAppliedTransform();const h=t.ax,c=t.ay;let d=t.ascaleX,u=d,m=t.ascaleY,f=e.ascaleX;const p=t.matrix;let g=0,E=0,x=0;d<0?(d=-d,g=180,x=-1):(g=0,x=1),m<0&&(m=-m,x=-x),f<0?(f=-f,E=180):E=0;const w=e.ax;let A=0,S=0,b=0,M=p.a,T=p.c,R=p.b,y=p.d;const I=Math.abs(d-m)<=1e-4;I?(A=e.ay,S=M*w+T*A+p.tx,b=R*w+y*A+p.ty):(A=0,S=M*w+p.tx,b=R*w+p.ty);const C=t.parent.matrix;M=C.a,T=C.c,R=C.b,y=C.d;const V=1/(M*y-T*R);let k=S-C.tx,P=b-C.ty;const N=(k*y-P*T)*V-h,v=(P*M-k*R)*V-c,q=Math.sqrt(N*N+v*v);let F,_,D=e.data.length*f;if(q<1e-4)return this.apply1(t,n,s,!1,i,!1,l),void e.updateWorldTransformWith(w,A,0,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY);k=n-C.tx,P=s-C.ty;let X=(k*y-P*T)*V-h,Y=(P*M-k*R)*V-c,O=X*X+Y*Y;if(0!=o){o*=d*(f+1)/2;const t=Math.sqrt(O),e=t-q-D*d+o;if(e>0){let n=Math.min(1,e/(2*o))-1;n=(e-o*(1-n*n))/t,X-=n*X,Y-=n*Y,O=X*X+Y*Y}}t:if(I){D*=d;let t=(O-q*q-D*D)/(2*q*D);t<-1?t=-1:t>1&&(t=1,i&&(u*=(Math.sqrt(O)/(q+D)-1)*l+1)),_=Math.acos(t)*a,M=q+D*t,T=D*Math.sin(_),F=Math.atan2(Y*M-X*T,X*M+Y*T)}else{M=d*D,T=m*D;const t=M*M,e=T*T,n=Math.atan2(Y,X);R=e*q*q+t*O-t*e;const s=-2*e*q,i=e-t;if(y=s*s-4*i*R,y>=0){let t=Math.sqrt(y);s<0&&(t=-t),t=-(s+t)/2;const e=t/i,r=R/t,o=Math.abs(e)<Math.abs(r)?e:r;if(o*o<=O){P=Math.sqrt(O-o*o)*a,F=n-Math.atan2(P,o),_=Math.atan2(P/m,(o-q)/d);break t}}let o=r.cj.PI,l=q-M,h=l*l,c=0,u=0,f=q+M,p=f*f,g=0;R=-M*q/(t-e),R>=-1&&R<=1&&(R=Math.acos(R),k=M*Math.cos(R)+q,P=T*Math.sin(R),y=k*k+P*P,y<h&&(o=R,h=y,l=k,c=P),y>p&&(u=R,p=y,f=k,g=P)),O<=(h+p)/2?(F=n-Math.atan2(c*a,l),_=o*a):(F=n-Math.atan2(g*a,f),_=u*a)}const B=Math.atan2(A,w)*x;let L=t.arotation;F=(F-B)*r.cj.radDeg+g-L,F>180?F-=360:F<-180&&(F+=360),t.updateWorldTransformWith(h,c,L+F*l,u,t.ascaleY,0,0),L=e.arotation,_=((_+B)*r.cj.radDeg-e.ashearX)*x+E-L,_>180?_-=360:_<-180&&(_+=360),e.updateWorldTransformWith(w,A,L+_*l,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}}class Et extends mt{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}}class xt extends mt{constructor(t){super(t,0,!1),this.bones=new Array}}var wt=(t=>(t[t.Length=0]="Length",t[t.Fixed=1]="Fixed",t[t.Percent=2]="Percent",t))(wt||{});const At=class{constructor(t,e){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let n=0,s=t.bones.length;n<s;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findSlot(t.target.name),this.position=t.position,this.spacing=t.spacing,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix}isActive(){return this.active}apply(){this.update()}update(){const t=this.target.getAttachment();if(!(t instanceof x))return;const e=this.rotateMix,n=this.translateMix,s=e>0;if(!(n>0||s))return;const a=this.data,i=a.spacingMode,o=i==wt.Length,l=a.rotateMode,h=l==r.Dr.Tangent,c=l==r.Dr.ChainScale,d=this.bones.length,u=h?d:d+1,m=this.bones,f=r.Aq.setArraySize(this.spaces,u);let p=null;const g=this.spacing;if(c||o){c&&(p=r.Aq.setArraySize(this.lengths,d));for(let t=0,e=u-1;t<e;){const e=m[t],n=e.data.length;if(n<At.epsilon)c&&(p[t]=0),f[++t]=0;else{const s=n*e.matrix.a,a=n*e.matrix.b,r=Math.sqrt(s*s+a*a);c&&(p[t]=r),f[++t]=(o?n+g:g)*r/n}}}else for(let t=1;t<u;t++)f[t]=g;const E=this.computeWorldPositions(t,u,h,a.positionMode==r.pw.Percent,i==wt.Percent);let w=E[0],A=E[1],S=a.offsetRotation,b=!1;if(0==S)b=l==r.Dr.Chain;else{b=!1;const t=this.target.bone.matrix;S*=t.a*t.d-t.b*t.c>0?r.cj.degRad:-r.cj.degRad}for(let t=0,a=3;t<d;t++,a+=3){const i=m[t],o=i.matrix;o.tx+=(w-o.tx)*n,o.ty+=(A-o.ty)*n;const l=E[a],d=E[a+1],u=l-w,g=d-A;if(c){const n=p[t];if(0!=n){const t=(Math.sqrt(u*u+g*g)/n-1)*e+1;o.a*=t,o.b*=t}}if(w=l,A=d,s){const n=o.a,s=o.c,l=o.b,c=o.d;let d=0,m=0,p=0;if(h&&(d=h?E[a-1]:0==f[t+1]?E[a+2]:Math.atan2(g,u)),d-=Math.atan2(l,n),b){m=Math.cos(d),p=Math.sin(d);const t=i.data.length;w+=(t*(m*n-p*l)-u)*e,A+=(t*(p*n+m*l)-g)*e}else d+=S;d>r.cj.PI?d-=r.cj.PI2:d<-r.cj.PI&&(d+=r.cj.PI2),d*=e,m=Math.cos(d),p=Math.sin(d),o.a=m*n-p*l,o.c=m*s-p*c,o.b=p*n+m*l,o.d=p*s+m*c}i.appliedValid=!1}}computeWorldPositions(t,e,n,s,a){const i=this.target;let o=this.position;const l=this.spaces,h=r.Aq.setArraySize(this.positions,3*e+2);let c=null;const d=t.closed;let u=t.worldVerticesLength,m=u/6,f=At.NONE;if(!t.constantSpeed){const p=t.lengths;m-=d?1:2;const g=p[m];if(s&&(o*=g),a)for(let t=0;t<e;t++)l[t]*=g;c=r.Aq.setArraySize(this.world,8);for(let s=0,a=0,r=0;s<e;s++,a+=3){const e=l[s];o+=e;let E=o;if(d)E%=g,E<0&&(E+=g),r=0;else{if(E<0){f!=At.BEFORE&&(f=At.BEFORE,t.computeWorldVertices(i,2,4,c,0,2)),this.addBeforePosition(E,c,0,h,a);continue}if(E>g){f!=At.AFTER&&(f=At.AFTER,t.computeWorldVertices(i,u-6,4,c,0,2)),this.addAfterPosition(E-g,c,0,h,a);continue}}for(;;r++){const t=p[r];if(!(E>t)){if(0==r)E/=t;else{const e=p[r-1];E=(E-e)/(t-e)}break}}r!=f&&(f=r,d&&r==m?(t.computeWorldVertices(i,u-4,4,c,0,2),t.computeWorldVertices(i,0,4,c,4,2)):t.computeWorldVertices(i,6*r+2,8,c,0,2)),this.addCurvePosition(E,c[0],c[1],c[2],c[3],c[4],c[5],c[6],c[7],h,a,n||s>0&&0==e)}return h}d?(u+=2,c=r.Aq.setArraySize(this.world,u),t.computeWorldVertices(i,2,u-4,c,0,2),t.computeWorldVertices(i,0,2,c,u-4,2),c[u-2]=c[0],c[u-1]=c[1]):(m--,u-=4,c=r.Aq.setArraySize(this.world,u),t.computeWorldVertices(i,2,u,c,0,2));const p=r.Aq.setArraySize(this.curves,m);let g=0,E=c[0],x=c[1],w=0,A=0,S=0,b=0,M=0,T=0,R=0,y=0,I=0,C=0,V=0,k=0,P=0,N=0;for(let t=0,e=2;t<m;t++,e+=6)w=c[e],A=c[e+1],S=c[e+2],b=c[e+3],M=c[e+4],T=c[e+5],R=.1875*(E-2*w+S),y=.1875*(x-2*A+b),I=.09375*(3*(w-S)-E+M),C=.09375*(3*(A-b)-x+T),V=2*R+I,k=2*y+C,P=.75*(w-E)+R+.16666667*I,N=.75*(A-x)+y+.16666667*C,g+=Math.sqrt(P*P+N*N),P+=V,N+=k,V+=I,k+=C,g+=Math.sqrt(P*P+N*N),P+=V,N+=k,g+=Math.sqrt(P*P+N*N),P+=V+I,N+=k+C,g+=Math.sqrt(P*P+N*N),p[t]=g,E=M,x=T;if(s&&(o*=g),a)for(let t=0;t<e;t++)l[t]*=g;const v=this.segments;let q=0;for(let t=0,s=0,a=0,r=0;t<e;t++,s+=3){const e=l[t];o+=e;let i=o;if(d)i%=g,i<0&&(i+=g),a=0;else{if(i<0){this.addBeforePosition(i,c,0,h,s);continue}if(i>g){this.addAfterPosition(i-g,c,u-4,h,s);continue}}for(;;a++){const t=p[a];if(!(i>t)){if(0==a)i/=t;else{const e=p[a-1];i=(i-e)/(t-e)}break}}if(a!=f){f=a;let t=6*a;for(E=c[t],x=c[t+1],w=c[t+2],A=c[t+3],S=c[t+4],b=c[t+5],M=c[t+6],T=c[t+7],R=.03*(E-2*w+S),y=.03*(x-2*A+b),I=.006*(3*(w-S)-E+M),C=.006*(3*(A-b)-x+T),V=2*R+I,k=2*y+C,P=.3*(w-E)+R+.16666667*I,N=.3*(A-x)+y+.16666667*C,q=Math.sqrt(P*P+N*N),v[0]=q,t=1;t<8;t++)P+=V,N+=k,V+=I,k+=C,q+=Math.sqrt(P*P+N*N),v[t]=q;P+=V,N+=k,q+=Math.sqrt(P*P+N*N),v[8]=q,P+=V+I,N+=k+C,q+=Math.sqrt(P*P+N*N),v[9]=q,r=0}for(i*=q;;r++){const t=v[r];if(!(i>t)){if(0==r)i/=t;else{const e=v[r-1];i=r+(i-e)/(t-e)}break}}this.addCurvePosition(.1*i,E,x,w,A,S,b,M,T,h,s,n||t>0&&0==e)}return h}addBeforePosition(t,e,n,s,a){const r=e[n],i=e[n+1],o=e[n+2]-r,l=e[n+3]-i,h=Math.atan2(l,o);s[a]=r+t*Math.cos(h),s[a+1]=i+t*Math.sin(h),s[a+2]=h}addAfterPosition(t,e,n,s,a){const r=e[n+2],i=e[n+3],o=r-e[n],l=i-e[n+1],h=Math.atan2(l,o);s[a]=r+t*Math.cos(h),s[a+1]=i+t*Math.sin(h),s[a+2]=h}addCurvePosition(t,e,n,s,a,r,i,o,l,h,c,d){(0==t||isNaN(t))&&(t=1e-4);const u=t*t,m=u*t,f=1-t,p=f*f,g=p*f,E=f*t,x=3*E,w=f*x,A=x*t,S=e*g+s*w+r*A+o*m,b=n*g+a*w+i*A+l*m;h[c]=S,h[c+1]=b,d&&(h[c+2]=Math.atan2(b-(n*p+a*E*2+i*u),S-(e*p+s*E*2+r*u)))}};let St=At;St.NONE=-1,St.BEFORE=-2,St.AFTER=-3,St.epsilon=1e-5;class bt{constructor(t,e){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new r.I9,this.active=!1,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,e=this.translateMix,n=this.scaleMix,s=this.shearMix,a=this.target,i=a.matrix,o=i.a,l=i.c,h=i.b,c=i.d,d=o*c-l*h>0?r.cj.degRad:-r.cj.degRad,u=this.data.offsetRotation*d,m=this.data.offsetShearY*d,f=this.bones;for(let i=0,d=f.length;i<d;i++){const d=f[i];let p=!1;const g=d.matrix;if(0!=t){const e=g.a,n=g.c,s=g.b,a=g.d;let i=Math.atan2(h,o)-Math.atan2(s,e)+u;i>r.cj.PI?i-=r.cj.PI2:i<-r.cj.PI&&(i+=r.cj.PI2),i*=t;const l=Math.cos(i),c=Math.sin(i);g.a=l*e-c*s,g.c=l*n-c*a,g.b=c*e+l*s,g.d=c*n+l*a,p=!0}if(0!=e){const t=this.temp;a.localToWorld(t.set(this.data.offsetX,this.data.offsetY)),g.tx+=(t.x-g.tx)*e,g.ty+=(t.y-g.ty)*e,p=!0}if(n>0){let t=Math.sqrt(g.a*g.a+g.b*g.b),e=Math.sqrt(o*o+h*h);t>1e-5&&(t=(t+(e-t+this.data.offsetScaleX)*n)/t),g.a*=t,g.b*=t,t=Math.sqrt(g.c*g.c+g.d*g.d),e=Math.sqrt(l*l+c*c),t>1e-5&&(t=(t+(e-t+this.data.offsetScaleY)*n)/t),g.c*=t,g.d*=t,p=!0}if(s>0){const t=g.c,e=g.d,n=Math.atan2(e,t);let a=Math.atan2(c,l)-Math.atan2(h,o)-(n-Math.atan2(g.b,g.a));a>r.cj.PI?a-=r.cj.PI2:a<-r.cj.PI&&(a+=r.cj.PI2),a=n+(a+m)*s;const i=Math.sqrt(t*t+e*e);g.c=Math.cos(a)*i,g.d=Math.sin(a)*i,p=!0}p&&(d.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,e=this.translateMix,n=this.scaleMix,s=this.shearMix,a=this.target,i=a.matrix,o=i.a,l=i.c,h=i.b,c=i.d,d=o*c-l*h>0?r.cj.degRad:-r.cj.degRad,u=this.data.offsetRotation*d,m=this.data.offsetShearY*d,f=this.bones;for(let i=0,d=f.length;i<d;i++){const d=f[i];let p=!1;const g=d.matrix;if(0!=t){const e=g.a,n=g.c,s=g.b,a=g.d;let i=Math.atan2(h,o)+u;i>r.cj.PI?i-=r.cj.PI2:i<-r.cj.PI&&(i+=r.cj.PI2),i*=t;const l=Math.cos(i),c=Math.sin(i);g.a=l*e-c*s,g.c=l*n-c*a,g.b=c*e+l*s,g.d=c*n+l*a,p=!0}if(0!=e){const t=this.temp;a.localToWorld(t.set(this.data.offsetX,this.data.offsetY)),g.tx+=t.x*e,g.ty+=t.y*e,p=!0}if(n>0){let t=(Math.sqrt(o*o+h*h)-1+this.data.offsetScaleX)*n+1;g.a*=t,g.b*=t,t=(Math.sqrt(l*l+c*c)-1+this.data.offsetScaleY)*n+1,g.c*=t,g.d*=t,p=!0}if(s>0){let t=Math.atan2(c,l)-Math.atan2(h,o);t>r.cj.PI?t-=r.cj.PI2:t<-r.cj.PI&&(t+=r.cj.PI2);const e=g.c,n=g.d;t=Math.atan2(n,e)+(t-r.cj.PI/2+m)*s;const a=Math.sqrt(e*e+n*n);g.c=Math.cos(t)*a,g.d=Math.sin(t)*a,p=!0}p&&(d.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,e=this.translateMix,n=this.scaleMix,s=this.shearMix,a=this.target;a.appliedValid||a.updateAppliedTransform();const r=this.bones;for(let i=0,o=r.length;i<o;i++){const o=r[i];o.appliedValid||o.updateAppliedTransform();let l=o.arotation;if(0!=t){let e=a.arotation-l+this.data.offsetRotation;e-=360*(16384-(16384.499999999996-e/360|0)),l+=e*t}let h=o.ax,c=o.ay;0!=e&&(h+=(a.ax-h+this.data.offsetX)*e,c+=(a.ay-c+this.data.offsetY)*e);let d=o.ascaleX,u=o.ascaleY;n>0&&(d>1e-5&&(d=(d+(a.ascaleX-d+this.data.offsetScaleX)*n)/d),u>1e-5&&(u=(u+(a.ascaleY-u+this.data.offsetScaleY)*n)/u));const m=o.ashearY;if(s>0){let t=a.ashearY-m+this.data.offsetShearY;t-=360*(16384-(16384.499999999996-t/360|0)),o.shearY+=t*s}o.updateWorldTransformWith(h,c,l,d,u,o.ashearX,m)}}applyRelativeLocal(){const t=this.rotateMix,e=this.translateMix,n=this.scaleMix,s=this.shearMix,a=this.target;a.appliedValid||a.updateAppliedTransform();const r=this.bones;for(let i=0,o=r.length;i<o;i++){const o=r[i];o.appliedValid||o.updateAppliedTransform();let l=o.arotation;0!=t&&(l+=(a.arotation+this.data.offsetRotation)*t);let h=o.ax,c=o.ay;0!=e&&(h+=(a.ax+this.data.offsetX)*e,c+=(a.ay+this.data.offsetY)*e);let d=o.ascaleX,u=o.ascaleY;n>0&&(d>1e-5&&(d*=(a.ascaleX-1+this.data.offsetScaleX)*n+1),u>1e-5&&(u*=(a.ascaleY-1+this.data.offsetScaleY)*n+1));let m=o.ashearY;s>0&&(m+=(a.ashearY+this.data.offsetShearY)*s),o.updateWorldTransformWith(h,c,l,d,u,o.ashearX,m)}}}const Mt=class{constructor(t){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,null==t)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){const n=t.bones[e];let s;if(null==n.parent)s=new dt(n,this,null);else{const t=this.bones[n.parent.index];s=new dt(n,this,t),t.children.push(s)}this.bones.push(s)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){const n=t.slots[e],s=this.bones[n.boneData.index],a=new A(n,s);this.slots.push(a),this.drawOrder.push(a)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){const n=t.ikConstraints[e];this.ikConstraints.push(new gt(n,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){const n=t.transformConstraints[e];this.transformConstraints.push(new bt(n,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){const n=t.pathConstraints[e];this.pathConstraints.push(new St(n,this))}this.color=new r.Q1(1,1,1,1),this.updateCache()}updateCache(){this._updateCache.length=0,this.updateCacheReset.length=0;const t=this.bones;for(let e=0,n=t.length;e<n;e++){const n=t[e];n.sorted=n.data.skinRequired,n.active=!n.sorted}if(null!=this.skin){const t=this.skin.bones;for(let e=0,n=this.skin.bones.length;e<n;e++){let n=this.bones[t[e].index];do{n.sorted=!1,n.active=!0,n=n.parent}while(null!=n)}}const e=this.ikConstraints,n=this.transformConstraints,s=this.pathConstraints,a=e.length,r=n.length,i=s.length,o=a+r+i;t:for(let t=0;t<o;t++){for(let n=0;n<a;n++){const s=e[n];if(s.data.order==t){this.sortIkConstraint(s);continue t}}for(let e=0;e<r;e++){const s=n[e];if(s.data.order==t){this.sortTransformConstraint(s);continue t}}for(let e=0;e<i;e++){const n=s[e];if(n.data.order==t){this.sortPathConstraint(n);continue t}}}for(let e=0,n=t.length;e<n;e++)this.sortBone(t[e])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||null!=this.skin&&r.Aq.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target;this.sortBone(e);const n=t.bones,s=n[0];if(this.sortBone(s),n.length>1){const t=n[n.length-1];this._updateCache.indexOf(t)>-1||this.updateCacheReset.push(t)}this._updateCache.push(t),this.sortReset(s.children),n[n.length-1].sorted=!0}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||null!=this.skin&&r.Aq.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target,n=e.data.index,s=e.bone;null!=this.skin&&this.sortPathConstraintAttachment(this.skin,n,s),null!=this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,n,s);for(let t=0,e=this.data.skins.length;t<e;t++)this.sortPathConstraintAttachment(this.data.skins[t],n,s);const a=e.getAttachment();a instanceof x&&this.sortPathConstraintAttachmentWith(a,s);const i=t.bones,o=i.length;for(let t=0;t<o;t++)this.sortBone(i[t]);this._updateCache.push(t);for(let t=0;t<o;t++)this.sortReset(i[t].children);for(let t=0;t<o;t++)i[t].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||null!=this.skin&&r.Aq.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);const e=t.bones,n=e.length;if(t.data.local)for(let t=0;t<n;t++){const n=e[t];this.sortBone(n.parent),this._updateCache.indexOf(n)>-1||this.updateCacheReset.push(n)}else for(let t=0;t<n;t++)this.sortBone(e[t]);this._updateCache.push(t);for(let t=0;t<n;t++)this.sortReset(e[t].children);for(let t=0;t<n;t++)e[t].sorted=!0}sortPathConstraintAttachment(t,e,n){const s=t.attachments[e];if(s)for(const t in s)this.sortPathConstraintAttachmentWith(s[t],n)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof x))return;const n=t.bones;if(null==n)this.sortBone(e);else{const t=this.bones;let e=0;for(;e<n.length;){const s=n[e++];for(let a=e+s;e<a;e++){const s=n[e];this.sortBone(t[s])}}}}sortBone(t){if(t.sorted)return;const e=t.parent;null!=e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,n=t.length;e<n;e++){const n=t[e];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(){const t=this.updateCacheReset;for(let e=0,n=t.length;e<n;e++){const n=t[e];n.ax=n.x,n.ay=n.y,n.arotation=n.rotation,n.ascaleX=n.scaleX,n.ascaleY=n.scaleY,n.ashearX=n.shearX,n.ashearY=n.shearY,n.appliedValid=!0}const e=this._updateCache;for(let t=0,n=e.length;t<n;t++)e[t].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let e=0,n=t.length;e<n;e++)t[e].setToSetupPose();const e=this.ikConstraints;for(let t=0,n=e.length;t<n;t++){const n=e[t];n.mix=n.data.mix,n.softness=n.data.softness,n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch}const n=this.transformConstraints;for(let t=0,e=n.length;t<e;t++){const e=n[t],s=e.data;e.rotateMix=s.rotateMix,e.translateMix=s.translateMix,e.scaleMix=s.scaleMix,e.shearMix=s.shearMix}const s=this.pathConstraints;for(let t=0,e=s.length;t<e;t++){const e=s[t],n=e.data;e.position=n.position,e.spacing=n.spacing,e.rotateMix=n.rotateMix,e.translateMix=n.translateMix}}setSlotsToSetupPose(){const t=this.slots;r.Aq.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,n=t.length;e<n;e++)t[e].setToSetupPose()}getRootBone(){return 0==this.bones.length?null:this.bones[0]}findBone(t){if(null==t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findBoneIndex(t){if(null==t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++)if(e[n].data.name==t)return n;return-1}findSlot(t){if(null==t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findSlotIndex(t){if(null==t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++)if(e[n].data.name==t)return n;return-1}setSkinByName(t){const e=this.data.findSkin(t);if(null==e)throw new Error(`Skin not found: ${t}`);this.setSkin(e)}setSkin(t){if(t!=this.skin){if(null!=t)if(null!=this.skin)t.attachAll(this,this.skin);else{const e=this.slots;for(let n=0,s=e.length;n<s;n++){const s=e[n],a=s.data.attachmentName;if(null!=a){const e=t.getAttachment(n,a);null!=e&&s.setAttachment(e)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,e){return this.getAttachment(this.data.findSlotIndex(t),e)}getAttachment(t,e){if(null==e)throw new Error("attachmentName cannot be null.");if(null!=this.skin){const n=this.skin.getAttachment(t,e);if(null!=n)return n}return null!=this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(null==t)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,a=n.length;s<a;s++){const a=n[s];if(a.data.name==t){let n=null;if(null!=e&&(n=this.getAttachment(s,e),null==n))throw new Error(`Attachment not found: ${e}, for slot: ${t}`);return void a.setAttachment(n)}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findTransformConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findPathConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}getBounds(t,e,n=new Array(2)){if(null==t)throw new Error("offset cannot be null.");if(null==e)throw new Error("size cannot be null.");const s=this.drawOrder;let a=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY,l=Number.NEGATIVE_INFINITY;for(let t=0,e=s.length;t<e;t++){const e=s[t];if(!e.bone.active)continue;let h=0,c=null;const d=e.getAttachment();if(d instanceof b)h=8,c=r.Aq.setArraySize(n,h,0),d.computeWorldVertices(e.bone,c,0,2);else if(d instanceof E){const t=d;h=t.worldVerticesLength,c=r.Aq.setArraySize(n,h,0),t.computeWorldVertices(e,0,h,c,0,2)}if(null!=c)for(let t=0,e=c.length;t<e;t+=2){const e=c[t],n=c[t+1];a=Math.min(a,e),i=Math.min(i,n),o=Math.max(o,e),l=Math.max(l,n)}}t.set(a,i),e.set(o-a,l-i)}update(t){this.time+=t}get flipX(){return-1==this.scaleX}set flipX(t){Mt.deprecatedWarning1||(Mt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return-1==this.scaleY}set flipY(t){Mt.deprecatedWarning1||(Mt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};let Tt=Mt;Tt.deprecatedWarning1=!1;class Rt{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(null==t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findBoneIndex(t){if(null==t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++)if(e[n].name==t)return n;return-1}findSlot(t){if(null==t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findSlotIndex(t){if(null==t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++)if(e[n].name==t)return n;return-1}findSkin(t){if(null==t)throw new Error("skinName cannot be null.");const e=this.skins;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findEvent(t){if(null==t)throw new Error("eventDataName cannot be null.");const e=this.events;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findAnimation(t){if(null==t)throw new Error("animationName cannot be null.");const e=this.animations;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findIkConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findTransformConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findPathConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findPathConstraintIndex(t){if(null==t)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let n=0,s=e.length;n<s;n++)if(e[n].name==t)return n;return-1}}class yt{constructor(t,e,n){if(this.color=new r.Q1(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(null==e)throw new Error("name cannot be null.");if(null==n)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=n}}class It extends mt{constructor(t){super(t,0,!1),this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}}class Ct{constructor(t,e,n){this.slotIndex=t,this.name=e,this.attachment=n}}class Vt{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,null==t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,e,n){if(null==n)throw new Error("attachment cannot be null.");const s=this.attachments;t>=s.length&&(s.length=t+1),s[t]||(s[t]={}),s[t][e]=n}addSkin(t){for(let e=0;e<t.bones.length;e++){const n=t.bones[e];let s=!1;for(let t=0;t<this.bones.length;t++)if(this.bones[t]==n){s=!0;break}s||this.bones.push(n)}for(let e=0;e<t.constraints.length;e++){const n=t.constraints[e];let s=!1;for(let t=0;t<this.constraints.length;t++)if(this.constraints[t]==n){s=!0;break}s||this.constraints.push(n)}const e=t.getAttachments();for(let t=0;t<e.length;t++){const n=e[t];this.setAttachment(n.slotIndex,n.name,n.attachment)}}copySkin(t){for(let e=0;e<t.bones.length;e++){const n=t.bones[e];let s=!1;for(let t=0;t<this.bones.length;t++)if(this.bones[t]==n){s=!0;break}s||this.bones.push(n)}for(let e=0;e<t.constraints.length;e++){const n=t.constraints[e];let s=!1;for(let t=0;t<this.constraints.length;t++)if(this.constraints[t]==n){s=!0;break}s||this.constraints.push(n)}const e=t.getAttachments();for(let t=0;t<e.length;t++){const n=e[t];null!=n.attachment&&(n.attachment instanceof E?(n.attachment=n.attachment.newLinkedMesh(),this.setAttachment(n.slotIndex,n.name,n.attachment)):(n.attachment=n.attachment.copy(),this.setAttachment(n.slotIndex,n.name,n.attachment)))}}getAttachment(t,e){const n=this.attachments[t];return n?n[e]:null}removeAttachment(t,e){const n=this.attachments[t];n&&(n[e]=null)}getAttachments(){const t=new Array;for(let e=0;e<this.attachments.length;e++){const n=this.attachments[e];if(n)for(const s in n){const a=n[s];a&&t.push(new Ct(e,s,a))}}return t}getAttachmentsForSlot(t,e){const n=this.attachments[t];if(n)for(const s in n){const a=n[s];a&&e.push(new Ct(t,s,a))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,e){let n=0;for(let s=0;s<t.slots.length;s++){const a=t.slots[s],r=a.getAttachment();if(r&&n<e.attachments.length){const t=e.attachments[n];for(const e in t)if(r==t[e]){const t=this.getAttachment(n,e);null!=t&&a.setAttachment(t);break}}n++}}}const kt=class{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,n=new Rt;n.name="";const s=new r.aG(t);if(n.hash=s.readString(),n.version=s.readString(),"3.8.75"===n.version){const t="Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.";console.error(t)}n.x=s.readFloat(),n.y=s.readFloat(),n.width=s.readFloat(),n.height=s.readFloat();const a=s.readBoolean();a&&(n.fps=s.readFloat(),n.imagesPath=s.readString(),n.audioPath=s.readString());let i=0;i=s.readInt(!0);for(let t=0;t<i;t++)s.strings.push(s.readString());i=s.readInt(!0);for(let t=0;t<i;t++){const i=s.readString(),o=0==t?null:n.bones[s.readInt(!0)],l=new ut(t,i,o);l.rotation=s.readFloat(),l.x=s.readFloat()*e,l.y=s.readFloat()*e,l.scaleX=s.readFloat(),l.scaleY=s.readFloat(),l.shearX=s.readFloat(),l.shearY=s.readFloat(),l.length=s.readFloat()*e,l.transformMode=kt.TransformModeValues[s.readInt(!0)],l.skinRequired=s.readBoolean(),a&&r.Q1.rgba8888ToColor(l.color,s.readInt32()),n.bones.push(l)}i=s.readInt(!0);for(let t=0;t<i;t++){const e=s.readString(),a=n.bones[s.readInt(!0)],i=new yt(t,e,a);r.Q1.rgba8888ToColor(i.color,s.readInt32());const o=s.readInt32();-1!=o&&r.Q1.rgb888ToColor(i.darkColor=new r.Q1,o),i.attachmentName=s.readStringRef(),i.blendMode=kt.BlendModeValues[s.readInt(!0)],n.slots.push(i)}i=s.readInt(!0);for(let t,a=0;a<i;a++){const a=new Et(s.readString());a.order=s.readInt(!0),a.skinRequired=s.readBoolean(),t=s.readInt(!0);for(let e=0;e<t;e++)a.bones.push(n.bones[s.readInt(!0)]);a.target=n.bones[s.readInt(!0)],a.mix=s.readFloat(),a.softness=s.readFloat()*e,a.bendDirection=s.readByte(),a.compress=s.readBoolean(),a.stretch=s.readBoolean(),a.uniform=s.readBoolean(),n.ikConstraints.push(a)}i=s.readInt(!0);for(let t,a=0;a<i;a++){const a=new It(s.readString());a.order=s.readInt(!0),a.skinRequired=s.readBoolean(),t=s.readInt(!0);for(let e=0;e<t;e++)a.bones.push(n.bones[s.readInt(!0)]);a.target=n.bones[s.readInt(!0)],a.local=s.readBoolean(),a.relative=s.readBoolean(),a.offsetRotation=s.readFloat(),a.offsetX=s.readFloat()*e,a.offsetY=s.readFloat()*e,a.offsetScaleX=s.readFloat(),a.offsetScaleY=s.readFloat(),a.offsetShearY=s.readFloat(),a.rotateMix=s.readFloat(),a.translateMix=s.readFloat(),a.scaleMix=s.readFloat(),a.shearMix=s.readFloat(),n.transformConstraints.push(a)}i=s.readInt(!0);for(let t,a=0;a<i;a++){const a=new xt(s.readString());a.order=s.readInt(!0),a.skinRequired=s.readBoolean(),t=s.readInt(!0);for(let e=0;e<t;e++)a.bones.push(n.bones[s.readInt(!0)]);a.target=n.slots[s.readInt(!0)],a.positionMode=kt.PositionModeValues[s.readInt(!0)],a.spacingMode=kt.SpacingModeValues[s.readInt(!0)],a.rotateMode=kt.RotateModeValues[s.readInt(!0)],a.offsetRotation=s.readFloat(),a.position=s.readFloat(),a.positionMode==r.pw.Fixed&&(a.position*=e),a.spacing=s.readFloat(),a.spacingMode!=wt.Length&&a.spacingMode!=wt.Fixed||(a.spacing*=e),a.rotateMix=s.readFloat(),a.translateMix=s.readFloat(),n.pathConstraints.push(a)}const o=this.readSkin(s,n,!0,a);null!=o&&(n.defaultSkin=o,n.skins.push(o));{let t=n.skins.length;for(r.Aq.setArraySize(n.skins,i=t+s.readInt(!0));t<i;t++)n.skins[t]=this.readSkin(s,n,!1,a)}i=this.linkedMeshes.length;for(let t=0;t<i;t++){const e=this.linkedMeshes[t],s=null==e.skin?n.defaultSkin:n.findSkin(e.skin);if(null==s)throw new Error(`Skin not found: ${e.skin}`);const a=s.getAttachment(e.slotIndex,e.parent);if(null==a)throw new Error(`Parent mesh not found: ${e.parent}`);e.mesh.deformAttachment=e.inheritDeform?a:e.mesh,e.mesh.setParentMesh(a)}this.linkedMeshes.length=0,i=s.readInt(!0);for(let t=0;t<i;t++){const t=new pt(s.readStringRef());t.intValue=s.readInt(!1),t.floatValue=s.readFloat(),t.stringValue=s.readString(),t.audioPath=s.readString(),null!=t.audioPath&&(t.volume=s.readFloat(),t.balance=s.readFloat()),n.events.push(t)}i=s.readInt(!0);for(let t=0;t<i;t++)n.animations.push(this.readAnimation(s,s.readString(),n));return n}readSkin(t,e,n,s){let a=null,r=0;if(n){if(r=t.readInt(!0),0==r)return null;a=new Vt("default")}else{a=new Vt(t.readStringRef()),a.bones.length=t.readInt(!0);for(let n=0,s=a.bones.length;n<s;n++)a.bones[n]=e.bones[t.readInt(!0)];for(let n=0,s=t.readInt(!0);n<s;n++)a.constraints.push(e.ikConstraints[t.readInt(!0)]);for(let n=0,s=t.readInt(!0);n<s;n++)a.constraints.push(e.transformConstraints[t.readInt(!0)]);for(let n=0,s=t.readInt(!0);n<s;n++)a.constraints.push(e.pathConstraints[t.readInt(!0)]);r=t.readInt(!0)}for(let n=0;n<r;n++){const n=t.readInt(!0);for(let r=0,i=t.readInt(!0);r<i;r++){const r=t.readStringRef(),i=this.readAttachment(t,e,a,n,r,s);null!=i&&a.setAttachment(n,r,i)}}return a}readAttachment(t,e,n,s,a,i){const o=this.scale;let l=t.readStringRef();null==l&&(l=a);const h=t.readByte();switch(kt.AttachmentTypeValues[h]){case r.wh.Region:{let e=t.readStringRef();const s=t.readFloat(),a=t.readFloat(),i=t.readFloat(),h=t.readFloat(),c=t.readFloat(),d=t.readFloat(),u=t.readFloat(),m=t.readInt32();null==e&&(e=l);const f=this.attachmentLoader.newRegionAttachment(n,l,e);return null==f?null:(f.path=e,f.x=a*o,f.y=i*o,f.scaleX=h,f.scaleY=c,f.rotation=s,f.width=d*o,f.height=u*o,r.Q1.rgba8888ToColor(f.color,m),f)}case r.wh.BoundingBox:{const e=t.readInt(!0),s=this.readVertices(t,e),a=i?t.readInt32():0,o=this.attachmentLoader.newBoundingBoxAttachment(n,l);return null==o?null:(o.worldVerticesLength=e<<1,o.vertices=s.vertices,o.bones=s.bones,i&&r.Q1.rgba8888ToColor(o.color,a),o)}case r.wh.Mesh:{let e=t.readStringRef();const s=t.readInt32(),a=t.readInt(!0),h=this.readFloatArray(t,a<<1,1),c=this.readShortArray(t),d=this.readVertices(t,a),u=t.readInt(!0);let m=null,f=0,p=0;i&&(m=this.readShortArray(t),f=t.readFloat(),p=t.readFloat()),null==e&&(e=l);const g=this.attachmentLoader.newMeshAttachment(n,l,e);return null==g?null:(g.path=e,r.Q1.rgba8888ToColor(g.color,s),g.bones=d.bones,g.vertices=d.vertices,g.worldVerticesLength=a<<1,g.triangles=c,g.regionUVs=new Float32Array(h),g.hullLength=u<<1,i&&(g.edges=m,g.width=f*o,g.height=p*o),g)}case r.wh.LinkedMesh:{let e=t.readStringRef();const a=t.readInt32(),h=t.readStringRef(),c=t.readStringRef(),d=t.readBoolean();let u=0,m=0;i&&(u=t.readFloat(),m=t.readFloat()),null==e&&(e=l);const f=this.attachmentLoader.newMeshAttachment(n,l,e);return null==f?null:(f.path=e,r.Q1.rgba8888ToColor(f.color,a),i&&(f.width=u*o,f.height=m*o),this.linkedMeshes.push(new Nt(f,h,s,c,d)),f)}case r.wh.Path:{const e=t.readBoolean(),s=t.readBoolean(),a=t.readInt(!0),h=this.readVertices(t,a),c=r.Aq.newArray(a/3,0);for(let e=0,n=c.length;e<n;e++)c[e]=t.readFloat()*o;const d=i?t.readInt32():0,u=this.attachmentLoader.newPathAttachment(n,l);return null==u?null:(u.closed=e,u.constantSpeed=s,u.worldVerticesLength=a<<1,u.vertices=h.vertices,u.bones=h.bones,u.lengths=c,i&&r.Q1.rgba8888ToColor(u.color,d),u)}case r.wh.Point:{const e=t.readFloat(),s=t.readFloat(),a=t.readFloat(),h=i?t.readInt32():0,c=this.attachmentLoader.newPointAttachment(n,l);return null==c?null:(c.x=s*o,c.y=a*o,c.rotation=e,i&&r.Q1.rgba8888ToColor(c.color,h),c)}case r.wh.Clipping:{const s=t.readInt(!0),a=t.readInt(!0),o=this.readVertices(t,a),h=i?t.readInt32():0,c=this.attachmentLoader.newClippingAttachment(n,l);return null==c?null:(c.endSlot=e.slots[s],c.worldVerticesLength=a<<1,c.vertices=o.vertices,c.bones=o.bones,i&&r.Q1.rgba8888ToColor(c.color,h),c)}}return null}readVertices(t,e){const n=e<<1,s=new vt,a=this.scale;if(!t.readBoolean())return s.vertices=this.readFloatArray(t,n,a),s;const i=new Array,o=new Array;for(let n=0;n<e;n++){const e=t.readInt(!0);o.push(e);for(let n=0;n<e;n++)o.push(t.readInt(!0)),i.push(t.readFloat()*a),i.push(t.readFloat()*a),i.push(t.readFloat())}return s.vertices=r.Aq.toFloatArray(i),s.bones=o,s}readFloatArray(t,e,n){const s=new Array(e);if(1==n)for(let n=0;n<e;n++)s[n]=t.readFloat();else for(let a=0;a<e;a++)s[a]=t.readFloat()*n;return s}readShortArray(t){const e=t.readInt(!0),n=new Array(e);for(let s=0;s<e;s++)n[s]=t.readShort();return n}readAnimation(t,e,n){const s=new Array,a=this.scale;let i=0;const o=new r.Q1,l=new r.Q1;for(let e=0,n=t.readInt(!0);e<n;e++){const e=t.readInt(!0);for(let n=0,a=t.readInt(!0);n<a;n++){const n=t.readByte(),a=t.readInt(!0);switch(n){case kt.SLOT_ATTACHMENT:{const n=new O(a);n.slotIndex=e;for(let e=0;e<a;e++)n.setFrame(e,t.readFloat(),t.readStringRef());s.push(n),i=Math.max(i,n.frames[a-1]);break}case kt.SLOT_COLOR:{const n=new D(a);n.slotIndex=e;for(let e=0;e<a;e++){const s=t.readFloat();r.Q1.rgba8888ToColor(o,t.readInt32()),n.setFrame(e,s,o.r,o.g,o.b,o.a),e<a-1&&this.readCurve(t,e,n)}s.push(n),i=Math.max(i,n.frames[(a-1)*D.ENTRIES]);break}case kt.SLOT_TWO_COLOR:{const n=new Y(a);n.slotIndex=e;for(let e=0;e<a;e++){const s=t.readFloat();r.Q1.rgba8888ToColor(o,t.readInt32()),r.Q1.rgb888ToColor(l,t.readInt32()),n.setFrame(e,s,o.r,o.g,o.b,o.a,l.r,l.g,l.b),e<a-1&&this.readCurve(t,e,n)}s.push(n),i=Math.max(i,n.frames[(a-1)*Y.ENTRIES]);break}}}}for(let e=0,n=t.readInt(!0);e<n;e++){const e=t.readInt(!0);for(let n=0,r=t.readInt(!0);n<r;n++){const n=t.readByte(),r=t.readInt(!0);switch(n){case kt.BONE_ROTATE:{const n=new P(r);n.boneIndex=e;for(let e=0;e<r;e++)n.setFrame(e,t.readFloat(),t.readFloat()),e<r-1&&this.readCurve(t,e,n);s.push(n),i=Math.max(i,n.frames[(r-1)*P.ENTRIES]);break}case kt.BONE_TRANSLATE:case kt.BONE_SCALE:case kt.BONE_SHEAR:{let o,l=1;n==kt.BONE_SCALE?o=new q(r):n==kt.BONE_SHEAR?o=new F(r):(o=new v(r),l=a),o.boneIndex=e;for(let e=0;e<r;e++)o.setFrame(e,t.readFloat(),t.readFloat()*l,t.readFloat()*l),e<r-1&&this.readCurve(t,e,o);s.push(o),i=Math.max(i,o.frames[(r-1)*v.ENTRIES]);break}}}}for(let e=0,n=t.readInt(!0);e<n;e++){const e=t.readInt(!0),n=t.readInt(!0),r=new $(n);r.ikConstraintIndex=e;for(let e=0;e<n;e++)r.setFrame(e,t.readFloat(),t.readFloat(),t.readFloat()*a,t.readByte(),t.readBoolean(),t.readBoolean()),e<n-1&&this.readCurve(t,e,r);s.push(r),i=Math.max(i,r.frames[(n-1)*$.ENTRIES])}for(let e=0,n=t.readInt(!0);e<n;e++){const e=t.readInt(!0),n=t.readInt(!0),a=new Q(n);a.transformConstraintIndex=e;for(let e=0;e<n;e++)a.setFrame(e,t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat()),e<n-1&&this.readCurve(t,e,a);s.push(a),i=Math.max(i,a.frames[(n-1)*Q.ENTRIES])}for(let e=0,o=t.readInt(!0);e<o;e++){const e=t.readInt(!0),o=n.pathConstraints[e];for(let n=0,l=t.readInt(!0);n<l;n++){const n=t.readByte(),l=t.readInt(!0);switch(n){case kt.PATH_POSITION:case kt.PATH_SPACING:{let h,c=1;n==kt.PATH_SPACING?(h=new z(l),o.spacingMode!=wt.Length&&o.spacingMode!=wt.Fixed||(c=a)):(h=new Z(l),o.positionMode==r.pw.Fixed&&(c=a)),h.pathConstraintIndex=e;for(let e=0;e<l;e++)h.setFrame(e,t.readFloat(),t.readFloat()*c),e<l-1&&this.readCurve(t,e,h);s.push(h),i=Math.max(i,h.frames[(l-1)*Z.ENTRIES]);break}case kt.PATH_MIX:{const n=new K(l);n.pathConstraintIndex=e;for(let e=0;e<l;e++)n.setFrame(e,t.readFloat(),t.readFloat(),t.readFloat()),e<l-1&&this.readCurve(t,e,n);s.push(n),i=Math.max(i,n.frames[(l-1)*K.ENTRIES]);break}}}}for(let e=0,o=t.readInt(!0);e<o;e++){const e=n.skins[t.readInt(!0)];for(let n=0,o=t.readInt(!0);n<o;n++){const n=t.readInt(!0);for(let o=0,l=t.readInt(!0);o<l;o++){const o=e.getAttachment(n,t.readStringRef()),l=null!=o.bones,h=o.vertices,c=l?h.length/3*2:h.length,d=t.readInt(!0),u=new L(d);u.slotIndex=n,u.attachment=o;for(let e=0;e<d;e++){const n=t.readFloat();let s,i=t.readInt(!0);if(0==i)s=l?r.Aq.newFloatArray(c):h;else{s=r.Aq.newFloatArray(c);const e=t.readInt(!0);if(i+=e,1==a)for(let n=e;n<i;n++)s[n]=t.readFloat();else for(let n=e;n<i;n++)s[n]=t.readFloat()*a;if(!l)for(let t=0,e=s.length;t<e;t++)s[t]+=h[t]}u.setFrame(e,n,s),e<d-1&&this.readCurve(t,e,u)}s.push(u),i=Math.max(i,u.frames[d-1])}}}const h=t.readInt(!0);if(h>0){const e=new j(h),a=n.slots.length;for(let n=0;n<h;n++){const s=t.readFloat(),i=t.readInt(!0),o=r.Aq.newArray(a,0);for(let t=a-1;t>=0;t--)o[t]=-1;const l=r.Aq.newArray(a-i,0);let h=0,c=0;for(let e=0;e<i;e++){const e=t.readInt(!0);for(;h!=e;)l[c++]=h++;o[h+t.readInt(!0)]=h++}for(;h<a;)l[c++]=h++;for(let t=a-1;t>=0;t--)-1==o[t]&&(o[t]=l[--c]);e.setFrame(n,s,o)}s.push(e),i=Math.max(i,e.frames[h-1])}const c=t.readInt(!0);if(c>0){const e=new U(c);for(let s=0;s<c;s++){const a=t.readFloat(),r=n.events[t.readInt(!0)],i=new ft(a,r);i.intValue=t.readInt(!1),i.floatValue=t.readFloat(),i.stringValue=t.readBoolean()?t.readString():r.stringValue,null!=i.data.audioPath&&(i.volume=t.readFloat(),i.balance=t.readFloat()),e.setFrame(s,i)}s.push(e),i=Math.max(i,e.frames[c-1])}return new y(e,s,i)}readCurve(t,e,n){switch(t.readByte()){case kt.CURVE_STEPPED:n.setStepped(e);break;case kt.CURVE_BEZIER:this.setCurve(n,e,t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat())}}setCurve(t,e,n,s,a,r){t.setCurve(e,n,s,a,r)}};let Pt=kt;Pt.AttachmentTypeValues=[0,1,2,3,4,5,6],Pt.TransformModeValues=[r._C.Normal,r._C.OnlyTranslation,r._C.NoRotationOrReflection,r._C.NoScale,r._C.NoScaleOrReflection],Pt.PositionModeValues=[r.pw.Fixed,r.pw.Percent],Pt.SpacingModeValues=[wt.Length,wt.Fixed,wt.Percent],Pt.RotateModeValues=[r.Dr.Tangent,r.Dr.Chain,r.Dr.ChainScale],Pt.BlendModeValues=[o.B9.NORMAL,o.B9.ADD,o.B9.MULTIPLY,o.B9.SCREEN],Pt.BONE_ROTATE=0,Pt.BONE_TRANSLATE=1,Pt.BONE_SCALE=2,Pt.BONE_SHEAR=3,Pt.SLOT_ATTACHMENT=0,Pt.SLOT_COLOR=1,Pt.SLOT_TWO_COLOR=2,Pt.PATH_POSITION=0,Pt.PATH_SPACING=1,Pt.PATH_MIX=2,Pt.CURVE_LINEAR=0,Pt.CURVE_STEPPED=1,Pt.CURVE_BEZIER=2;class Nt{constructor(t,e,n,s,a){this.mesh=t,this.skin=e,this.slotIndex=n,this.parent=s,this.inheritDeform=a}}class vt{constructor(t=null,e=null){this.bones=t,this.vertices=e}}class qt extends r.S3{}class Ft{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,n=new Rt,s="string"==typeof t?JSON.parse(t):t,a=s.skeleton;if(null!=a){if(n.hash=a.hash,n.version=a.spine,"3.8"!==n.version.substr(0,3)){const t=`Spine 3.8 loader cant load version ${a.spine}. Please configure your pixi-spine bundle`;console.error(t)}if("3.8.75"===n.version){const t="Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.";console.error(t)}n.x=a.x,n.y=a.y,n.width=a.width,n.height=a.height,n.fps=a.fps,n.imagesPath=a.images}if(s.bones)for(let t=0;t<s.bones.length;t++){const a=s.bones[t];let r=null;const i=this.getValue(a,"parent",null);if(null!=i&&(r=n.findBone(i),null==r))throw new Error(`Parent bone not found: ${i}`);const o=new ut(n.bones.length,a.name,r);o.length=this.getValue(a,"length",0)*e,o.x=this.getValue(a,"x",0)*e,o.y=this.getValue(a,"y",0)*e,o.rotation=this.getValue(a,"rotation",0),o.scaleX=this.getValue(a,"scaleX",1),o.scaleY=this.getValue(a,"scaleY",1),o.shearX=this.getValue(a,"shearX",0),o.shearY=this.getValue(a,"shearY",0),o.transformMode=Ft.transformModeFromString(this.getValue(a,"transform","normal")),o.skinRequired=this.getValue(a,"skin",!1),n.bones.push(o)}if(s.slots)for(let t=0;t<s.slots.length;t++){const e=s.slots[t],a=e.name,i=e.bone,o=n.findBone(i);if(null==o)throw new Error(`Slot bone not found: ${i}`);const l=new yt(n.slots.length,a,o),h=this.getValue(e,"color",null);null!=h&&l.color.setFromString(h);const c=this.getValue(e,"dark",null);null!=c&&(l.darkColor=new r.Q1(1,1,1,1),l.darkColor.setFromString(c)),l.attachmentName=this.getValue(e,"attachment",null),l.blendMode=Ft.blendModeFromString(this.getValue(e,"blend","normal")),n.slots.push(l)}if(s.ik)for(let t=0;t<s.ik.length;t++){const a=s.ik[t],r=new Et(a.name);r.order=this.getValue(a,"order",0),r.skinRequired=this.getValue(a,"skin",!1);for(let t=0;t<a.bones.length;t++){const e=a.bones[t],s=n.findBone(e);if(null==s)throw new Error(`IK bone not found: ${e}`);r.bones.push(s)}const i=a.target;if(r.target=n.findBone(i),null==r.target)throw new Error(`IK target bone not found: ${i}`);r.mix=this.getValue(a,"mix",1),r.softness=this.getValue(a,"softness",0)*e,r.bendDirection=this.getValue(a,"bendPositive",!0)?1:-1,r.compress=this.getValue(a,"compress",!1),r.stretch=this.getValue(a,"stretch",!1),r.uniform=this.getValue(a,"uniform",!1),n.ikConstraints.push(r)}if(s.transform)for(let t=0;t<s.transform.length;t++){const a=s.transform[t],r=new It(a.name);r.order=this.getValue(a,"order",0),r.skinRequired=this.getValue(a,"skin",!1);for(let t=0;t<a.bones.length;t++){const e=a.bones[t],s=n.findBone(e);if(null==s)throw new Error(`Transform constraint bone not found: ${e}`);r.bones.push(s)}const i=a.target;if(r.target=n.findBone(i),null==r.target)throw new Error(`Transform constraint target bone not found: ${i}`);r.local=this.getValue(a,"local",!1),r.relative=this.getValue(a,"relative",!1),r.offsetRotation=this.getValue(a,"rotation",0),r.offsetX=this.getValue(a,"x",0)*e,r.offsetY=this.getValue(a,"y",0)*e,r.offsetScaleX=this.getValue(a,"scaleX",0),r.offsetScaleY=this.getValue(a,"scaleY",0),r.offsetShearY=this.getValue(a,"shearY",0),r.rotateMix=this.getValue(a,"rotateMix",1),r.translateMix=this.getValue(a,"translateMix",1),r.scaleMix=this.getValue(a,"scaleMix",1),r.shearMix=this.getValue(a,"shearMix",1),n.transformConstraints.push(r)}if(s.path)for(let t=0;t<s.path.length;t++){const a=s.path[t],i=new xt(a.name);i.order=this.getValue(a,"order",0),i.skinRequired=this.getValue(a,"skin",!1);for(let t=0;t<a.bones.length;t++){const e=a.bones[t],s=n.findBone(e);if(null==s)throw new Error(`Transform constraint bone not found: ${e}`);i.bones.push(s)}const o=a.target;if(i.target=n.findSlot(o),null==i.target)throw new Error(`Path target slot not found: ${o}`);i.positionMode=Ft.positionModeFromString(this.getValue(a,"positionMode","percent")),i.spacingMode=Ft.spacingModeFromString(this.getValue(a,"spacingMode","length")),i.rotateMode=Ft.rotateModeFromString(this.getValue(a,"rotateMode","tangent")),i.offsetRotation=this.getValue(a,"rotation",0),i.position=this.getValue(a,"position",0),i.positionMode==r.pw.Fixed&&(i.position*=e),i.spacing=this.getValue(a,"spacing",0),i.spacingMode!=wt.Length&&i.spacingMode!=wt.Fixed||(i.spacing*=e),i.rotateMix=this.getValue(a,"rotateMix",1),i.translateMix=this.getValue(a,"translateMix",1),n.pathConstraints.push(i)}if(s.skins)for(let t=0;t<s.skins.length;t++){const e=s.skins[t],a=new Vt(e.name);if(e.bones)for(let s=0;s<e.bones.length;s++){const r=n.findBone(e.bones[s]);if(null==r)throw new Error(`Skin bone not found: ${e.bones[t]}`);a.bones.push(r)}if(e.ik)for(let s=0;s<e.ik.length;s++){const r=n.findIkConstraint(e.ik[s]);if(null==r)throw new Error(`Skin IK constraint not found: ${e.ik[t]}`);a.constraints.push(r)}if(e.transform)for(let s=0;s<e.transform.length;s++){const r=n.findTransformConstraint(e.transform[s]);if(null==r)throw new Error(`Skin transform constraint not found: ${e.transform[t]}`);a.constraints.push(r)}if(e.path)for(let s=0;s<e.path.length;s++){const r=n.findPathConstraint(e.path[s]);if(null==r)throw new Error(`Skin path constraint not found: ${e.path[t]}`);a.constraints.push(r)}for(const t in e.attachments){const s=n.findSlot(t);if(null==s)throw new Error(`Slot not found: ${t}`);const r=e.attachments[t];for(const t in r){const e=this.readAttachment(r[t],a,s.index,t,n);null!=e&&a.setAttachment(s.index,t,e)}}n.skins.push(a),"default"==a.name&&(n.defaultSkin=a)}for(let t=0,e=this.linkedMeshes.length;t<e;t++){const e=this.linkedMeshes[t],s=null==e.skin?n.defaultSkin:n.findSkin(e.skin);if(null==s)throw new Error(`Skin not found: ${e.skin}`);const a=s.getAttachment(e.slotIndex,e.parent);if(null==a)throw new Error(`Parent mesh not found: ${e.parent}`);e.mesh.deformAttachment=e.inheritDeform?a:e.mesh,e.mesh.setParentMesh(a)}if(this.linkedMeshes.length=0,s.events)for(const t in s.events){const e=s.events[t],a=new pt(t);a.intValue=this.getValue(e,"int",0),a.floatValue=this.getValue(e,"float",0),a.stringValue=this.getValue(e,"string",""),a.audioPath=this.getValue(e,"audio",null),null!=a.audioPath&&(a.volume=this.getValue(e,"volume",1),a.balance=this.getValue(e,"balance",0)),n.events.push(a)}if(s.animations)for(const t in s.animations){const e=s.animations[t];this.readAnimation(e,t,n)}return n}readAttachment(t,e,n,s,a){const i=this.scale;switch(s=this.getValue(t,"name",s),this.getValue(t,"type","region")){case"region":{const n=this.getValue(t,"path",s),a=this.attachmentLoader.newRegionAttachment(e,s,n);if(null==a)return null;a.path=n,a.x=this.getValue(t,"x",0)*i,a.y=this.getValue(t,"y",0)*i,a.scaleX=this.getValue(t,"scaleX",1),a.scaleY=this.getValue(t,"scaleY",1),a.rotation=this.getValue(t,"rotation",0),a.width=t.width*i,a.height=t.height*i;const r=this.getValue(t,"color",null);return null!=r&&a.color.setFromString(r),a}case"boundingbox":{const n=this.attachmentLoader.newBoundingBoxAttachment(e,s);if(null==n)return null;this.readVertices(t,n,t.vertexCount<<1);const a=this.getValue(t,"color",null);return null!=a&&n.color.setFromString(a),n}case"mesh":case"linkedmesh":{const a=this.getValue(t,"path",s),r=this.attachmentLoader.newMeshAttachment(e,s,a);if(null==r)return null;r.path=a;const o=this.getValue(t,"color",null);null!=o&&r.color.setFromString(o),r.width=this.getValue(t,"width",0)*i,r.height=this.getValue(t,"height",0)*i;const l=this.getValue(t,"parent",null);if(null!=l)return this.linkedMeshes.push(new _t(r,this.getValue(t,"skin",null),n,l,this.getValue(t,"deform",!0))),r;const h=t.uvs;return this.readVertices(t,r,h.length),r.triangles=t.triangles,r.regionUVs=new Float32Array(h),r.edges=this.getValue(t,"edges",null),r.hullLength=2*this.getValue(t,"hull",0),r}case"path":{const n=this.attachmentLoader.newPathAttachment(e,s);if(null==n)return null;n.closed=this.getValue(t,"closed",!1),n.constantSpeed=this.getValue(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,n,a<<1);const o=r.Aq.newArray(a/3,0);for(let e=0;e<t.lengths.length;e++)o[e]=t.lengths[e]*i;n.lengths=o;const l=this.getValue(t,"color",null);return null!=l&&n.color.setFromString(l),n}case"point":{const n=this.attachmentLoader.newPointAttachment(e,s);if(null==n)return null;n.x=this.getValue(t,"x",0)*i,n.y=this.getValue(t,"y",0)*i,n.rotation=this.getValue(t,"rotation",0);const a=this.getValue(t,"color",null);return null!=a&&n.color.setFromString(a),n}case"clipping":{const n=this.attachmentLoader.newClippingAttachment(e,s);if(null==n)return null;const r=this.getValue(t,"end",null);if(null!=r){const t=a.findSlot(r);if(null==t)throw new Error(`Clipping end slot not found: ${r}`);n.endSlot=t}const i=t.vertexCount;this.readVertices(t,n,i<<1);const o=this.getValue(t,"color",null);return null!=o&&n.color.setFromString(o),n}}return null}readVertices(t,e,n){const s=this.scale;e.worldVerticesLength=n;const a=t.vertices;if(n==a.length){const t=r.Aq.toFloatArray(a);if(1!=s)for(let e=0,n=a.length;e<n;e++)t[e]*=s;return void(e.vertices=t)}const i=new Array,o=new Array;for(let t=0,e=a.length;t<e;){const e=a[t++];o.push(e);for(let n=t+4*e;t<n;t+=4)o.push(a[t]),i.push(a[t+1]*s),i.push(a[t+2]*s),i.push(a[t+3])}e.bones=o,e.vertices=r.Aq.toFloatArray(i)}readAnimation(t,e,n){const s=this.scale,a=new Array;let i=0;if(t.slots)for(const e in t.slots){const s=t.slots[e],o=n.findSlotIndex(e);if(-1==o)throw new Error(`Slot not found: ${e}`);for(const t in s){const n=s[t];if("attachment"==t){const t=new O(n.length);t.slotIndex=o;let e=0;for(let s=0;s<n.length;s++){const a=n[s];t.setFrame(e++,this.getValue(a,"time",0),a.name)}a.push(t),i=Math.max(i,t.frames[t.getFrameCount()-1])}else if("color"==t){const t=new D(n.length);t.slotIndex=o;let e=0;for(let s=0;s<n.length;s++){const a=n[s],i=new r.Q1;i.setFromString(a.color||"ffffffff"),t.setFrame(e,this.getValue(a,"time",0),i.r,i.g,i.b,i.a),this.readCurve(a,t,e),e++}a.push(t),i=Math.max(i,t.frames[(t.getFrameCount()-1)*D.ENTRIES])}else{if("twoColor"!=t)throw new Error(`Invalid timeline type for a slot: ${t} (${e})`);{const t=new Y(n.length);t.slotIndex=o;let e=0;for(let s=0;s<n.length;s++){const a=n[s],i=new r.Q1,o=new r.Q1;i.setFromString(a.light),o.setFromString(a.dark),t.setFrame(e,this.getValue(a,"time",0),i.r,i.g,i.b,i.a,o.r,o.g,o.b),this.readCurve(a,t,e),e++}a.push(t),i=Math.max(i,t.frames[(t.getFrameCount()-1)*Y.ENTRIES])}}}}if(t.bones)for(const e in t.bones){const r=t.bones[e],o=n.findBoneIndex(e);if(-1==o)throw new Error(`Bone not found: ${e}`);for(const t in r){const n=r[t];if("rotate"===t){const t=new P(n.length);t.boneIndex=o;let e=0;for(let s=0;s<n.length;s++){const a=n[s];t.setFrame(e,this.getValue(a,"time",0),this.getValue(a,"angle",0)),this.readCurve(a,t,e),e++}a.push(t),i=Math.max(i,t.frames[(t.getFrameCount()-1)*P.ENTRIES])}else{if("translate"!==t&&"scale"!==t&&"shear"!==t)throw new Error(`Invalid timeline type for a bone: ${t} (${e})`);{let e=null,r=1,l=0;"scale"===t?(e=new q(n.length),l=1):"shear"===t?e=new F(n.length):(e=new v(n.length),r=s),e.boneIndex=o;let h=0;for(let t=0;t<n.length;t++){const s=n[t],a=this.getValue(s,"x",l),i=this.getValue(s,"y",l);e.setFrame(h,this.getValue(s,"time",0),a*r,i*r),this.readCurve(s,e,h),h++}a.push(e),i=Math.max(i,e.frames[(e.getFrameCount()-1)*v.ENTRIES])}}}}if(t.ik)for(const e in t.ik){const r=t.ik[e],o=n.findIkConstraint(e),l=new $(r.length);l.ikConstraintIndex=n.ikConstraints.indexOf(o);let h=0;for(let t=0;t<r.length;t++){const e=r[t];l.setFrame(h,this.getValue(e,"time",0),this.getValue(e,"mix",1),this.getValue(e,"softness",0)*s,this.getValue(e,"bendPositive",!0)?1:-1,this.getValue(e,"compress",!1),this.getValue(e,"stretch",!1)),this.readCurve(e,l,h),h++}a.push(l),i=Math.max(i,l.frames[(l.getFrameCount()-1)*$.ENTRIES])}if(t.transform)for(const e in t.transform){const s=t.transform[e],r=n.findTransformConstraint(e),o=new Q(s.length);o.transformConstraintIndex=n.transformConstraints.indexOf(r);let l=0;for(let t=0;t<s.length;t++){const e=s[t];o.setFrame(l,this.getValue(e,"time",0),this.getValue(e,"rotateMix",1),this.getValue(e,"translateMix",1),this.getValue(e,"scaleMix",1),this.getValue(e,"shearMix",1)),this.readCurve(e,o,l),l++}a.push(o),i=Math.max(i,o.frames[(o.getFrameCount()-1)*Q.ENTRIES])}if(t.path)for(const e in t.path){const o=t.path[e],l=n.findPathConstraintIndex(e);if(-1==l)throw new Error(`Path constraint not found: ${e}`);const h=n.pathConstraints[l];for(const t in o){const e=o[t];if("position"===t||"spacing"===t){let n=null,o=1;"spacing"===t?(n=new z(e.length),h.spacingMode!=wt.Length&&h.spacingMode!=wt.Fixed||(o=s)):(n=new Z(e.length),h.positionMode==r.pw.Fixed&&(o=s)),n.pathConstraintIndex=l;let c=0;for(let s=0;s<e.length;s++){const a=e[s];n.setFrame(c,this.getValue(a,"time",0),this.getValue(a,t,0)*o),this.readCurve(a,n,c),c++}a.push(n),i=Math.max(i,n.frames[(n.getFrameCount()-1)*Z.ENTRIES])}else if("mix"===t){const t=new K(e.length);t.pathConstraintIndex=l;let n=0;for(let s=0;s<e.length;s++){const a=e[s];t.setFrame(n,this.getValue(a,"time",0),this.getValue(a,"rotateMix",1),this.getValue(a,"translateMix",1)),this.readCurve(a,t,n),n++}a.push(t),i=Math.max(i,t.frames[(t.getFrameCount()-1)*K.ENTRIES])}}}if(t.deform)for(const e in t.deform){const o=t.deform[e],l=n.findSkin(e);if(null!=l)for(const t in o){const e=o[t],h=n.findSlotIndex(t);if(-1==h)throw new Error(`Slot not found: ${e.name}`);for(const t in e){const n=e[t],o=l.getAttachment(h,t);if(null==o)throw new Error(`Deform attachment not found: ${n.name}`);const c=null!=o.bones,d=o.vertices,u=c?d.length/3*2:d.length,m=new L(n.length);m.slotIndex=h,m.attachment=o;let f=0;for(let t=0;t<n.length;t++){const e=n[t];let a;const i=this.getValue(e,"vertices",null);if(null==i)a=c?r.Aq.newFloatArray(u):d;else{a=r.Aq.newFloatArray(u);const t=this.getValue(e,"offset",0);if(r.Aq.arrayCopy(i,0,a,t,i.length),1!=s)for(let e=t,n=e+i.length;e<n;e++)a[e]*=s;if(!c)for(let t=0;t<u;t++)a[t]+=d[t]}m.setFrame(f,this.getValue(e,"time",0),a),this.readCurve(e,m,f),f++}a.push(m),i=Math.max(i,m.frames[m.getFrameCount()-1])}}else if(r.W0.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${e}`)}let o=t.drawOrder;if(null==o&&(o=t.draworder),null!=o){const t=new j(o.length),e=n.slots.length;let s=0;for(let a=0;a<o.length;a++){const i=o[a];let l=null;const h=this.getValue(i,"offsets",null);if(null!=h){l=r.Aq.newArray(e,-1);const t=r.Aq.newArray(e-h.length,0);let s=0,a=0;for(let e=0;e<h.length;e++){const r=h[e],i=n.findSlotIndex(r.slot);if(-1==i)throw new Error(`Slot not found: ${r.slot}`);for(;s!=i;)t[a++]=s++;l[s+r.offset]=s++}for(;s<e;)t[a++]=s++;for(let n=e-1;n>=0;n--)-1==l[n]&&(l[n]=t[--a])}t.setFrame(s++,this.getValue(i,"time",0),l)}a.push(t),i=Math.max(i,t.frames[t.getFrameCount()-1])}if(t.events){const e=new U(t.events.length);let s=0;for(let a=0;a<t.events.length;a++){const i=t.events[a],o=n.findEvent(i.name);if(null==o)throw new Error(`Event not found: ${i.name}`);const l=new ft(r.Aq.toSinglePrecision(this.getValue(i,"time",0)),o);l.intValue=this.getValue(i,"int",o.intValue),l.floatValue=this.getValue(i,"float",o.floatValue),l.stringValue=this.getValue(i,"string",o.stringValue),null!=l.data.audioPath&&(l.volume=this.getValue(i,"volume",1),l.balance=this.getValue(i,"balance",0)),e.setFrame(s++,l)}a.push(e),i=Math.max(i,e.frames[e.getFrameCount()-1])}if(isNaN(i))throw new Error("Error while parsing animation, duration is NaN");n.animations.push(new y(e,a,i))}readCurve(t,e,n){if(t.hasOwnProperty("curve"))if("stepped"===t.curve)e.setStepped(n);else{const s=t.curve;e.setCurve(n,s,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,e,n){return void 0!==t[e]?t[e]:n}static blendModeFromString(t){if("normal"==(t=t.toLowerCase()))return o.B9.NORMAL;if("additive"==t)return o.B9.ADD;if("multiply"==t)return o.B9.MULTIPLY;if("screen"==t)return o.B9.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if("fixed"==(t=t.toLowerCase()))return r.pw.Fixed;if("percent"==t)return r.pw.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if("length"==(t=t.toLowerCase()))return wt.Length;if("fixed"==t)return wt.Fixed;if("percent"==t)return wt.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if("tangent"==(t=t.toLowerCase()))return r.Dr.Tangent;if("chain"==t)return r.Dr.Chain;if("chainscale"==t)return r.Dr.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if("normal"==(t=t.toLowerCase()))return r._C.Normal;if("onlytranslation"==t)return r._C.OnlyTranslation;if("norotationorreflection"==t)return r._C.NoRotationOrReflection;if("noscale"==t)return r._C.NoScale;if("noscaleorreflection"==t)return r._C.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}}class _t{constructor(t,e,n,s,a){this.mesh=t,this.skin=e,this.slotIndex=n,this.parent=s,this.inheritDeform=a}}class Dt extends r.bJ{createSkeleton(t){this.skeleton=new Tt(t),this.skeleton.updateWorldTransform(),this.stateData=new ht(t),this.state=new et(this.stateData)}}class Xt{constructor(t){if(null==t)throw new Error("name cannot be null.");this.name=t}}const Yt=class extends Xt{constructor(t){super(t),this.id=(65535&Yt.nextID++)<<11,this.worldVerticesLength=0}computeWorldVerticesOld(t,e){this.computeWorldVertices(t,0,this.worldVerticesLength,e,0,2)}computeWorldVertices(t,e,n,s,a,r){n=a+(n>>1)*r;const i=t.bone.skeleton,o=t.attachmentVertices;let l=this.vertices;const h=this.bones;if(null==h){o.length>0&&(l=o);const i=t.bone.matrix,h=i.tx,c=i.ty,d=i.a,u=i.c,m=i.b,f=i.d;for(let t=e,i=a;i<n;t+=2,i+=r){const e=l[t],n=l[t+1];s[i]=e*d+n*u+h,s[i+1]=e*m+n*f+c}return}let c=0,d=0;for(let t=0;t<e;t+=2){const t=h[c];c+=t+1,d+=t}const u=i.bones;if(0==o.length)for(let t=a,e=3*d;t<n;t+=r){let n=0,a=0,r=h[c++];for(r+=c;c<r;c++,e+=3){const t=u[h[c]].matrix,s=l[e],r=l[e+1],i=l[e+2];n+=(s*t.a+r*t.c+t.tx)*i,a+=(s*t.b+r*t.d+t.ty)*i}s[t]=n,s[t+1]=a}else{const t=o;for(let e=a,i=3*d,o=d<<1;e<n;e+=r){let n=0,a=0,r=h[c++];for(r+=c;c<r;c++,i+=3,o+=2){const e=u[h[c]].matrix,s=l[i]+t[o],r=l[i+1]+t[o+1],d=l[i+2];n+=(s*e.a+r*e.c+e.tx)*d,a+=(s*e.b+r*e.d+e.ty)*d}s[e]=n,s[e+1]=a}}}applyDeform(t){return this==t}};let Ot=Yt;Ot.nextID=0;class Bt extends Ot{constructor(t){super(t),this.type=r.wh.BoundingBox,this.color=new r.Q1(1,1,1,1)}}class Lt extends Ot{constructor(t){super(t),this.type=r.wh.Clipping,this.color=new r.Q1(.2275,.2275,.8078,1)}}class Ut extends Ot{constructor(t){super(t),this.type=r.wh.Mesh,this.color=new r.Q1(1,1,1,1),this.inheritDeform=!1,this.tempColor=new r.Q1(0,0,0,0)}applyDeform(t){return this==t||this.inheritDeform&&this.parentMesh==t}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,null!=t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}}class jt extends Ot{constructor(t){super(t),this.type=r.wh.Path,this.closed=!1,this.constantSpeed=!1,this.color=new r.Q1(1,1,1,1)}}class Wt extends Ot{constructor(t){super(t),this.type=r.wh.Point,this.color=new r.Q1(.38,.94,0,1)}computeWorldPosition(t,e){const n=t.matrix;return e.x=this.x*n.a+this.y*n.c+t.worldX,e.y=this.x*n.b+this.y*n.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,n=r.cj.cosDeg(this.rotation),s=r.cj.sinDeg(this.rotation),a=n*e.a+s*e.c,i=n*e.b+s*e.d;return Math.atan2(i,a)*r.cj.radDeg}}class $t{constructor(t,e){if(this.attachmentVertices=new Array,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new r.Q1,this.darkColor=null==t.darkColor?null:new r.Q1,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.attachmentVertices.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),null!=this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),null==this.data.attachmentName?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const Ht=class extends Xt{constructor(t){super(t),this.type=r.wh.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new r.Q1(1,1,1,1),this.offset=r.Aq.newFloatArray(8),this.uvs=r.Aq.newFloatArray(8),this.tempColor=new r.Q1(1,1,1,1)}updateOffset(){const t=this.width/this.region.originalWidth*this.scaleX,e=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*t,s=-this.height/2*this.scaleY+this.region.offsetY*e,a=n+this.region.width*t,r=s+this.region.height*e,i=this.rotation*Math.PI/180,o=Math.cos(i),l=Math.sin(i),h=n*o+this.x,c=n*l,d=s*o+this.y,u=s*l,m=a*o+this.x,f=a*l,p=r*o+this.y,g=r*l,E=this.offset;E[Ht.OX1]=h-u,E[Ht.OY1]=d+c,E[Ht.OX2]=h-g,E[Ht.OY2]=p+c,E[Ht.OX3]=m-g,E[Ht.OY3]=p+f,E[Ht.OX4]=m-u,E[Ht.OY4]=d+f}setRegion(t){this.region=t;const e=this.uvs;t.rotate?(e[2]=t.u,e[3]=t.v2,e[4]=t.u,e[5]=t.v,e[6]=t.u2,e[7]=t.v,e[0]=t.u2,e[1]=t.v2):(e[0]=t.u,e[1]=t.v2,e[2]=t.u,e[3]=t.v,e[4]=t.u2,e[5]=t.v,e[6]=t.u2,e[7]=t.v2)}computeWorldVertices(t,e,n,s){const a=this.offset,r=t instanceof $t?t.bone.matrix:t.matrix,i=r.tx,o=r.ty,l=r.a,h=r.c,c=r.b,d=r.d;let u=0,m=0;u=a[Ht.OX1],m=a[Ht.OY1],e[n]=u*l+m*h+i,e[n+1]=u*c+m*d+o,n+=s,u=a[Ht.OX2],m=a[Ht.OY2],e[n]=u*l+m*h+i,e[n+1]=u*c+m*d+o,n+=s,u=a[Ht.OX3],m=a[Ht.OY3],e[n]=u*l+m*h+i,e[n+1]=u*c+m*d+o,n+=s,u=a[Ht.OX4],m=a[Ht.OY4],e[n]=u*l+m*h+i,e[n+1]=u*c+m*d+o}};let Qt=Ht;Qt.OX1=0,Qt.OY1=1,Qt.OX2=2,Qt.OY2=3,Qt.OX3=4,Qt.OY3=5,Qt.OX4=6,Qt.OY4=7,Qt.X1=0,Qt.Y1=1,Qt.C1R=2,Qt.C1G=3,Qt.C1B=4,Qt.C1A=5,Qt.U1=6,Qt.V1=7,Qt.X2=8,Qt.Y2=9,Qt.C2R=10,Qt.C2G=11,Qt.C2B=12,Qt.C2A=13,Qt.U2=14,Qt.V2=15,Qt.X3=16,Qt.Y3=17,Qt.C3R=18,Qt.C3G=19,Qt.C3B=20,Qt.C3A=21,Qt.U3=22,Qt.V3=23,Qt.X4=24,Qt.Y4=25,Qt.C4R=26,Qt.C4G=27,Qt.C4B=28,Qt.C4A=29,Qt.U4=30,Qt.V4=31;class Gt{constructor(t,e){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=e}begin(t){}transform(t,e,n,s){t.x+=r.cj.randomTriangular(-this.jitterX,this.jitterY),t.y+=r.cj.randomTriangular(-this.jitterX,this.jitterY)}end(){}}const Zt=class{constructor(t){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=t}begin(t){this.worldX=t.x+this.centerX,this.worldY=t.y+this.centerY}transform(t,e,n,s){const a=this.angle*r.cj.degreesToRadians,i=t.x-this.worldX,o=t.y-this.worldY,l=Math.sqrt(i*i+o*o);if(l<this.radius){const e=Zt.interpolation.apply(0,a,(this.radius-l)/this.radius),n=Math.cos(e),s=Math.sin(e);t.x=n*i-s*o+this.worldX,t.y=s*i+n*o+this.worldY}}end(){}};let zt=Zt;zt.interpolation=new r.Ff(2);class Jt{constructor(t,e,n){if(null==t)throw new Error("name cannot be null.");if(null==e)throw new Error("timelines cannot be null.");this.name=t,this.timelines=e,this.duration=n}apply(t,e,n,s,a,r,i,o){if(null==t)throw new Error("skeleton cannot be null.");s&&0!=this.duration&&(n%=this.duration,e>0&&(e%=this.duration));const l=this.timelines;for(let s=0,h=l.length;s<h;s++)l[s].apply(t,e,n,a,r,i,o)}static binarySearch(t,e,n=1){let s=0,a=t.length/n-2;if(0==a)return n;let r=a>>>1;for(;;){if(t[(r+1)*n]<=e?s=r+1:a=r,s==a)return(s+1)*n;r=s+a>>>1}}static linearSearch(t,e,n){for(let s=0,a=t.length-n;s<=a;s+=n)if(t[s]>e)return s;return-1}}var Kt=(t=>(t[t.rotate=0]="rotate",t[t.translate=1]="translate",t[t.scale=2]="scale",t[t.shear=3]="shear",t[t.attachment=4]="attachment",t[t.color=5]="color",t[t.deform=6]="deform",t[t.event=7]="event",t[t.drawOrder=8]="drawOrder",t[t.ikConstraint=9]="ikConstraint",t[t.transformConstraint=10]="transformConstraint",t[t.pathConstraintPosition=11]="pathConstraintPosition",t[t.pathConstraintSpacing=12]="pathConstraintSpacing",t[t.pathConstraintMix=13]="pathConstraintMix",t[t.twoColor=14]="twoColor",t))(Kt||{});const te=class{constructor(t){if(t<=0)throw new Error(`frameCount must be > 0: ${t}`);this.curves=r.Aq.newFloatArray((t-1)*te.BEZIER_SIZE)}getFrameCount(){return this.curves.length/te.BEZIER_SIZE+1}setLinear(t){this.curves[t*te.BEZIER_SIZE]=te.LINEAR}setStepped(t){this.curves[t*te.BEZIER_SIZE]=te.STEPPED}getCurveType(t){const e=t*te.BEZIER_SIZE;if(e==this.curves.length)return te.LINEAR;const n=this.curves[e];return n==te.LINEAR?te.LINEAR:n==te.STEPPED?te.STEPPED:te.BEZIER}setCurve(t,e,n,s,a){const r=.03*(2*-e+s),i=.03*(2*-n+a),o=.006*(3*(e-s)+1),l=.006*(3*(n-a)+1);let h=2*r+o,c=2*i+l,d=.3*e+r+.16666667*o,u=.3*n+i+.16666667*l,m=t*te.BEZIER_SIZE;const f=this.curves;f[m++]=te.BEZIER;let p=d,g=u;for(let t=m+te.BEZIER_SIZE-1;m<t;m+=2)f[m]=p,f[m+1]=g,d+=h,u+=c,h+=o,c+=l,p+=d,g+=u}getCurvePercent(t,e){e=r.cj.clamp(e,0,1);const n=this.curves;let s=t*te.BEZIER_SIZE;const a=n[s];if(a==te.LINEAR)return e;if(a==te.STEPPED)return 0;s++;let i=0;for(let t=s,a=s+te.BEZIER_SIZE-1;s<a;s+=2)if(i=n[s],i>=e){let a,r;return s==t?(a=0,r=0):(a=n[s-2],r=n[s-1]),r+(n[s+1]-r)*(e-a)/(i-a)}const o=n[s-1];return o+(1-o)*(e-i)/(1-i)}};let ee=te;ee.LINEAR=0,ee.STEPPED=1,ee.BEZIER=2,ee.BEZIER_SIZE=19;const ne=class extends ee{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t<<1)}getPropertyId(){return 0+this.boneIndex}setFrame(t,e,n){t<<=1,this.frames[t]=e,this.frames[t+ne.ROTATION]=n}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.bones[this.boneIndex];if(n<l[0]){switch(i){case r.qU.setup:return void(h.rotation=h.data.rotation);case r.qU.first:const t=h.data.rotation-h.rotation;h.rotation+=(t-360*(16384-(16384.499999999996-t/360|0)))*a}return}if(n>=l[l.length-ne.ENTRIES]){let t=l[l.length+ne.PREV_ROTATION];switch(i){case r.qU.setup:h.rotation=h.data.rotation+t*a;break;case r.qU.first:case r.qU.replace:t+=h.data.rotation-h.rotation,t-=360*(16384-(16384.499999999996-t/360|0));case r.qU.add:h.rotation+=t*a}return}const c=Jt.binarySearch(l,n,ne.ENTRIES),d=l[c+ne.PREV_ROTATION],u=l[c],m=this.getCurvePercent((c>>1)-1,1-(n-u)/(l[c+ne.PREV_TIME]-u));let f=l[c+ne.ROTATION]-d;switch(f=d+(f-360*(16384-(16384.499999999996-f/360|0)))*m,i){case r.qU.setup:h.rotation=h.data.rotation+(f-360*(16384-(16384.499999999996-f/360|0)))*a;break;case r.qU.first:case r.qU.replace:f+=h.data.rotation-h.rotation;case r.qU.add:h.rotation+=(f-360*(16384-(16384.499999999996-f/360|0)))*a}}};let se=ne;se.ENTRIES=2,se.PREV_TIME=-2,se.PREV_ROTATION=-1,se.ROTATION=1;const ae=class extends ee{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t*ae.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(t,e,n,s){t*=ae.ENTRIES,this.frames[t]=e,this.frames[t+ae.X]=n,this.frames[t+ae.Y]=s}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.bones[this.boneIndex];if(n<l[0]){switch(i){case r.qU.setup:return h.x=h.data.x,void(h.y=h.data.y);case r.qU.first:h.x+=(h.data.x-h.x)*a,h.y+=(h.data.y-h.y)*a}return}let c=0,d=0;if(n>=l[l.length-ae.ENTRIES])c=l[l.length+ae.PREV_X],d=l[l.length+ae.PREV_Y];else{const t=Jt.binarySearch(l,n,ae.ENTRIES);c=l[t+ae.PREV_X],d=l[t+ae.PREV_Y];const e=l[t],s=this.getCurvePercent(t/ae.ENTRIES-1,1-(n-e)/(l[t+ae.PREV_TIME]-e));c+=(l[t+ae.X]-c)*s,d+=(l[t+ae.Y]-d)*s}switch(i){case r.qU.setup:h.x=h.data.x+c*a,h.y=h.data.y+d*a;break;case r.qU.first:case r.qU.replace:h.x+=(h.data.x+c-h.x)*a,h.y+=(h.data.y+d-h.y)*a;break;case r.qU.add:h.x+=c*a,h.y+=d*a}}};let re=ae;re.ENTRIES=3,re.PREV_TIME=-3,re.PREV_X=-2,re.PREV_Y=-1,re.X=1,re.Y=2;class ie extends re{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.bones[this.boneIndex];if(n<l[0]){switch(i){case r.qU.setup:return h.scaleX=h.data.scaleX,void(h.scaleY=h.data.scaleY);case r.qU.first:h.scaleX+=(h.data.scaleX-h.scaleX)*a,h.scaleY+=(h.data.scaleY-h.scaleY)*a}return}let c=0,d=0;if(n>=l[l.length-ie.ENTRIES])c=l[l.length+ie.PREV_X]*h.data.scaleX,d=l[l.length+ie.PREV_Y]*h.data.scaleY;else{const t=Jt.binarySearch(l,n,ie.ENTRIES);c=l[t+ie.PREV_X],d=l[t+ie.PREV_Y];const e=l[t],s=this.getCurvePercent(t/ie.ENTRIES-1,1-(n-e)/(l[t+ie.PREV_TIME]-e));c=(c+(l[t+ie.X]-c)*s)*h.data.scaleX,d=(d+(l[t+ie.Y]-d)*s)*h.data.scaleY}if(1==a)i==r.qU.add?(h.scaleX+=c-h.data.scaleX,h.scaleY+=d-h.data.scaleY):(h.scaleX=c,h.scaleY=d);else{let t=0,e=0;if(o==r.mj.mixOut)switch(i){case r.qU.setup:t=h.data.scaleX,e=h.data.scaleY,h.scaleX=t+(Math.abs(c)*r.cj.signum(t)-t)*a,h.scaleY=e+(Math.abs(d)*r.cj.signum(e)-e)*a;break;case r.qU.first:case r.qU.replace:t=h.scaleX,e=h.scaleY,h.scaleX=t+(Math.abs(c)*r.cj.signum(t)-t)*a,h.scaleY=e+(Math.abs(d)*r.cj.signum(e)-e)*a;break;case r.qU.add:t=h.scaleX,e=h.scaleY,h.scaleX=t+(Math.abs(c)*r.cj.signum(t)-h.data.scaleX)*a,h.scaleY=e+(Math.abs(d)*r.cj.signum(e)-h.data.scaleY)*a}else switch(i){case r.qU.setup:t=Math.abs(h.data.scaleX)*r.cj.signum(c),e=Math.abs(h.data.scaleY)*r.cj.signum(d),h.scaleX=t+(c-t)*a,h.scaleY=e+(d-e)*a;break;case r.qU.first:case r.qU.replace:t=Math.abs(h.scaleX)*r.cj.signum(c),e=Math.abs(h.scaleY)*r.cj.signum(d),h.scaleX=t+(c-t)*a,h.scaleY=e+(d-e)*a;break;case r.qU.add:t=r.cj.signum(c),e=r.cj.signum(d),h.scaleX=Math.abs(h.scaleX)*t+(c-Math.abs(h.data.scaleX)*t)*a,h.scaleY=Math.abs(h.scaleY)*e+(d-Math.abs(h.data.scaleY)*e)*a}}}}class oe extends re{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.bones[this.boneIndex];if(n<l[0]){switch(i){case r.qU.setup:return h.shearX=h.data.shearX,void(h.shearY=h.data.shearY);case r.qU.first:h.shearX+=(h.data.shearX-h.shearX)*a,h.shearY+=(h.data.shearY-h.shearY)*a}return}let c=0,d=0;if(n>=l[l.length-oe.ENTRIES])c=l[l.length+oe.PREV_X],d=l[l.length+oe.PREV_Y];else{const t=Jt.binarySearch(l,n,oe.ENTRIES);c=l[t+oe.PREV_X],d=l[t+oe.PREV_Y];const e=l[t],s=this.getCurvePercent(t/oe.ENTRIES-1,1-(n-e)/(l[t+oe.PREV_TIME]-e));c+=(l[t+oe.X]-c)*s,d+=(l[t+oe.Y]-d)*s}switch(i){case r.qU.setup:h.shearX=h.data.shearX+c*a,h.shearY=h.data.shearY+d*a;break;case r.qU.first:case r.qU.replace:h.shearX+=(h.data.shearX+c-h.shearX)*a,h.shearY+=(h.data.shearY+d-h.shearY)*a;break;case r.qU.add:h.shearX+=c*a,h.shearY+=d*a}}}const le=class extends ee{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t*le.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(t,e,n,s,a,r){t*=le.ENTRIES,this.frames[t]=e,this.frames[t+le.R]=n,this.frames[t+le.G]=s,this.frames[t+le.B]=a,this.frames[t+le.A]=r}apply(t,e,n,s,a,i,o){const l=t.slots[this.slotIndex],h=this.frames;if(n<h[0]){switch(i){case r.qU.setup:return void l.color.setFromColor(l.data.color);case r.qU.first:const t=l.color,e=l.data.color;t.add((e.r-t.r)*a,(e.g-t.g)*a,(e.b-t.b)*a,(e.a-t.a)*a)}return}let c=0,d=0,u=0,m=0;if(n>=h[h.length-le.ENTRIES]){const t=h.length;c=h[t+le.PREV_R],d=h[t+le.PREV_G],u=h[t+le.PREV_B],m=h[t+le.PREV_A]}else{const t=Jt.binarySearch(h,n,le.ENTRIES);c=h[t+le.PREV_R],d=h[t+le.PREV_G],u=h[t+le.PREV_B],m=h[t+le.PREV_A];const e=h[t],s=this.getCurvePercent(t/le.ENTRIES-1,1-(n-e)/(h[t+le.PREV_TIME]-e));c+=(h[t+le.R]-c)*s,d+=(h[t+le.G]-d)*s,u+=(h[t+le.B]-u)*s,m+=(h[t+le.A]-m)*s}if(1==a)l.color.set(c,d,u,m);else{const t=l.color;i==r.qU.setup&&t.setFromColor(l.data.color),t.add((c-t.r)*a,(d-t.g)*a,(u-t.b)*a,(m-t.a)*a)}}};let he=le;he.ENTRIES=5,he.PREV_TIME=-5,he.PREV_R=-4,he.PREV_G=-3,he.PREV_B=-2,he.PREV_A=-1,he.R=1,he.G=2,he.B=3,he.A=4;const ce=class extends ee{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t*ce.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(t,e,n,s,a,r,i,o,l){t*=ce.ENTRIES,this.frames[t]=e,this.frames[t+ce.R]=n,this.frames[t+ce.G]=s,this.frames[t+ce.B]=a,this.frames[t+ce.A]=r,this.frames[t+ce.R2]=i,this.frames[t+ce.G2]=o,this.frames[t+ce.B2]=l}apply(t,e,n,s,a,i,o){const l=t.slots[this.slotIndex],h=this.frames;if(n<h[0]){switch(i){case r.qU.setup:return l.color.setFromColor(l.data.color),void l.darkColor.setFromColor(l.data.darkColor);case r.qU.first:const t=l.color,e=l.darkColor,n=l.data.color,s=l.data.darkColor;t.add((n.r-t.r)*a,(n.g-t.g)*a,(n.b-t.b)*a,(n.a-t.a)*a),e.add((s.r-e.r)*a,(s.g-e.g)*a,(s.b-e.b)*a,0)}return}let c=0,d=0,u=0,m=0,f=0,p=0,g=0;if(n>=h[h.length-ce.ENTRIES]){const t=h.length;c=h[t+ce.PREV_R],d=h[t+ce.PREV_G],u=h[t+ce.PREV_B],m=h[t+ce.PREV_A],f=h[t+ce.PREV_R2],p=h[t+ce.PREV_G2],g=h[t+ce.PREV_B2]}else{const t=Jt.binarySearch(h,n,ce.ENTRIES);c=h[t+ce.PREV_R],d=h[t+ce.PREV_G],u=h[t+ce.PREV_B],m=h[t+ce.PREV_A],f=h[t+ce.PREV_R2],p=h[t+ce.PREV_G2],g=h[t+ce.PREV_B2];const e=h[t],s=this.getCurvePercent(t/ce.ENTRIES-1,1-(n-e)/(h[t+ce.PREV_TIME]-e));c+=(h[t+ce.R]-c)*s,d+=(h[t+ce.G]-d)*s,u+=(h[t+ce.B]-u)*s,m+=(h[t+ce.A]-m)*s,f+=(h[t+ce.R2]-f)*s,p+=(h[t+ce.G2]-p)*s,g+=(h[t+ce.B2]-g)*s}if(1==a)l.color.set(c,d,u,m),l.darkColor.set(f,p,g,1);else{const t=l.color,e=l.darkColor;i==r.qU.setup&&(t.setFromColor(l.data.color),e.setFromColor(l.data.darkColor)),t.add((c-t.r)*a,(d-t.g)*a,(u-t.b)*a,(m-t.a)*a),e.add((f-e.r)*a,(p-e.g)*a,(g-e.b)*a,0)}}};let de=ce;de.ENTRIES=8,de.PREV_TIME=-8,de.PREV_R=-7,de.PREV_G=-6,de.PREV_B=-5,de.PREV_A=-4,de.PREV_R2=-3,de.PREV_G2=-2,de.PREV_B2=-1,de.R=1,de.G=2,de.B=3,de.A=4,de.R2=5,de.G2=6,de.B2=7;class ue{constructor(t){this.frames=r.Aq.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,e,n){this.frames[t]=e,this.attachmentNames[t]=n}apply(t,e,n,s,a,i,o){const l=t.slots[this.slotIndex];if(o==r.mj.mixOut&&i==r.qU.setup){const e=l.data.attachmentName;return void l.setAttachment(null==e?null:t.getAttachment(this.slotIndex,e))}const h=this.frames;if(n<h[0]){if(i==r.qU.setup||i==r.qU.first){const e=l.data.attachmentName;l.setAttachment(null==e?null:t.getAttachment(this.slotIndex,e))}return}let c=0;c=n>=h[h.length-1]?h.length-1:Jt.binarySearch(h,n,1)-1;const d=this.attachmentNames[c];t.slots[this.slotIndex].setAttachment(null==d?null:t.getAttachment(this.slotIndex,d))}}let me=null;class fe extends ee{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t),this.frameVertices=new Array(t),null==me&&(me=r.Aq.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,e,n){this.frames[t]=e,this.frameVertices[t]=n}apply(t,e,n,s,a,i,o){const l=t.slots[this.slotIndex],h=l.getAttachment();if(!(h instanceof Ot&&h.applyDeform(this.attachment)))return;const c=l.attachmentVertices;0==c.length&&(i=r.qU.setup);const d=this.frameVertices,u=d[0].length,m=this.frames;if(n<m[0]){const t=h;switch(i){case r.qU.setup:return void(c.length=0);case r.qU.first:if(1==a){c.length=0;break}const e=r.Aq.setArraySize(c,u);if(null==t.bones){const n=t.vertices;for(let t=0;t<u;t++)e[t]+=(n[t]-e[t])*a}else{a=1-a;for(let t=0;t<u;t++)e[t]*=a}}return}const f=r.Aq.setArraySize(c,u);if(n>=m[m.length-1]){const t=d[m.length-1];if(1==a)if(i==r.qU.add){const e=h;if(null==e.bones){const n=e.vertices;for(let e=0;e<u;e++)f[e]+=t[e]-n[e]}else for(let e=0;e<u;e++)f[e]+=t[e]}else r.Aq.arrayCopy(t,0,f,0,u);else switch(i){case r.qU.setup:{const e=h;if(null==e.bones){const n=e.vertices;for(let e=0;e<u;e++){const s=n[e];f[e]=s+(t[e]-s)*a}}else for(let e=0;e<u;e++)f[e]=t[e]*a;break}case r.qU.first:case r.qU.replace:for(let e=0;e<u;e++)f[e]+=(t[e]-f[e])*a;case r.qU.add:const e=h;if(null==e.bones){const n=e.vertices;for(let e=0;e<u;e++)f[e]+=(t[e]-n[e])*a}else for(let e=0;e<u;e++)f[e]+=t[e]*a}return}const p=Jt.binarySearch(m,n),g=d[p-1],E=d[p],x=m[p],w=this.getCurvePercent(p-1,1-(n-x)/(m[p-1]-x));if(1==a)if(i==r.qU.add){const t=h;if(null==t.bones){const e=t.vertices;for(let t=0;t<u;t++){const n=g[t];f[t]+=n+(E[t]-n)*w-e[t]}}else for(let t=0;t<u;t++){const e=g[t];f[t]+=e+(E[t]-e)*w}}else for(let t=0;t<u;t++){const e=g[t];f[t]=e+(E[t]-e)*w}else switch(i){case r.qU.setup:{const t=h;if(null==t.bones){const e=t.vertices;for(let t=0;t<u;t++){const n=g[t],s=e[t];f[t]=s+(n+(E[t]-n)*w-s)*a}}else for(let t=0;t<u;t++){const e=g[t];f[t]=(e+(E[t]-e)*w)*a}break}case r.qU.first:case r.qU.replace:for(let t=0;t<u;t++){const e=g[t];f[t]+=(e+(E[t]-e)*w-f[t])*a}break;case r.qU.add:const t=h;if(null==t.bones){const e=t.vertices;for(let t=0;t<u;t++){const n=g[t];f[t]+=(n+(E[t]-n)*w-e[t])*a}}else for(let t=0;t<u;t++){const e=g[t];f[t]+=(e+(E[t]-e)*w)*a}}}}class pe{constructor(t){this.frames=r.Aq.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,n,s,a,r,i){if(null==s)return;const o=this.frames,l=this.frames.length;if(e>n)this.apply(t,e,Number.MAX_VALUE,s,a,r,i),e=-1;else if(e>=o[l-1])return;if(n<o[0])return;let h=0;if(e<o[0])h=0;else{h=Jt.binarySearch(o,e);const t=o[h];for(;h>0&&o[h-1]==t;)h--}for(;h<l&&n>=o[h];h++)s.push(this.events[h])}}class ge{constructor(t){this.frames=r.Aq.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,e,n){this.frames[t]=e,this.drawOrders[t]=n}apply(t,e,n,s,a,i,o){const l=t.drawOrder,h=t.slots;if(o==r.mj.mixOut&&i==r.qU.setup)return void r.Aq.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);const c=this.frames;if(n<c[0])return void(i!=r.qU.setup&&i!=r.qU.first||r.Aq.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length));let d=0;d=n>=c[c.length-1]?c.length-1:Jt.binarySearch(c,n)-1;const u=this.drawOrders[d];if(null==u)r.Aq.arrayCopy(h,0,l,0,h.length);else for(let t=0,e=u.length;t<e;t++)l[t]=h[u[t]]}}const Ee=class extends ee{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t*Ee.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(t,e,n,s,a,r){t*=Ee.ENTRIES,this.frames[t]=e,this.frames[t+Ee.MIX]=n,this.frames[t+Ee.BEND_DIRECTION]=s,this.frames[t+Ee.COMPRESS]=a?1:0,this.frames[t+Ee.STRETCH]=r?1:0}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.ikConstraints[this.ikConstraintIndex];if(n<l[0]){switch(i){case r.qU.setup:return h.mix=h.data.mix,h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,void(h.stretch=h.data.stretch);case r.qU.first:h.mix+=(h.data.mix-h.mix)*a,h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,h.stretch=h.data.stretch}return}if(n>=l[l.length-Ee.ENTRIES])return void(i==r.qU.setup?(h.mix=h.data.mix+(l[l.length+Ee.PREV_MIX]-h.data.mix)*a,o==r.mj.mixOut?(h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,h.stretch=h.data.stretch):(h.bendDirection=l[l.length+Ee.PREV_BEND_DIRECTION],h.compress=0!=l[l.length+Ee.PREV_COMPRESS],h.stretch=0!=l[l.length+Ee.PREV_STRETCH])):(h.mix+=(l[l.length+Ee.PREV_MIX]-h.mix)*a,o==r.mj.mixIn&&(h.bendDirection=l[l.length+Ee.PREV_BEND_DIRECTION],h.compress=0!=l[l.length+Ee.PREV_COMPRESS],h.stretch=0!=l[l.length+Ee.PREV_STRETCH])));const c=Jt.binarySearch(l,n,Ee.ENTRIES),d=l[c+Ee.PREV_MIX],u=l[c],m=this.getCurvePercent(c/Ee.ENTRIES-1,1-(n-u)/(l[c+Ee.PREV_TIME]-u));i==r.qU.setup?(h.mix=h.data.mix+(d+(l[c+Ee.MIX]-d)*m-h.data.mix)*a,o==r.mj.mixOut?(h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,h.stretch=h.data.stretch):(h.bendDirection=l[c+Ee.PREV_BEND_DIRECTION],h.compress=0!=l[c+Ee.PREV_COMPRESS],h.stretch=0!=l[c+Ee.PREV_STRETCH])):(h.mix+=(d+(l[c+Ee.MIX]-d)*m-h.mix)*a,o==r.mj.mixIn&&(h.bendDirection=l[c+Ee.PREV_BEND_DIRECTION],h.compress=0!=l[c+Ee.PREV_COMPRESS],h.stretch=0!=l[c+Ee.PREV_STRETCH]))}};let xe=Ee;xe.ENTRIES=5,xe.PREV_TIME=-5,xe.PREV_MIX=-4,xe.PREV_BEND_DIRECTION=-3,xe.PREV_COMPRESS=-2,xe.PREV_STRETCH=-1,xe.MIX=1,xe.BEND_DIRECTION=2,xe.COMPRESS=3,xe.STRETCH=4;const we=class extends ee{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t*we.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(t,e,n,s,a,r){t*=we.ENTRIES,this.frames[t]=e,this.frames[t+we.ROTATE]=n,this.frames[t+we.TRANSLATE]=s,this.frames[t+we.SCALE]=a,this.frames[t+we.SHEAR]=r}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.transformConstraints[this.transformConstraintIndex];if(n<l[0]){const t=h.data;switch(i){case r.qU.setup:return h.rotateMix=t.rotateMix,h.translateMix=t.translateMix,h.scaleMix=t.scaleMix,void(h.shearMix=t.shearMix);case r.qU.first:h.rotateMix+=(t.rotateMix-h.rotateMix)*a,h.translateMix+=(t.translateMix-h.translateMix)*a,h.scaleMix+=(t.scaleMix-h.scaleMix)*a,h.shearMix+=(t.shearMix-h.shearMix)*a}return}let c=0,d=0,u=0,m=0;if(n>=l[l.length-we.ENTRIES]){const t=l.length;c=l[t+we.PREV_ROTATE],d=l[t+we.PREV_TRANSLATE],u=l[t+we.PREV_SCALE],m=l[t+we.PREV_SHEAR]}else{const t=Jt.binarySearch(l,n,we.ENTRIES);c=l[t+we.PREV_ROTATE],d=l[t+we.PREV_TRANSLATE],u=l[t+we.PREV_SCALE],m=l[t+we.PREV_SHEAR];const e=l[t],s=this.getCurvePercent(t/we.ENTRIES-1,1-(n-e)/(l[t+we.PREV_TIME]-e));c+=(l[t+we.ROTATE]-c)*s,d+=(l[t+we.TRANSLATE]-d)*s,u+=(l[t+we.SCALE]-u)*s,m+=(l[t+we.SHEAR]-m)*s}if(i==r.qU.setup){const t=h.data;h.rotateMix=t.rotateMix+(c-t.rotateMix)*a,h.translateMix=t.translateMix+(d-t.translateMix)*a,h.scaleMix=t.scaleMix+(u-t.scaleMix)*a,h.shearMix=t.shearMix+(m-t.shearMix)*a}else h.rotateMix+=(c-h.rotateMix)*a,h.translateMix+=(d-h.translateMix)*a,h.scaleMix+=(u-h.scaleMix)*a,h.shearMix+=(m-h.shearMix)*a}};let Ae=we;Ae.ENTRIES=5,Ae.PREV_TIME=-5,Ae.PREV_ROTATE=-4,Ae.PREV_TRANSLATE=-3,Ae.PREV_SCALE=-2,Ae.PREV_SHEAR=-1,Ae.ROTATE=1,Ae.TRANSLATE=2,Ae.SCALE=3,Ae.SHEAR=4;const Se=class extends ee{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t*Se.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(t,e,n){t*=Se.ENTRIES,this.frames[t]=e,this.frames[t+Se.VALUE]=n}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.pathConstraints[this.pathConstraintIndex];if(n<l[0]){switch(i){case r.qU.setup:return void(h.position=h.data.position);case r.qU.first:h.position+=(h.data.position-h.position)*a}return}let c=0;if(n>=l[l.length-Se.ENTRIES])c=l[l.length+Se.PREV_VALUE];else{const t=Jt.binarySearch(l,n,Se.ENTRIES);c=l[t+Se.PREV_VALUE];const e=l[t],s=this.getCurvePercent(t/Se.ENTRIES-1,1-(n-e)/(l[t+Se.PREV_TIME]-e));c+=(l[t+Se.VALUE]-c)*s}i==r.qU.setup?h.position=h.data.position+(c-h.data.position)*a:h.position+=(c-h.position)*a}};let be=Se;be.ENTRIES=2,be.PREV_TIME=-2,be.PREV_VALUE=-1,be.VALUE=1;class Me extends be{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.pathConstraints[this.pathConstraintIndex];if(n<l[0]){switch(i){case r.qU.setup:return void(h.spacing=h.data.spacing);case r.qU.first:h.spacing+=(h.data.spacing-h.spacing)*a}return}let c=0;if(n>=l[l.length-Me.ENTRIES])c=l[l.length+Me.PREV_VALUE];else{const t=Jt.binarySearch(l,n,Me.ENTRIES);c=l[t+Me.PREV_VALUE];const e=l[t],s=this.getCurvePercent(t/Me.ENTRIES-1,1-(n-e)/(l[t+Me.PREV_TIME]-e));c+=(l[t+Me.VALUE]-c)*s}i==r.qU.setup?h.spacing=h.data.spacing+(c-h.data.spacing)*a:h.spacing+=(c-h.spacing)*a}}const Te=class extends ee{constructor(t){super(t),this.frames=r.Aq.newFloatArray(t*Te.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(t,e,n,s){t*=Te.ENTRIES,this.frames[t]=e,this.frames[t+Te.ROTATE]=n,this.frames[t+Te.TRANSLATE]=s}apply(t,e,n,s,a,i,o){const l=this.frames,h=t.pathConstraints[this.pathConstraintIndex];if(n<l[0]){switch(i){case r.qU.setup:return h.rotateMix=h.data.rotateMix,void(h.translateMix=h.data.translateMix);case r.qU.first:h.rotateMix+=(h.data.rotateMix-h.rotateMix)*a,h.translateMix+=(h.data.translateMix-h.translateMix)*a}return}let c=0,d=0;if(n>=l[l.length-Te.ENTRIES])c=l[l.length+Te.PREV_ROTATE],d=l[l.length+Te.PREV_TRANSLATE];else{const t=Jt.binarySearch(l,n,Te.ENTRIES);c=l[t+Te.PREV_ROTATE],d=l[t+Te.PREV_TRANSLATE];const e=l[t],s=this.getCurvePercent(t/Te.ENTRIES-1,1-(n-e)/(l[t+Te.PREV_TIME]-e));c+=(l[t+Te.ROTATE]-c)*s,d+=(l[t+Te.TRANSLATE]-d)*s}i==r.qU.setup?(h.rotateMix=h.data.rotateMix+(c-h.data.rotateMix)*a,h.translateMix=h.data.translateMix+(d-h.data.translateMix)*a):(h.rotateMix+=(c-h.rotateMix)*a,h.translateMix+=(d-h.translateMix)*a)}};let Re=Te;Re.ENTRIES=3,Re.PREV_TIME=-3,Re.PREV_ROTATE=-2,Re.PREV_TRANSLATE=-1,Re.ROTATE=1,Re.TRANSLATE=2;const ye=class{constructor(t){this.tracks=new Array,this.events=new Array,this.listeners=new Array,this.queue=new Pe(this),this.propertyIDs=new r.ON,this.animationsChanged=!1,this.timeScale=1,this.trackEntryPool=new r.bC((()=>new Ve)),this.data=t}update(t){t*=this.timeScale;const e=this.tracks;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(null==s)continue;s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast;let a=t*s.timeScale;if(s.delay>0){if(s.delay-=a,s.delay>0)continue;a=-s.delay,s.delay=0}let r=s.next;if(null!=r){const e=s.trackLast-r.delay;if(e>=0){for(r.delay=0,r.trackTime=0==s.timeScale?0:(e/s.timeScale+t)*r.timeScale,s.trackTime+=a,this.setCurrent(n,r,!0);null!=r.mixingFrom;)r.mixTime+=t,r=r.mixingFrom;continue}}else if(s.trackLast>=s.trackEnd&&null==s.mixingFrom){e[n]=null,this.queue.end(s),this.disposeNext(s);continue}if(null!=s.mixingFrom&&this.updateMixingFrom(s,t)){let t=s.mixingFrom;for(s.mixingFrom=null,null!=t&&(t.mixingTo=null);null!=t;)this.queue.end(t),t=t.mixingFrom}s.trackTime+=a}this.queue.drain()}updateMixingFrom(t,e){const n=t.mixingFrom;if(null==n)return!0;const s=this.updateMixingFrom(n,e);return n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?(0!=n.totalAlpha&&0!=t.mixDuration||(t.mixingFrom=n.mixingFrom,null!=n.mixingFrom&&(n.mixingFrom.mixingTo=t),t.interruptAlpha=n.interruptAlpha,this.queue.end(n)),s):(n.trackTime+=e*n.timeScale,t.mixTime+=e,!1)}apply(t){if(null==t)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const e=this.events,n=this.tracks;let s=!1;for(let a=0,i=n.length;a<i;a++){const i=n[a];if(null==i||i.delay>0)continue;s=!0;const o=0==a?r.qU.first:i.mixBlend;let l=i.alpha;null!=i.mixingFrom?l*=this.applyMixingFrom(i,t,o):i.trackTime>=i.trackEnd&&null==i.next&&(l=0);const h=i.animationLast,c=i.getAnimationTime(),d=i.animation.timelines.length,u=i.animation.timelines;if(0==a&&1==l||o==r.qU.add)for(let n=0;n<d;n++)r.Aq.webkit602BugfixHelper(l,o),u[n].apply(t,h,c,e,l,o,r.mj.mixIn);else{const n=i.timelineMode,s=0==i.timelinesRotation.length;s&&r.Aq.setArraySize(i.timelinesRotation,d<<1,null);const a=i.timelinesRotation;for(let i=0;i<d;i++){const d=u[i],m=n[i]==ye.SUBSEQUENT?o:r.qU.setup;d instanceof se?this.applyRotateTimeline(d,t,c,l,m,a,i<<1,s):(r.Aq.webkit602BugfixHelper(l,o),d.apply(t,h,c,e,l,m,r.mj.mixIn))}}this.queueEvents(i,c),e.length=0,i.nextAnimationLast=c,i.nextTrackLast=i.trackTime}return this.queue.drain(),s}applyMixingFrom(t,e,n){const s=t.mixingFrom;null!=s.mixingFrom&&this.applyMixingFrom(s,e,n);let a=0;0==t.mixDuration?(a=1,n==r.qU.first&&(n=r.qU.setup)):(a=t.mixTime/t.mixDuration,a>1&&(a=1),n!=r.qU.first&&(n=s.mixBlend));const i=a<s.eventThreshold?this.events:null,o=a<s.attachmentThreshold,l=a<s.drawOrderThreshold,h=s.animationLast,c=s.getAnimationTime(),d=s.animation.timelines.length,u=s.animation.timelines,m=s.alpha*t.interruptAlpha,f=m*(1-a);if(n==r.qU.add)for(let t=0;t<d;t++)u[t].apply(e,h,c,i,f,n,r.mj.mixOut);else{const t=s.timelineMode,a=s.timelineHoldMix,p=0==s.timelinesRotation.length;p&&r.Aq.setArraySize(s.timelinesRotation,d<<1,null);const g=s.timelinesRotation;s.totalAlpha=0;for(let E=0;E<d;E++){const d=u[E];let x,w=r.mj.mixOut,A=0;switch(t[E]){case ye.SUBSEQUENT:if(!o&&d instanceof ue)continue;if(!l&&d instanceof ge)continue;x=n,A=f;break;case ye.FIRST:x=r.qU.setup,A=f;break;case ye.HOLD:x=r.qU.setup,A=m;break;default:x=r.qU.setup;const t=a[E];A=m*Math.max(0,1-t.mixTime/t.mixDuration)}s.totalAlpha+=A,d instanceof se?this.applyRotateTimeline(d,e,c,A,x,g,E<<1,p):(r.Aq.webkit602BugfixHelper(A,n),x==r.qU.setup&&(d instanceof ue?o&&(w=r.mj.mixOut):d instanceof ge&&l&&(w=r.mj.mixOut)),d.apply(e,h,c,i,A,x,w))}}return t.mixDuration>0&&this.queueEvents(s,c),this.events.length=0,s.nextAnimationLast=c,s.nextTrackLast=s.trackTime,a}applyRotateTimeline(t,e,n,s,a,i,o,l){if(l&&(i[o]=0),1==s)return void t.apply(e,0,n,null,1,a,r.mj.mixIn);const h=t,c=h.frames,d=e.bones[h.boneIndex];let u=0,m=0;if(n<c[0])switch(a){case r.qU.setup:d.rotation=d.data.rotation;default:return;case r.qU.first:u=d.rotation,m=d.data.rotation}else if(u=a==r.qU.setup?d.data.rotation:d.rotation,n>=c[c.length-se.ENTRIES])m=d.data.rotation+c[c.length+se.PREV_ROTATION];else{const t=Jt.binarySearch(c,n,se.ENTRIES),e=c[t+se.PREV_ROTATION],s=c[t],a=h.getCurvePercent((t>>1)-1,1-(n-s)/(c[t+se.PREV_TIME]-s));m=c[t+se.ROTATION]-e,m-=360*(16384-(16384.499999999996-m/360|0)),m=e+m*a+d.data.rotation,m-=360*(16384-(16384.499999999996-m/360|0))}let f=0,p=m-u;if(p-=360*(16384-(16384.499999999996-p/360|0)),0==p)f=i[o];else{let t=0,e=0;l?(t=0,e=p):(t=i[o],e=i[o+1]);const n=p>0;let s=t>=0;r.cj.signum(e)!=r.cj.signum(p)&&Math.abs(e)<=90&&(Math.abs(t)>180&&(t+=360*r.cj.signum(t)),s=n),f=p+t-t%360,s!=n&&(f+=360*r.cj.signum(t)),i[o]=f}i[o+1]=p,u+=f*s,d.rotation=u-360*(16384-(16384.499999999996-u/360|0))}queueEvents(t,e){const n=t.animationStart,s=t.animationEnd,a=s-n,r=t.trackLast%a,i=this.events;let o=0;const l=i.length;for(;o<l;o++){const e=i[o];if(e.time<r)break;e.time>s||this.queue.event(t,e)}let h=!1;for(h=t.loop?0==a||r>t.trackTime%a:e>=s&&t.animationLast<s,h&&this.queue.complete(t);o<l;o++)i[o].time<n||this.queue.event(t,i[o])}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,e=this.tracks.length;t<e;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const e=this.tracks[t];if(null==e)return;this.queue.end(e),this.disposeNext(e);let n=e;for(;;){const t=n.mixingFrom;if(null==t)break;this.queue.end(t),n.mixingFrom=null,n.mixingTo=null,n=t}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,n){const s=this.expandToIndex(t);this.tracks[t]=e,null!=s&&(n&&this.queue.interrupt(s),e.mixingFrom=s,s.mixingTo=e,e.mixTime=0,null!=s.mixingFrom&&s.mixDuration>0&&(e.interruptAlpha*=Math.min(1,s.mixTime/s.mixDuration)),s.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,n){const s=this.data.skeletonData.findAnimation(e);if(null==s)throw new Error(`Animation not found: ${e}`);return this.setAnimationWith(t,s,n)}setAnimationWith(t,e,n){if(null==e)throw new Error("animation cannot be null.");let s=!0,a=this.expandToIndex(t);null!=a&&(-1==a.nextTrackLast?(this.tracks[t]=a.mixingFrom,this.queue.interrupt(a),this.queue.end(a),this.disposeNext(a),a=a.mixingFrom,s=!1):this.disposeNext(a));const r=this.trackEntry(t,e,n,a);return this.setCurrent(t,r,s),this.queue.drain(),r}addAnimation(t,e,n,s){const a=this.data.skeletonData.findAnimation(e);if(null==a)throw new Error(`Animation not found: ${e}`);return this.addAnimationWith(t,a,n,s)}addAnimationWith(t,e,n,s){if(null==e)throw new Error("animation cannot be null.");let a=this.expandToIndex(t);if(null!=a)for(;null!=a.next;)a=a.next;const r=this.trackEntry(t,e,n,a);if(null==a)this.setCurrent(t,r,!0),this.queue.drain();else if(a.next=r,s<=0){const t=a.animationEnd-a.animationStart;0!=t?(a.loop?s+=t*(1+(a.trackTime/t|0)):s+=Math.max(t,a.trackTime),s-=this.data.getMix(a.animation,e)):s=a.trackTime}return r.delay=s,r}setEmptyAnimation(t,e){const n=this.setAnimationWith(t,ye.emptyAnimation,!1);return n.mixDuration=e,n.trackEnd=e,n}addEmptyAnimation(t,e,n){n<=0&&(n-=e);const s=this.addAnimationWith(t,ye.emptyAnimation,!1,n);return s.mixDuration=e,s.trackEnd=e,s}setEmptyAnimations(t){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,n=this.tracks.length;e<n;e++){const n=this.tracks[e];null!=n&&this.setEmptyAnimation(n.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(r.Aq.ensureArrayCapacity(this.tracks,t-this.tracks.length+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,n,s){const a=this.trackEntryPool.obtain();return a.trackIndex=t,a.animation=e,a.loop=n,a.holdPrevious=!1,a.eventThreshold=0,a.attachmentThreshold=0,a.drawOrderThreshold=0,a.animationStart=0,a.animationEnd=e.duration,a.animationLast=-1,a.nextAnimationLast=-1,a.delay=0,a.trackTime=0,a.trackLast=-1,a.nextTrackLast=-1,a.trackEnd=Number.MAX_VALUE,a.timeScale=1,a.alpha=1,a.interruptAlpha=1,a.mixTime=0,a.mixDuration=null==s?0:this.data.getMix(s.animation,e),a}disposeNext(t){let e=t.next;for(;null!=e;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let t=0,e=this.tracks.length;t<e;t++){let e=this.tracks[t];if(null!=e){for(;null!=e.mixingFrom;)e=e.mixingFrom;do{null!=e.mixingFrom&&e.mixBlend==r.qU.add||this.setTimelineModes(e),e=e.mixingTo}while(null!=e)}}}setTimelineModes(t){const e=t.mixingTo,n=t.animation.timelines,s=t.animation.timelines.length,a=r.Aq.setArraySize(t.timelineMode,s);t.timelineHoldMix.length=0;const i=r.Aq.setArraySize(t.timelineHoldMix,s),o=this.propertyIDs;if(null!=e&&e.holdPrevious)for(let t=0;t<s;t++)o.add(n[t].getPropertyId()),a[t]=ye.HOLD;else t:for(let r=0;r<s;r++){const s=n[r].getPropertyId();if(o.add(s))if(null!=e&&this.hasTimeline(e,s)){for(let n=e.mixingTo;null!=n;n=n.mixingTo)if(!this.hasTimeline(n,s)){if(t.mixDuration>0){a[r]=ye.HOLD_MIX,i[r]=n;continue t}break}a[r]=ye.HOLD}else a[r]=ye.FIRST;else a[r]=ye.SUBSEQUENT}}hasTimeline(t,e){const n=t.animation.timelines;for(let t=0,s=n.length;t<s;t++)if(n[t].getPropertyId()==e)return!0;return!1}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(null==t)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,e,n){ye.deprecatedWarning1||(ye.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,e,n)}addAnimationByName(t,e,n,s){ye.deprecatedWarning2||(ye.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,e,n,s)}hasAnimation(t){return null!==this.data.skeletonData.findAnimation(t)}hasAnimationByName(t){return ye.deprecatedWarning3||(ye.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};let Ie=ye;Ie.emptyAnimation=new Jt("<empty>",[],0),Ie.SUBSEQUENT=0,Ie.FIRST=1,Ie.HOLD=2,Ie.HOLD_MIX=3,Ie.deprecatedWarning1=!1,Ie.deprecatedWarning2=!1,Ie.deprecatedWarning3=!1;const Ce=class{constructor(){this.mixBlend=r.qU.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return 0==t?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return Ce.deprecatedWarning1||(Ce.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){Ce.deprecatedWarning1||(Ce.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return Ce.deprecatedWarning2||(Ce.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){Ce.deprecatedWarning2||(Ce.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Ve=Ce;Ve.deprecatedWarning1=!1,Ve.deprecatedWarning2=!1;const ke=class{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=t}start(t){this.objects.push(Ne.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(Ne.interrupt),this.objects.push(t)}end(t){this.objects.push(Ne.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(Ne.dispose),this.objects.push(t)}complete(t){this.objects.push(Ne.complete),this.objects.push(t)}event(t,e){this.objects.push(Ne.event),this.objects.push(t),this.objects.push(e)}deprecateStuff(){return ke.deprecatedWarning1||(ke.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,e=this.animState.listeners;for(let n=0;n<t.length;n+=2){const s=t[n],a=t[n+1];switch(s){case Ne.start:null!=a.listener&&a.listener.start&&a.listener.start(a);for(let t=0;t<e.length;t++)e[t].start&&e[t].start(a);a.onStart&&this.deprecateStuff()&&a.onStart(a.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(a.trackIndex);break;case Ne.interrupt:null!=a.listener&&a.listener.interrupt&&a.listener.interrupt(a);for(let t=0;t<e.length;t++)e[t].interrupt&&e[t].interrupt(a);break;case Ne.end:null!=a.listener&&a.listener.end&&a.listener.end(a);for(let t=0;t<e.length;t++)e[t].end&&e[t].end(a);a.onEnd&&this.deprecateStuff()&&a.onEnd(a.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(a.trackIndex);case Ne.dispose:null!=a.listener&&a.listener.dispose&&a.listener.dispose(a);for(let t=0;t<e.length;t++)e[t].dispose&&e[t].dispose(a);this.animState.trackEntryPool.free(a);break;case Ne.complete:null!=a.listener&&a.listener.complete&&a.listener.complete(a);for(let t=0;t<e.length;t++)e[t].complete&&e[t].complete(a);const s=r.cj.toInt(a.loopsCount());a.onComplete&&this.deprecateStuff()&&a.onComplete(a.trackIndex,s),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(a.trackIndex,s);break;case Ne.event:const i=t[2+n++];null!=a.listener&&a.listener.event&&a.listener.event(a,i);for(let t=0;t<e.length;t++)e[t].event&&e[t].event(a,i);a.onEvent&&this.deprecateStuff()&&a.onEvent(a.trackIndex,i),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(a.trackIndex,i)}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let Pe=ke;Pe.deprecatedWarning1=!1;var Ne=(t=>(t[t.start=0]="start",t[t.interrupt=1]="interrupt",t[t.end=2]="end",t[t.dispose=3]="dispose",t[t.complete=4]="complete",t[t.event=5]="event",t))(Ne||{});class ve{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}}const qe=class{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,null==t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,n){const s=this.skeletonData.findAnimation(t);if(null==s)throw new Error(`Animation not found: ${t}`);const a=this.skeletonData.findAnimation(e);if(null==a)throw new Error(`Animation not found: ${e}`);this.setMixWith(s,a,n)}setMixByName(t,e,n){qe.deprecatedWarning1||(qe.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(t,e,n)}setMixWith(t,e,n){if(null==t)throw new Error("from cannot be null.");if(null==e)throw new Error("to cannot be null.");const s=`${t.name}.${e.name}`;this.animationToMixTime[s]=n}getMix(t,e){const n=`${t.name}.${e.name}`,s=this.animationToMixTime[n];return void 0===s?this.defaultMix:s}};let Fe=qe;Fe.deprecatedWarning1=!1;class _e{constructor(t){this.atlas=t}newRegionAttachment(t,e,n){const s=this.atlas.findRegion(n);if(null==s)throw new Error(`Region not found in atlas: ${n} (region attachment: ${e})`);const a=new Qt(e);return a.region=s,a}newMeshAttachment(t,e,n){const s=this.atlas.findRegion(n);if(null==s)throw new Error(`Region not found in atlas: ${n} (mesh attachment: ${e})`);const a=new Ut(e);return a.region=s,a}newBoundingBoxAttachment(t,e){return new Bt(e)}newPathAttachment(t,e){return new jt(e)}newPointAttachment(t,e){return new Wt(e)}newClippingAttachment(t,e){return new Lt(e)}}class De{constructor(t,e,n){if(this.matrix=new o.uq,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!0,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=n,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,n,s,a,i,o){this.ax=t,this.ay=e,this.arotation=n,this.ascaleX=s,this.ascaleY=a,this.ashearX=i,this.ashearY=o,this.appliedValid=!0;const l=this.parent,h=this.matrix,c=this.skeleton.scaleX,d=r.W0.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(null==l){const l=this.skeleton,u=n+90+o;return h.a=r.cj.cosDeg(n+i)*s*c,h.c=r.cj.cosDeg(u)*a*c,h.b=r.cj.sinDeg(n+i)*s*d,h.d=r.cj.sinDeg(u)*a*d,h.tx=t*c+l.x,void(h.ty=e*d+l.y)}let u=l.matrix.a,m=l.matrix.c,f=l.matrix.b,p=l.matrix.d;switch(h.tx=u*t+m*e+l.matrix.tx,h.ty=f*t+p*e+l.matrix.ty,this.data.transformMode){case r._C.Normal:{const t=n+90+o,e=r.cj.cosDeg(n+i)*s,l=r.cj.cosDeg(t)*a,c=r.cj.sinDeg(n+i)*s,d=r.cj.sinDeg(t)*a;return h.a=u*e+m*c,h.c=u*l+m*d,h.b=f*e+p*c,void(h.d=f*l+p*d)}case r._C.OnlyTranslation:{const t=n+90+o;h.a=r.cj.cosDeg(n+i)*s,h.c=r.cj.cosDeg(t)*a,h.b=r.cj.sinDeg(n+i)*s,h.d=r.cj.sinDeg(t)*a;break}case r._C.NoRotationOrReflection:{let t=u*u+f*f,e=0;t>1e-4?(t=Math.abs(u*p-m*f)/t,m=f*t,p=u*t,e=Math.atan2(f,u)*r.cj.radDeg):(u=0,f=0,e=90-Math.atan2(p,m)*r.cj.radDeg);const l=n+i-e,c=n+o-e+90,d=r.cj.cosDeg(l)*s,g=r.cj.cosDeg(c)*a,E=r.cj.sinDeg(l)*s,x=r.cj.sinDeg(c)*a;h.a=u*d-m*E,h.c=u*g-m*x,h.b=f*d+p*E,h.d=f*g+p*x;break}case r._C.NoScale:case r._C.NoScaleOrReflection:{const t=r.cj.cosDeg(n),e=r.cj.sinDeg(n);let l=(u*t+m*e)/c,g=(f*t+p*e)/d,E=Math.sqrt(l*l+g*g);E>1e-5&&(E=1/E),l*=E,g*=E,E=Math.sqrt(l*l+g*g),this.data.transformMode==r._C.NoScale&&u*p-m*f<0!=(r.W0.yDown?this.skeleton.scaleX<0!=this.skeleton.scaleY>0:this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(E=-E);const x=Math.PI/2+Math.atan2(g,l),w=Math.cos(x)*E,A=Math.sin(x)*E,S=r.cj.cosDeg(i)*s,b=r.cj.cosDeg(90+o)*a,M=r.cj.sinDeg(i)*s,T=r.cj.sinDeg(90+o)*a;h.a=l*S+w*M,h.c=l*b+w*T,h.b=g*S+A*M,h.d=g*b+A*T;break}}h.a*=c,h.c*=c,h.b*=d,h.d*=d}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*r.cj.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*r.cj.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,e=this.matrix;if(null==t)return this.ax=e.tx,this.ay=e.ty,this.arotation=Math.atan2(e.b,e.a)*r.cj.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,void(this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*r.cj.radDeg);const n=t.matrix,s=1/(n.a*n.d-n.b*n.c),a=e.tx-n.tx,i=e.ty-n.ty;this.ax=a*n.d*s-i*n.c*s,this.ay=i*n.a*s-a*n.b*s;const o=s*n.d,l=s*n.a,h=s*n.c,c=s*n.b,d=o*e.a-h*e.b,u=o*e.c-h*e.d,m=l*e.b-c*e.a,f=l*e.d-c*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(d*d+m*m),this.ascaleX>1e-4){const t=d*f-u*m;this.ascaleY=t/this.ascaleX,this.ashearY=Math.atan2(d*u+m*f,t)*r.cj.radDeg,this.arotation=Math.atan2(m,d)*r.cj.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(u*u+f*f),this.ashearY=0,this.arotation=90-Math.atan2(f,u)*r.cj.radDeg}worldToLocal(t){const e=this.matrix,n=e.a,s=e.c,a=e.b,r=e.d,i=1/(n*r-s*a),o=t.x-e.tx,l=t.y-e.ty;return t.x=o*r*i-l*s*i,t.y=l*n*i-o*a*i,t}localToWorld(t){const e=this.matrix,n=t.x,s=t.y;return t.x=n*e.a+s*e.c+e.tx,t.y=n*e.b+s*e.d+e.ty,t}worldToLocalRotation(t){const e=r.cj.sinDeg(t),n=r.cj.cosDeg(t),s=this.matrix;return Math.atan2(s.a*e-s.b*n,s.d*n-s.c*e)*r.cj.radDeg}localToWorldRotation(t){const e=r.cj.sinDeg(t),n=r.cj.cosDeg(t),s=this.matrix;return Math.atan2(n*s.b+e*s.d,n*s.a+e*s.c)*r.cj.radDeg}rotateWorld(t){const e=this.matrix,n=e.a,s=e.c,a=e.b,i=e.d,o=r.cj.cosDeg(t),l=r.cj.sinDeg(t);e.a=o*n-l*a,e.c=o*s-l*i,e.b=l*n+o*a,e.d=l*s+o*i,this.appliedValid=!1}}class Xe{constructor(t,e,n){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=r._C.Normal,t<0)throw new Error("index must be >= 0.");if(null==e)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=n}}class Ye{constructor(t,e){if(null==e)throw new Error("data cannot be null.");this.time=t,this.data=e}}class Oe{constructor(t){this.name=t}}class Be{constructor(t,e){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findBone(t.target.name)}getOrder(){return this.data.order}apply(){this.update()}update(){const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.mix)}}apply1(t,e,n,s,a,i,o){t.appliedValid||t.updateAppliedTransform();const l=t.parent.matrix,h=1/(l.a*l.d-l.b*l.c),c=e-l.tx,d=n-l.ty,u=(c*l.d-d*l.c)*h-t.ax,m=(d*l.a-c*l.b)*h-t.ay;let f=Math.atan2(m,u)*r.cj.radDeg-t.ashearX-t.arotation;t.ascaleX<0&&(f+=180),f>180?f-=360:f<-180&&(f+=360);let p=t.ascaleX,g=t.ascaleY;if(s||a){const e=t.data.length*p,n=Math.sqrt(u*u+m*m);if(s&&n<e||a&&n>e&&e>1e-4){const t=(n/e-1)*o+1;p*=t,i&&(g*=t)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+f*o,p,g,t.ashearX,t.ashearY)}apply2(t,e,n,s,a,i,o){if(0==o)return void e.updateWorldTransform();t.appliedValid||t.updateAppliedTransform(),e.appliedValid||e.updateAppliedTransform();const l=t.ax,h=t.ay;let c=t.ascaleX,d=c,u=t.ascaleY,m=e.ascaleX;const f=t.matrix;let p=0,g=0,E=0;c<0?(c=-c,p=180,E=-1):(p=0,E=1),u<0&&(u=-u,E=-E),m<0?(m=-m,g=180):g=0;const x=e.ax;let w=0,A=0,S=0,b=f.a,M=f.c,T=f.b,R=f.d;const y=Math.abs(c-u)<=1e-4;y?(w=e.ay,A=b*x+M*w+f.tx,S=T*x+R*w+f.ty):(w=0,A=b*x+f.tx,S=T*x+f.ty);const I=t.parent.matrix;b=I.a,M=I.c,T=I.b,R=I.d;const C=1/(b*R-M*T);let V=n-I.tx,k=s-I.ty;const P=(V*R-k*M)*C-l,N=(k*b-V*T)*C-h,v=P*P+N*N;V=A-I.tx,k=S-I.ty;const q=(V*R-k*M)*C-l,F=(k*b-V*T)*C-h,_=Math.sqrt(q*q+F*F);let D=e.data.length*m,X=0,Y=0;t:if(y){D*=c;let t=(v-_*_-D*D)/(2*_*D);t<-1?t=-1:t>1&&(t=1,i&&_+D>1e-4&&(d*=(Math.sqrt(v)/(_+D)-1)*o+1)),Y=Math.acos(t)*a,b=_+D*t,M=D*Math.sin(Y),X=Math.atan2(N*b-P*M,P*b+N*M)}else{b=c*D,M=u*D;const t=b*b,e=M*M,n=Math.atan2(N,P);T=e*_*_+t*v-t*e;const s=-2*e*_,i=e-t;if(R=s*s-4*i*T,R>=0){let t=Math.sqrt(R);s<0&&(t=-t),t=-(s+t)/2;const e=t/i,r=T/t,o=Math.abs(e)<Math.abs(r)?e:r;if(o*o<=v){k=Math.sqrt(v-o*o)*a,X=n-Math.atan2(k,o),Y=Math.atan2(k/u,(o-_)/c);break t}}let o=r.cj.PI,l=_-b,h=l*l,d=0,m=0,f=_+b,p=f*f,g=0;T=-b*_/(t-e),T>=-1&&T<=1&&(T=Math.acos(T),V=b*Math.cos(T)+_,k=M*Math.sin(T),R=V*V+k*k,R<h&&(o=T,h=R,l=V,d=k),R>p&&(m=T,p=R,f=V,g=k)),v<=(h+p)/2?(X=n-Math.atan2(d*a,l),Y=o*a):(X=n-Math.atan2(g*a,f),Y=m*a)}const O=Math.atan2(w,x)*E;let B=t.arotation;X=(X-O)*r.cj.radDeg+p-B,X>180?X-=360:X<-180&&(X+=360),t.updateWorldTransformWith(l,h,B+X*o,d,t.ascaleY,0,0),B=e.arotation,Y=((Y+O)*r.cj.radDeg-e.ashearX)*E+g-B,Y>180?Y-=360:Y<-180&&(Y+=360),e.updateWorldTransformWith(x,w,B+Y*o,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}}class Le{constructor(t){this.order=0,this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.name=t}}class Ue{constructor(t){this.order=0,this.bones=new Array,this.name=t}}var je=(t=>(t[t.Length=0]="Length",t[t.Fixed=1]="Fixed",t[t.Percent=2]="Percent",t))(je||{});const We=class{constructor(t,e){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let n=0,s=t.bones.length;n<s;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findSlot(t.target.name),this.position=t.position,this.spacing=t.spacing,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix}apply(){this.update()}update(){const t=this.target.getAttachment();if(!(t instanceof jt))return;const e=this.rotateMix,n=this.translateMix,s=e>0;if(!(n>0||s))return;const a=this.data,i=a.spacingMode,o=i==je.Length,l=a.rotateMode,h=l==r.Dr.Tangent,c=l==r.Dr.ChainScale,d=this.bones.length,u=h?d:d+1,m=this.bones,f=r.Aq.setArraySize(this.spaces,u);let p=null;const g=this.spacing;if(c||o){c&&(p=r.Aq.setArraySize(this.lengths,d));for(let t=0,e=u-1;t<e;){const e=m[t],n=e.data.length;if(n<We.epsilon)c&&(p[t]=0),f[++t]=0;else{const s=n*e.matrix.a,a=n*e.matrix.b,r=Math.sqrt(s*s+a*a);c&&(p[t]=r),f[++t]=(o?n+g:g)*r/n}}}else for(let t=1;t<u;t++)f[t]=g;const E=this.computeWorldPositions(t,u,h,a.positionMode==r.pw.Percent,i==je.Percent);let x=E[0],w=E[1],A=a.offsetRotation,S=!1;if(0==A)S=l==r.Dr.Chain;else{S=!1;const t=this.target.bone.matrix;A*=t.a*t.d-t.b*t.c>0?r.cj.degRad:-r.cj.degRad}for(let t=0,a=3;t<d;t++,a+=3){const i=m[t],o=i.matrix;o.tx+=(x-o.tx)*n,o.ty+=(w-o.ty)*n;const l=E[a],d=E[a+1],u=l-x,g=d-w;if(c){const n=p[t];if(0!=n){const t=(Math.sqrt(u*u+g*g)/n-1)*e+1;o.a*=t,o.b*=t}}if(x=l,w=d,s){const n=o.a,s=o.c,l=o.b,c=o.d;let d=0,m=0,p=0;if(h&&(d=h?E[a-1]:0==f[t+1]?E[a+2]:Math.atan2(g,u)),d-=Math.atan2(l,n),S){m=Math.cos(d),p=Math.sin(d);const t=i.data.length;x+=(t*(m*n-p*l)-u)*e,w+=(t*(p*n+m*l)-g)*e}else d+=A;d>r.cj.PI?d-=r.cj.PI2:d<-r.cj.PI&&(d+=r.cj.PI2),d*=e,m=Math.cos(d),p=Math.sin(d),o.a=m*n-p*l,o.c=m*s-p*c,o.b=p*n+m*l,o.d=p*s+m*c}i.appliedValid=!1}}computeWorldPositions(t,e,n,s,a){const i=this.target;let o=this.position;const l=this.spaces,h=r.Aq.setArraySize(this.positions,3*e+2);let c=null;const d=t.closed;let u=t.worldVerticesLength,m=u/6,f=We.NONE;if(!t.constantSpeed){const p=t.lengths;m-=d?1:2;const g=p[m];if(s&&(o*=g),a)for(let t=0;t<e;t++)l[t]*=g;c=r.Aq.setArraySize(this.world,8);for(let s=0,a=0,r=0;s<e;s++,a+=3){const e=l[s];o+=e;let E=o;if(d)E%=g,E<0&&(E+=g),r=0;else{if(E<0){f!=We.BEFORE&&(f=We.BEFORE,t.computeWorldVertices(i,2,4,c,0,2)),this.addBeforePosition(E,c,0,h,a);continue}if(E>g){f!=We.AFTER&&(f=We.AFTER,t.computeWorldVertices(i,u-6,4,c,0,2)),this.addAfterPosition(E-g,c,0,h,a);continue}}for(;;r++){const t=p[r];if(!(E>t)){if(0==r)E/=t;else{const e=p[r-1];E=(E-e)/(t-e)}break}}r!=f&&(f=r,d&&r==m?(t.computeWorldVertices(i,u-4,4,c,0,2),t.computeWorldVertices(i,0,4,c,4,2)):t.computeWorldVertices(i,6*r+2,8,c,0,2)),this.addCurvePosition(E,c[0],c[1],c[2],c[3],c[4],c[5],c[6],c[7],h,a,n||s>0&&0==e)}return h}d?(u+=2,c=r.Aq.setArraySize(this.world,u),t.computeWorldVertices(i,2,u-4,c,0,2),t.computeWorldVertices(i,0,2,c,u-4,2),c[u-2]=c[0],c[u-1]=c[1]):(m--,u-=4,c=r.Aq.setArraySize(this.world,u),t.computeWorldVertices(i,2,u,c,0,2));const p=r.Aq.setArraySize(this.curves,m);let g=0,E=c[0],x=c[1],w=0,A=0,S=0,b=0,M=0,T=0,R=0,y=0,I=0,C=0,V=0,k=0,P=0,N=0;for(let t=0,e=2;t<m;t++,e+=6)w=c[e],A=c[e+1],S=c[e+2],b=c[e+3],M=c[e+4],T=c[e+5],R=.1875*(E-2*w+S),y=.1875*(x-2*A+b),I=.09375*(3*(w-S)-E+M),C=.09375*(3*(A-b)-x+T),V=2*R+I,k=2*y+C,P=.75*(w-E)+R+.16666667*I,N=.75*(A-x)+y+.16666667*C,g+=Math.sqrt(P*P+N*N),P+=V,N+=k,V+=I,k+=C,g+=Math.sqrt(P*P+N*N),P+=V,N+=k,g+=Math.sqrt(P*P+N*N),P+=V+I,N+=k+C,g+=Math.sqrt(P*P+N*N),p[t]=g,E=M,x=T;if(s&&(o*=g),a)for(let t=0;t<e;t++)l[t]*=g;const v=this.segments;let q=0;for(let t=0,s=0,a=0,r=0;t<e;t++,s+=3){const e=l[t];o+=e;let i=o;if(d)i%=g,i<0&&(i+=g),a=0;else{if(i<0){this.addBeforePosition(i,c,0,h,s);continue}if(i>g){this.addAfterPosition(i-g,c,u-4,h,s);continue}}for(;;a++){const t=p[a];if(!(i>t)){if(0==a)i/=t;else{const e=p[a-1];i=(i-e)/(t-e)}break}}if(a!=f){f=a;let t=6*a;for(E=c[t],x=c[t+1],w=c[t+2],A=c[t+3],S=c[t+4],b=c[t+5],M=c[t+6],T=c[t+7],R=.03*(E-2*w+S),y=.03*(x-2*A+b),I=.006*(3*(w-S)-E+M),C=.006*(3*(A-b)-x+T),V=2*R+I,k=2*y+C,P=.3*(w-E)+R+.16666667*I,N=.3*(A-x)+y+.16666667*C,q=Math.sqrt(P*P+N*N),v[0]=q,t=1;t<8;t++)P+=V,N+=k,V+=I,k+=C,q+=Math.sqrt(P*P+N*N),v[t]=q;P+=V,N+=k,q+=Math.sqrt(P*P+N*N),v[8]=q,P+=V+I,N+=k+C,q+=Math.sqrt(P*P+N*N),v[9]=q,r=0}for(i*=q;;r++){const t=v[r];if(!(i>t)){if(0==r)i/=t;else{const e=v[r-1];i=r+(i-e)/(t-e)}break}}this.addCurvePosition(.1*i,E,x,w,A,S,b,M,T,h,s,n||t>0&&0==e)}return h}addBeforePosition(t,e,n,s,a){const r=e[n],i=e[n+1],o=e[n+2]-r,l=e[n+3]-i,h=Math.atan2(l,o);s[a]=r+t*Math.cos(h),s[a+1]=i+t*Math.sin(h),s[a+2]=h}addAfterPosition(t,e,n,s,a){const r=e[n+2],i=e[n+3],o=r-e[n],l=i-e[n+1],h=Math.atan2(l,o);s[a]=r+t*Math.cos(h),s[a+1]=i+t*Math.sin(h),s[a+2]=h}addCurvePosition(t,e,n,s,a,r,i,o,l,h,c,d){(0==t||isNaN(t))&&(t=1e-4);const u=t*t,m=u*t,f=1-t,p=f*f,g=p*f,E=f*t,x=3*E,w=f*x,A=x*t,S=e*g+s*w+r*A+o*m,b=n*g+a*w+i*A+l*m;h[c]=S,h[c+1]=b,d&&(h[c+2]=Math.atan2(b-(n*p+a*E*2+i*u),S-(e*p+s*E*2+r*u)))}getOrder(){return this.data.order}};let $e=We;$e.NONE=-1,$e.BEFORE=-2,$e.AFTER=-3,$e.epsilon=1e-5;class He{constructor(t,e){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new r.I9,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findBone(t.target.name)}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,e=this.translateMix,n=this.scaleMix,s=this.shearMix,a=this.target,i=a.matrix,o=i.a,l=i.c,h=i.b,c=i.d,d=o*c-l*h>0?r.cj.degRad:-r.cj.degRad,u=this.data.offsetRotation*d,m=this.data.offsetShearY*d,f=this.bones;for(let i=0,d=f.length;i<d;i++){const d=f[i];let p=!1;const g=d.matrix;if(0!=t){const e=g.a,n=g.c,s=g.b,a=g.d;let i=Math.atan2(h,o)-Math.atan2(s,e)+u;i>r.cj.PI?i-=r.cj.PI2:i<-r.cj.PI&&(i+=r.cj.PI2),i*=t;const l=Math.cos(i),c=Math.sin(i);g.a=l*e-c*s,g.c=l*n-c*a,g.b=c*e+l*s,g.d=c*n+l*a,p=!0}if(0!=e){const t=this.temp;a.localToWorld(t.set(this.data.offsetX,this.data.offsetY)),g.tx+=(t.x-g.tx)*e,g.ty+=(t.y-g.ty)*e,p=!0}if(n>0){let t=Math.sqrt(g.a*g.a+g.b*g.b),e=Math.sqrt(o*o+h*h);t>1e-5&&(t=(t+(e-t+this.data.offsetScaleX)*n)/t),g.a*=t,g.b*=t,t=Math.sqrt(g.c*g.c+g.d*g.d),e=Math.sqrt(l*l+c*c),t>1e-5&&(t=(t+(e-t+this.data.offsetScaleY)*n)/t),g.c*=t,g.d*=t,p=!0}if(s>0){const t=g.c,e=g.d,n=Math.atan2(e,t);let a=Math.atan2(c,l)-Math.atan2(h,o)-(n-Math.atan2(g.b,g.a));a>r.cj.PI?a-=r.cj.PI2:a<-r.cj.PI&&(a+=r.cj.PI2),a=n+(a+m)*s;const i=Math.sqrt(t*t+e*e);g.c=Math.cos(a)*i,g.d=Math.sin(a)*i,p=!0}p&&(d.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,e=this.translateMix,n=this.scaleMix,s=this.shearMix,a=this.target,i=a.matrix,o=i.a,l=i.c,h=i.b,c=i.d,d=o*c-l*h>0?r.cj.degRad:-r.cj.degRad,u=this.data.offsetRotation*d,m=this.data.offsetShearY*d,f=this.bones;for(let i=0,d=f.length;i<d;i++){const d=f[i];let p=!1;const g=d.matrix;if(0!=t){const e=g.a,n=g.c,s=g.b,a=g.d;let i=Math.atan2(h,o)+u;i>r.cj.PI?i-=r.cj.PI2:i<-r.cj.PI&&(i+=r.cj.PI2),i*=t;const l=Math.cos(i),c=Math.sin(i);g.a=l*e-c*s,g.c=l*n-c*a,g.b=c*e+l*s,g.d=c*n+l*a,p=!0}if(0!=e){const t=this.temp;a.localToWorld(t.set(this.data.offsetX,this.data.offsetY)),g.tx+=t.x*e,g.ty+=t.y*e,p=!0}if(n>0){let t=(Math.sqrt(o*o+h*h)-1+this.data.offsetScaleX)*n+1;g.a*=t,g.b*=t,t=(Math.sqrt(l*l+c*c)-1+this.data.offsetScaleY)*n+1,g.c*=t,g.d*=t,p=!0}if(s>0){let t=Math.atan2(c,l)-Math.atan2(h,o);t>r.cj.PI?t-=r.cj.PI2:t<-r.cj.PI&&(t+=r.cj.PI2);const e=g.c,n=g.d;t=Math.atan2(n,e)+(t-r.cj.PI/2+m)*s;const a=Math.sqrt(e*e+n*n);g.c=Math.cos(t)*a,g.d=Math.sin(t)*a,p=!0}p&&(d.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,e=this.translateMix,n=this.scaleMix,s=this.shearMix,a=this.target;a.appliedValid||a.updateAppliedTransform();const r=this.bones;for(let i=0,o=r.length;i<o;i++){const o=r[i];o.appliedValid||o.updateAppliedTransform();let l=o.arotation;if(0!=t){let e=a.arotation-l+this.data.offsetRotation;e-=360*(16384-(16384.499999999996-e/360|0)),l+=e*t}let h=o.ax,c=o.ay;0!=e&&(h+=(a.ax-h+this.data.offsetX)*e,c+=(a.ay-c+this.data.offsetY)*e);let d=o.ascaleX,u=o.ascaleY;n>0&&(d>1e-5&&(d=(d+(a.ascaleX-d+this.data.offsetScaleX)*n)/d),u>1e-5&&(u=(u+(a.ascaleY-u+this.data.offsetScaleY)*n)/u));const m=o.ashearY;if(s>0){let t=a.ashearY-m+this.data.offsetShearY;t-=360*(16384-(16384.499999999996-t/360|0)),o.shearY+=t*s}o.updateWorldTransformWith(h,c,l,d,u,o.ashearX,m)}}applyRelativeLocal(){const t=this.rotateMix,e=this.translateMix,n=this.scaleMix,s=this.shearMix,a=this.target;a.appliedValid||a.updateAppliedTransform();const r=this.bones;for(let i=0,o=r.length;i<o;i++){const o=r[i];o.appliedValid||o.updateAppliedTransform();let l=o.arotation;0!=t&&(l+=(a.arotation+this.data.offsetRotation)*t);let h=o.ax,c=o.ay;0!=e&&(h+=(a.ax+this.data.offsetX)*e,c+=(a.ay+this.data.offsetY)*e);let d=o.ascaleX,u=o.ascaleY;n>0&&(d>1e-5&&(d*=(a.ascaleX-1+this.data.offsetScaleX)*n+1),u>1e-5&&(u*=(a.ascaleY-1+this.data.offsetScaleY)*n+1));let m=o.ashearY;s>0&&(m+=(a.ashearY+this.data.offsetShearY)*s),o.updateWorldTransformWith(h,c,l,d,u,o.ashearX,m)}}getOrder(){return this.data.order}}const Qe=class{constructor(t){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,null==t)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){const n=t.bones[e];let s;if(null==n.parent)s=new De(n,this,null);else{const t=this.bones[n.parent.index];s=new De(n,this,t),t.children.push(s)}this.bones.push(s)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){const n=t.slots[e],s=this.bones[n.boneData.index],a=new $t(n,s);this.slots.push(a),this.drawOrder.push(a)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){const n=t.ikConstraints[e];this.ikConstraints.push(new Be(n,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){const n=t.transformConstraints[e];this.transformConstraints.push(new He(n,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){const n=t.pathConstraints[e];this.pathConstraints.push(new $e(n,this))}this.color=new r.Q1(1,1,1,1),this.updateCache()}updateCache(){this._updateCache.length=0,this.updateCacheReset.length=0;const t=this.bones;for(let e=0,n=t.length;e<n;e++)t[e].sorted=!1;const e=this.ikConstraints,n=this.transformConstraints,s=this.pathConstraints,a=e.length,r=n.length,i=s.length,o=a+r+i;t:for(let t=0;t<o;t++){for(let n=0;n<a;n++){const s=e[n];if(s.data.order==t){this.sortIkConstraint(s);continue t}}for(let e=0;e<r;e++){const s=n[e];if(s.data.order==t){this.sortTransformConstraint(s);continue t}}for(let e=0;e<i;e++){const n=s[e];if(n.data.order==t){this.sortPathConstraint(n);continue t}}}for(let e=0,n=t.length;e<n;e++)this.sortBone(t[e])}sortIkConstraint(t){const e=t.target;this.sortBone(e);const n=t.bones,s=n[0];if(this.sortBone(s),n.length>1){const t=n[n.length-1];this._updateCache.indexOf(t)>-1||this.updateCacheReset.push(t)}this._updateCache.push(t),this.sortReset(s.children),n[n.length-1].sorted=!0}sortPathConstraint(t){const e=t.target,n=e.data.index,s=e.bone;null!=this.skin&&this.sortPathConstraintAttachment(this.skin,n,s),null!=this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,n,s);for(let t=0,e=this.data.skins.length;t<e;t++)this.sortPathConstraintAttachment(this.data.skins[t],n,s);const a=e.getAttachment();a instanceof jt&&this.sortPathConstraintAttachmentWith(a,s);const r=t.bones,i=r.length;for(let t=0;t<i;t++)this.sortBone(r[t]);this._updateCache.push(t);for(let t=0;t<i;t++)this.sortReset(r[t].children);for(let t=0;t<i;t++)r[t].sorted=!0}sortTransformConstraint(t){this.sortBone(t.target);const e=t.bones,n=e.length;if(t.data.local)for(let t=0;t<n;t++){const n=e[t];this.sortBone(n.parent),this._updateCache.indexOf(n)>-1||this.updateCacheReset.push(n)}else for(let t=0;t<n;t++)this.sortBone(e[t]);this._updateCache.push(t);for(let t=0;t<n;t++)this.sortReset(e[t].children);for(let t=0;t<n;t++)e[t].sorted=!0}sortPathConstraintAttachment(t,e,n){const s=t.attachments[e];if(s)for(const t in s)this.sortPathConstraintAttachmentWith(s[t],n)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof jt))return;const n=t.bones;if(null==n)this.sortBone(e);else{const t=this.bones;let e=0;for(;e<n.length;){const s=n[e++];for(let a=e+s;e<a;e++){const s=n[e];this.sortBone(t[s])}}}}sortBone(t){if(t.sorted)return;const e=t.parent;null!=e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,n=t.length;e<n;e++){const n=t[e];n.sorted&&this.sortReset(n.children),n.sorted=!1}}updateWorldTransform(){const t=this.updateCacheReset;for(let e=0,n=t.length;e<n;e++){const n=t[e];n.ax=n.x,n.ay=n.y,n.arotation=n.rotation,n.ascaleX=n.scaleX,n.ascaleY=n.scaleY,n.ashearX=n.shearX,n.ashearY=n.shearY,n.appliedValid=!0}const e=this._updateCache;for(let t=0,n=e.length;t<n;t++)e[t].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let e=0,n=t.length;e<n;e++)t[e].setToSetupPose();const e=this.ikConstraints;for(let t=0,n=e.length;t<n;t++){const n=e[t];n.bendDirection=n.data.bendDirection,n.mix=n.data.mix}const n=this.transformConstraints;for(let t=0,e=n.length;t<e;t++){const e=n[t],s=e.data;e.rotateMix=s.rotateMix,e.translateMix=s.translateMix,e.scaleMix=s.scaleMix,e.shearMix=s.shearMix}const s=this.pathConstraints;for(let t=0,e=s.length;t<e;t++){const e=s[t],n=e.data;e.position=n.position,e.spacing=n.spacing,e.rotateMix=n.rotateMix,e.translateMix=n.translateMix}}setSlotsToSetupPose(){const t=this.slots;r.Aq.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,n=t.length;e<n;e++)t[e].setToSetupPose()}getRootBone(){return 0==this.bones.length?null:this.bones[0]}findBone(t){if(null==t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findBoneIndex(t){if(null==t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++)if(e[n].data.name==t)return n;return-1}findSlot(t){if(null==t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findSlotIndex(t){if(null==t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++)if(e[n].data.name==t)return n;return-1}setSkinByName(t){const e=this.data.findSkin(t);if(null==e)throw new Error(`Skin not found: ${t}`);this.setSkin(e)}setSkin(t){if(null!=t)if(null!=this.skin)t.attachAll(this,this.skin);else{const e=this.slots;for(let n=0,s=e.length;n<s;n++){const s=e[n],a=s.data.attachmentName;if(null!=a){const e=t.getAttachment(n,a);null!=e&&s.setAttachment(e)}}}this.skin=t}getAttachmentByName(t,e){return this.getAttachment(this.data.findSlotIndex(t),e)}getAttachment(t,e){if(null==e)throw new Error("attachmentName cannot be null.");if(null!=this.skin){const n=this.skin.getAttachment(t,e);if(null!=n)return n}return null!=this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(null==t)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,a=n.length;s<a;s++){const a=n[s];if(a.data.name==t){let n=null;if(null!=e&&(n=this.getAttachment(s,e),null==n))throw new Error(`Attachment not found: ${e}, for slot: ${t}`);return void a.setAttachment(n)}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findTransformConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findPathConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}getBounds(t,e,n){if(null==t)throw new Error("offset cannot be null.");if(null==e)throw new Error("size cannot be null.");const s=this.drawOrder;let a=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY,l=Number.NEGATIVE_INFINITY;for(let t=0,e=s.length;t<e;t++){const e=s[t];let h=0,c=null;const d=e.getAttachment();if(d instanceof Qt)h=8,c=r.Aq.setArraySize(n,h,0),d.computeWorldVertices(e.bone,c,0,2);else if(d instanceof Ut){const t=d;h=t.worldVerticesLength,c=r.Aq.setArraySize(n,h,0),t.computeWorldVertices(e,0,h,c,0,2)}if(null!=c)for(let t=0,e=c.length;t<e;t+=2){const e=c[t],n=c[t+1];a=Math.min(a,e),i=Math.min(i,n),o=Math.max(o,e),l=Math.max(l,n)}}t.set(a,i),e.set(o-a,l-i)}update(t){this.time+=t}get flipX(){return-1==this.scaleX}set flipX(t){Qe.deprecatedWarning1||(Qe.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return-1==this.scaleY}set flipY(t){Qe.deprecatedWarning1||(Qe.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};let Ge=Qe;Ge.deprecatedWarning1=!1;class Ze extends r.S3{}class ze{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(null==t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findBoneIndex(t){if(null==t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++)if(e[n].name==t)return n;return-1}findSlot(t){if(null==t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findSlotIndex(t){if(null==t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++)if(e[n].name==t)return n;return-1}findSkin(t){if(null==t)throw new Error("skinName cannot be null.");const e=this.skins;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findEvent(t){if(null==t)throw new Error("eventDataName cannot be null.");const e=this.events;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findAnimation(t){if(null==t)throw new Error("animationName cannot be null.");const e=this.animations;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findIkConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findTransformConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findPathConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findPathConstraintIndex(t){if(null==t)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let n=0,s=e.length;n<s;n++)if(e[n].name==t)return n;return-1}}class Je{constructor(t,e,n){if(this.color=new r.Q1(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(null==e)throw new Error("name cannot be null.");if(null==n)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=n}}class Ke{constructor(t){if(this.order=0,this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1,null==t)throw new Error("name cannot be null.");this.name=t}}class tn{constructor(t){if(this.attachments=new Array,null==t)throw new Error("name cannot be null.");this.name=t}addAttachment(t,e,n){if(null==n)throw new Error("attachment cannot be null.");const s=this.attachments;t>=s.length&&(s.length=t+1),s[t]||(s[t]={}),s[t][e]=n}getAttachment(t,e){const n=this.attachments[t];return n?n[e]:null}attachAll(t,e){let n=0;for(let s=0;s<t.slots.length;s++){const a=t.slots[s],r=a.getAttachment();if(r&&n<e.attachments.length){const t=e.attachments[n];for(const e in t)if(r==t[e]){const t=this.getAttachment(n,e);null!=t&&a.setAttachment(t);break}}n++}}}class en{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,n=new ze,s="string"==typeof t?JSON.parse(t):t,a=s.skeleton;if(null!=a&&(n.hash=a.hash,n.version=a.spine,n.width=a.width,n.height=a.height,n.fps=a.fps,n.imagesPath=a.images),s.bones)for(let t=0;t<s.bones.length;t++){const a=s.bones[t];let r=null;const i=this.getValue(a,"parent",null);if(null!=i&&(r=n.findBone(i),null==r))throw new Error(`Parent bone not found: ${i}`);const o=new Xe(n.bones.length,a.name,r);o.length=this.getValue(a,"length",0)*e,o.x=this.getValue(a,"x",0)*e,o.y=this.getValue(a,"y",0)*e,o.rotation=this.getValue(a,"rotation",0),o.scaleX=this.getValue(a,"scaleX",1),o.scaleY=this.getValue(a,"scaleY",1),o.shearX=this.getValue(a,"shearX",0),o.shearY=this.getValue(a,"shearY",0),o.transformMode=en.transformModeFromString(this.getValue(a,"transform","normal")),n.bones.push(o)}if(s.slots)for(let t=0;t<s.slots.length;t++){const e=s.slots[t],a=e.name,i=e.bone,o=n.findBone(i);if(null==o)throw new Error(`Slot bone not found: ${i}`);const l=new Je(n.slots.length,a,o),h=this.getValue(e,"color",null);null!=h&&l.color.setFromString(h);const c=this.getValue(e,"dark",null);null!=c&&(l.darkColor=new r.Q1(1,1,1,1),l.darkColor.setFromString(c)),l.attachmentName=this.getValue(e,"attachment",null),l.blendMode=en.blendModeFromString(this.getValue(e,"blend","normal")),n.slots.push(l)}if(s.ik)for(let t=0;t<s.ik.length;t++){const e=s.ik[t],a=new Le(e.name);a.order=this.getValue(e,"order",0);for(let t=0;t<e.bones.length;t++){const s=e.bones[t],r=n.findBone(s);if(null==r)throw new Error(`IK bone not found: ${s}`);a.bones.push(r)}const r=e.target;if(a.target=n.findBone(r),null==a.target)throw new Error(`IK target bone not found: ${r}`);a.bendDirection=this.getValue(e,"bendPositive",!0)?1:-1,a.mix=this.getValue(e,"mix",1),n.ikConstraints.push(a)}if(s.transform)for(let t=0;t<s.transform.length;t++){const a=s.transform[t],r=new Ke(a.name);r.order=this.getValue(a,"order",0);for(let t=0;t<a.bones.length;t++){const e=a.bones[t],s=n.findBone(e);if(null==s)throw new Error(`Transform constraint bone not found: ${e}`);r.bones.push(s)}const i=a.target;if(r.target=n.findBone(i),null==r.target)throw new Error(`Transform constraint target bone not found: ${i}`);r.local=this.getValue(a,"local",!1),r.relative=this.getValue(a,"relative",!1),r.offsetRotation=this.getValue(a,"rotation",0),r.offsetX=this.getValue(a,"x",0)*e,r.offsetY=this.getValue(a,"y",0)*e,r.offsetScaleX=this.getValue(a,"scaleX",0),r.offsetScaleY=this.getValue(a,"scaleY",0),r.offsetShearY=this.getValue(a,"shearY",0),r.rotateMix=this.getValue(a,"rotateMix",1),r.translateMix=this.getValue(a,"translateMix",1),r.scaleMix=this.getValue(a,"scaleMix",1),r.shearMix=this.getValue(a,"shearMix",1),n.transformConstraints.push(r)}if(s.path)for(let t=0;t<s.path.length;t++){const a=s.path[t],i=new Ue(a.name);i.order=this.getValue(a,"order",0);for(let t=0;t<a.bones.length;t++){const e=a.bones[t],s=n.findBone(e);if(null==s)throw new Error(`Transform constraint bone not found: ${e}`);i.bones.push(s)}const o=a.target;if(i.target=n.findSlot(o),null==i.target)throw new Error(`Path target slot not found: ${o}`);i.positionMode=en.positionModeFromString(this.getValue(a,"positionMode","percent")),i.spacingMode=en.spacingModeFromString(this.getValue(a,"spacingMode","length")),i.rotateMode=en.rotateModeFromString(this.getValue(a,"rotateMode","tangent")),i.offsetRotation=this.getValue(a,"rotation",0),i.position=this.getValue(a,"position",0),i.positionMode==r.pw.Fixed&&(i.position*=e),i.spacing=this.getValue(a,"spacing",0),i.spacingMode!=je.Length&&i.spacingMode!=je.Fixed||(i.spacing*=e),i.rotateMix=this.getValue(a,"rotateMix",1),i.translateMix=this.getValue(a,"translateMix",1),n.pathConstraints.push(i)}if(s.skins)for(const t in s.skins){const e=s.skins[t],a=new tn(t);for(const t in e){const s=n.findSlotIndex(t);if(-1==s)throw new Error(`Slot not found: ${t}`);const r=e[t];for(const t in r){const e=this.readAttachment(r[t],a,s,t,n);null!=e&&a.addAttachment(s,t,e)}}n.skins.push(a),"default"==a.name&&(n.defaultSkin=a)}for(let t=0,e=this.linkedMeshes.length;t<e;t++){const e=this.linkedMeshes[t],s=null==e.skin?n.defaultSkin:n.findSkin(e.skin);if(null==s)throw new Error(`Skin not found: ${e.skin}`);const a=s.getAttachment(e.slotIndex,e.parent);if(null==a)throw new Error(`Parent mesh not found: ${e.parent}`);e.mesh.setParentMesh(a)}if(this.linkedMeshes.length=0,s.events)for(const t in s.events){const e=s.events[t],a=new Oe(t);a.intValue=this.getValue(e,"int",0),a.floatValue=this.getValue(e,"float",0),a.stringValue=this.getValue(e,"string",""),a.audioPath=this.getValue(e,"audio",null),null!=a.audioPath&&(a.volume=this.getValue(e,"volume",1),a.balance=this.getValue(e,"balance",0)),n.events.push(a)}if(s.animations)for(const t in s.animations){const e=s.animations[t];this.readAnimation(e,t,n)}return n}readAttachment(t,e,n,s,a){const i=this.scale;switch(s=this.getValue(t,"name",s),this.getValue(t,"type","region")){case"region":{const n=this.getValue(t,"path",s),a=this.attachmentLoader.newRegionAttachment(e,s,n);if(null==a)return null;a.path=n,a.x=this.getValue(t,"x",0)*i,a.y=this.getValue(t,"y",0)*i,a.scaleX=this.getValue(t,"scaleX",1),a.scaleY=this.getValue(t,"scaleY",1),a.rotation=this.getValue(t,"rotation",0),a.width=t.width*i,a.height=t.height*i;const r=this.getValue(t,"color",null);return null!=r&&a.color.setFromString(r),a}case"boundingbox":{const n=this.attachmentLoader.newBoundingBoxAttachment(e,s);if(null==n)return null;this.readVertices(t,n,t.vertexCount<<1);const a=this.getValue(t,"color",null);return null!=a&&n.color.setFromString(a),n}case"mesh":case"linkedmesh":{const a=this.getValue(t,"path",s),r=this.attachmentLoader.newMeshAttachment(e,s,a);if(null==r)return null;r.path=a;const i=this.getValue(t,"color",null);null!=i&&r.color.setFromString(i);const o=this.getValue(t,"parent",null);if(null!=o)return r.inheritDeform=this.getValue(t,"deform",!0),this.linkedMeshes.push(new nn(r,this.getValue(t,"skin",null),n,o)),r;const l=t.uvs;return this.readVertices(t,r,l.length),r.triangles=t.triangles,r.regionUVs=new Float32Array(l),r.hullLength=2*this.getValue(t,"hull",0),r}case"path":{const n=this.attachmentLoader.newPathAttachment(e,s);if(null==n)return null;n.closed=this.getValue(t,"closed",!1),n.constantSpeed=this.getValue(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,n,a<<1);const o=r.Aq.newArray(a/3,0);for(let e=0;e<t.lengths.length;e++)o[e]=t.lengths[e]*i;n.lengths=o;const l=this.getValue(t,"color",null);return null!=l&&n.color.setFromString(l),n}case"point":{const n=this.attachmentLoader.newPointAttachment(e,s);if(null==n)return null;n.x=this.getValue(t,"x",0)*i,n.y=this.getValue(t,"y",0)*i,n.rotation=this.getValue(t,"rotation",0);const a=this.getValue(t,"color",null);return null!=a&&n.color.setFromString(a),n}case"clipping":{const n=this.attachmentLoader.newClippingAttachment(e,s);if(null==n)return null;const r=this.getValue(t,"end",null);if(null!=r){const t=a.findSlot(r);if(null==t)throw new Error(`Clipping end slot not found: ${r}`);n.endSlot=t}const i=t.vertexCount;this.readVertices(t,n,i<<1);const o=this.getValue(t,"color",null);return null!=o&&n.color.setFromString(o),n}}return null}readVertices(t,e,n){const s=this.scale;e.worldVerticesLength=n;const a=t.vertices;if(n==a.length){const t=r.Aq.toFloatArray(a);if(1!=s)for(let e=0,n=a.length;e<n;e++)t[e]*=s;return void(e.vertices=t)}const i=new Array,o=new Array;for(let t=0,e=a.length;t<e;){const e=a[t++];o.push(e);for(let n=t+4*e;t<n;t+=4)o.push(a[t]),i.push(a[t+1]*s),i.push(a[t+2]*s),i.push(a[t+3])}e.bones=o,e.vertices=r.Aq.toFloatArray(i)}readAnimation(t,e,n){const s=this.scale,a=new Array;let i=0;if(t.slots)for(const e in t.slots){const s=t.slots[e],o=n.findSlotIndex(e);if(-1==o)throw new Error(`Slot not found: ${e}`);for(const t in s){const n=s[t];if("attachment"==t){const t=new ue(n.length);t.slotIndex=o;let e=0;for(let s=0;s<n.length;s++){const a=n[s];t.setFrame(e++,a.time,a.name)}a.push(t),i=Math.max(i,t.frames[t.getFrameCount()-1])}else if("color"==t){const t=new he(n.length);t.slotIndex=o;let e=0;for(let s=0;s<n.length;s++){const a=n[s],i=new r.Q1;i.setFromString(a.color||"ffffffff"),t.setFrame(e,a.time,i.r,i.g,i.b,i.a),this.readCurve(a,t,e),e++}a.push(t),i=Math.max(i,t.frames[(t.getFrameCount()-1)*he.ENTRIES])}else{if("twoColor"!=t)throw new Error(`Invalid timeline type for a slot: ${t} (${e})`);{const t=new de(n.length);t.slotIndex=o;let e=0;for(let s=0;s<n.length;s++){const a=n[s],i=new r.Q1,o=new r.Q1;i.setFromString(a.light),o.setFromString(a.dark),t.setFrame(e,a.time,i.r,i.g,i.b,i.a,o.r,o.g,o.b),this.readCurve(a,t,e),e++}a.push(t),i=Math.max(i,t.frames[(t.getFrameCount()-1)*de.ENTRIES])}}}}if(t.bones)for(const e in t.bones){const r=t.bones[e],o=n.findBoneIndex(e);if(-1==o)throw new Error(`Bone not found: ${e}`);for(const t in r){const n=r[t];if("rotate"===t){const t=new se(n.length);t.boneIndex=o;let e=0;for(let s=0;s<n.length;s++){const a=n[s];t.setFrame(e,a.time,a.angle),this.readCurve(a,t,e),e++}a.push(t),i=Math.max(i,t.frames[(t.getFrameCount()-1)*se.ENTRIES])}else{if("translate"!==t&&"scale"!==t&&"shear"!==t)throw new Error(`Invalid timeline type for a bone: ${t} (${e})`);{let e=null,r=1;"scale"===t?e=new ie(n.length):"shear"===t?e=new oe(n.length):(e=new re(n.length),r=s),e.boneIndex=o;let l=0;for(let t=0;t<n.length;t++){const s=n[t],a=this.getValue(s,"x",0),i=this.getValue(s,"y",0);e.setFrame(l,s.time,a*r,i*r),this.readCurve(s,e,l),l++}a.push(e),i=Math.max(i,e.frames[(e.getFrameCount()-1)*re.ENTRIES])}}}}if(t.ik)for(const e in t.ik){const s=t.ik[e],r=n.findIkConstraint(e),o=new xe(s.length);o.ikConstraintIndex=n.ikConstraints.indexOf(r);let l=0;for(let t=0;t<s.length;t++){const e=s[t];o.setFrame(l,e.time,this.getValue(e,"mix",1),this.getValue(e,"bendPositive",!0)?1:-1,this.getValue(e,"compress",!1),this.getValue(e,"stretch",!1)),this.readCurve(e,o,l),l++}a.push(o),i=Math.max(i,o.frames[(o.getFrameCount()-1)*xe.ENTRIES])}if(t.transform)for(const e in t.transform){const s=t.transform[e],r=n.findTransformConstraint(e),o=new Ae(s.length);o.transformConstraintIndex=n.transformConstraints.indexOf(r);let l=0;for(let t=0;t<s.length;t++){const e=s[t];o.setFrame(l,e.time,this.getValue(e,"rotateMix",1),this.getValue(e,"translateMix",1),this.getValue(e,"scaleMix",1),this.getValue(e,"shearMix",1)),this.readCurve(e,o,l),l++}a.push(o),i=Math.max(i,o.frames[(o.getFrameCount()-1)*Ae.ENTRIES])}if(t.paths)for(const e in t.paths){const o=t.paths[e],l=n.findPathConstraintIndex(e);if(-1==l)throw new Error(`Path constraint not found: ${e}`);const h=n.pathConstraints[l];for(const t in o){const e=o[t];if("position"===t||"spacing"===t){let n=null,o=1;"spacing"===t?(n=new Me(e.length),h.spacingMode!=je.Length&&h.spacingMode!=je.Fixed||(o=s)):(n=new be(e.length),h.positionMode==r.pw.Fixed&&(o=s)),n.pathConstraintIndex=l;let c=0;for(let s=0;s<e.length;s++){const a=e[s];n.setFrame(c,a.time,this.getValue(a,t,0)*o),this.readCurve(a,n,c),c++}a.push(n),i=Math.max(i,n.frames[(n.getFrameCount()-1)*be.ENTRIES])}else if("mix"===t){const t=new Re(e.length);t.pathConstraintIndex=l;let n=0;for(let s=0;s<e.length;s++){const a=e[s];t.setFrame(n,a.time,this.getValue(a,"rotateMix",1),this.getValue(a,"translateMix",1)),this.readCurve(a,t,n),n++}a.push(t),i=Math.max(i,t.frames[(t.getFrameCount()-1)*Re.ENTRIES])}}}if(t.deform)for(const e in t.deform){const o=t.deform[e],l=n.findSkin(e);if(null!=l)for(const t in o){const e=o[t],h=n.findSlotIndex(t);if(-1==h)throw new Error(`Slot not found: ${e.name}`);for(const t in e){const n=e[t],o=l.getAttachment(h,t);if(null==o)throw new Error(`Deform attachment not found: ${n.name}`);const c=null!=o.bones,d=o.vertices,u=c?d.length/3*2:d.length,m=new fe(n.length);m.slotIndex=h,m.attachment=o;let f=0;for(let t=0;t<n.length;t++){const e=n[t];let a;const i=this.getValue(e,"vertices",null);if(null==i)a=c?r.Aq.newFloatArray(u):d;else{a=r.Aq.newFloatArray(u);const t=this.getValue(e,"offset",0);if(r.Aq.arrayCopy(i,0,a,t,i.length),1!=s)for(let e=t,n=e+i.length;e<n;e++)a[e]*=s;if(!c)for(let t=0;t<u;t++)a[t]+=d[t]}m.setFrame(f,e.time,a),this.readCurve(e,m,f),f++}a.push(m),i=Math.max(i,m.frames[m.getFrameCount()-1])}}else if(r.W0.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${e}`)}let o=t.drawOrder;if(null==o&&(o=t.draworder),null!=o){const t=new ge(o.length),e=n.slots.length;let s=0;for(let a=0;a<o.length;a++){const i=o[a];let l=null;const h=this.getValue(i,"offsets",null);if(null!=h){l=r.Aq.newArray(e,-1);const t=r.Aq.newArray(e-h.length,0);let s=0,a=0;for(let e=0;e<h.length;e++){const r=h[e],i=n.findSlotIndex(r.slot);if(-1==i)throw new Error(`Slot not found: ${r.slot}`);for(;s!=i;)t[a++]=s++;l[s+r.offset]=s++}for(;s<e;)t[a++]=s++;for(let n=e-1;n>=0;n--)-1==l[n]&&(l[n]=t[--a])}t.setFrame(s++,i.time,l)}a.push(t),i=Math.max(i,t.frames[t.getFrameCount()-1])}if(t.events){const e=new pe(t.events.length);let s=0;for(let a=0;a<t.events.length;a++){const i=t.events[a],o=n.findEvent(i.name);if(null==o)throw new Error(`Event not found: ${i.name}`);const l=new Ye(r.Aq.toSinglePrecision(i.time),o);l.intValue=this.getValue(i,"int",o.intValue),l.floatValue=this.getValue(i,"float",o.floatValue),l.stringValue=this.getValue(i,"string",o.stringValue),null!=l.data.audioPath&&(l.volume=this.getValue(i,"volume",1),l.balance=this.getValue(i,"balance",0)),e.setFrame(s++,l)}a.push(e),i=Math.max(i,e.frames[e.getFrameCount()-1])}if(isNaN(i))throw new Error("Error while parsing animation, duration is NaN");n.animations.push(new Jt(e,a,i))}readCurve(t,e,n){if(t.curve)if("stepped"===t.curve)e.setStepped(n);else if("[object Array]"===Object.prototype.toString.call(t.curve)){const s=t.curve;e.setCurve(n,s[0],s[1],s[2],s[3])}}getValue(t,e,n){return void 0!==t[e]?t[e]:n}static blendModeFromString(t){if("normal"==(t=t.toLowerCase()))return o.B9.NORMAL;if("additive"==t)return o.B9.ADD;if("multiply"==t)return o.B9.MULTIPLY;if("screen"==t)return o.B9.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if("fixed"==(t=t.toLowerCase()))return r.pw.Fixed;if("percent"==t)return r.pw.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if("length"==(t=t.toLowerCase()))return je.Length;if("fixed"==t)return je.Fixed;if("percent"==t)return je.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if("tangent"==(t=t.toLowerCase()))return r.Dr.Tangent;if("chain"==t)return r.Dr.Chain;if("chainscale"==t)return r.Dr.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if("normal"==(t=t.toLowerCase()))return r._C.Normal;if("onlytranslation"==t)return r._C.OnlyTranslation;if("norotationorreflection"==t)return r._C.NoRotationOrReflection;if("noscale"==t)return r._C.NoScale;if("noscaleorreflection"==t)return r._C.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}}class nn{constructor(t,e,n,s){this.mesh=t,this.skin=e,this.slotIndex=n,this.parent=s}}class sn extends r.bJ{createSkeleton(t){this.skeleton=new Ge(t),this.skeleton.updateWorldTransform(),this.stateData=new Fe(t),this.state=new Ie(this.stateData)}}var an=n("webpack/sharing/consume/default/@pixi-spine/runtime-4.1/@pixi-spine/runtime-4.1"),rn=n.t(an,2),on=(t=>(t[t.UNKNOWN=0]="UNKNOWN",t[t.VER37=37]="VER37",t[t.VER38=38]="VER38",t[t.VER40=40]="VER40",t[t.VER41=41]="VER41",t))(on||{});function ln(t){const e=t.substr(0,3),n=Math.floor(10*Number(e)+.001);return"3.7"===e?37:"3.8"===e?38:"4.0"===e?40:"4.1"===e?41:n<37?37:0}class hn{constructor(){this.scale=1}readSkeletonData(t,e){let n=null,s=this.readVersionOldFormat(e),a=ln(s);if(a===on.VER38&&(n=new Pt(new ct(t))),s=this.readVersionNewFormat(e),a=ln(s),a!==on.VER40&&a!==on.VER41||(n=new an.SkeletonBinary(new an.AtlasAttachmentLoader(t))),!n){const t=`Unsupported version of spine model ${s}, please update pixi-spine`;console.error(t)}return n.scale=this.scale,n.readSkeletonData(e)}readVersionOldFormat(t){const e=new r.aG(t);let n;try{e.readString(),n=e.readString()}catch(t){n=""}return n||""}readVersionNewFormat(t){const e=new r.aG(t);let n;e.readInt32(),e.readInt32();try{n=e.readString()}catch(t){n=""}return n||""}}class cn{constructor(){this.scale=1}readSkeletonData(t,e){const n=e.skeleton.spine,s=ln(n);let a=null;if(s===on.VER37&&(a=new en(new _e(t))),s===on.VER38&&(a=new Ft(new ct(t))),s!==on.VER40&&s!==on.VER41||(a=new an.SkeletonJson(new an.AtlasAttachmentLoader(t))),!a){const t=`Unsupported version of spine model ${n}, please update pixi-spine`;console.error(t)}return a.scale=this.scale,a.readSkeletonData(e)}}class dn extends r.bJ{createSkeleton(t){const e=ln(t.version);let n=null;if(e===on.VER37&&(n=a),e===on.VER38&&(n=s),e!==on.VER40&&e!==on.VER41||(n=rn),!n){const e=`Cant detect version of spine model ${t.version}`;console.error(e)}this.skeleton=new n.Skeleton(t),this.skeleton.updateWorldTransform(),this.stateData=new n.AnimationStateData(t),this.state=new n.AnimationState(this.stateData)}}(new class extends d{createBinaryParser(){return new hn}createJsonParser(){return new cn}parseData(t,e,n){return{spineData:t.readSkeletonData(e,n),spineAtlas:e}}}).installLoader()}}]);