"use strict";(self.webpackChunkfederation_clients=self.webpackChunkfederation_clients||[]).push([["vendors-node_modules_pixi_graphics_lib_index_mjs"],{"./node_modules/@pixi/display/lib/index.mjs":(t,s,e)=>{e.d(s,{cz:()=>h,mc:()=>c,q9:()=>n,dC:()=>r});var i=e("./node_modules/@pixi/core/lib/index.mjs");class h{constructor(){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0,this.rect=null,this.updateID=-1}isEmpty(){return this.minX>this.maxX||this.minY>this.maxY}clear(){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0}getRectangle(t){return this.minX>this.maxX||this.minY>this.maxY?i.M_.EMPTY:((t=t||new i.M_(0,0,1,1)).x=this.minX,t.y=this.minY,t.width=this.maxX-this.minX,t.height=this.maxY-this.minY,t)}addPoint(t){this.minX=Math.min(this.minX,t.x),this.maxX=Math.max(this.maxX,t.x),this.minY=Math.min(this.minY,t.y),this.maxY=Math.max(this.maxY,t.y)}addPointMatrix(t,s){const{a:e,b:i,c:h,d:n,tx:r,ty:a}=t,l=e*s.x+h*s.y+r,o=i*s.x+n*s.y+a;this.minX=Math.min(this.minX,l),this.maxX=Math.max(this.maxX,l),this.minY=Math.min(this.minY,o),this.maxY=Math.max(this.maxY,o)}addQuad(t){let s=this.minX,e=this.minY,i=this.maxX,h=this.maxY,n=t[0],r=t[1];s=n<s?n:s,e=r<e?r:e,i=n>i?n:i,h=r>h?r:h,n=t[2],r=t[3],s=n<s?n:s,e=r<e?r:e,i=n>i?n:i,h=r>h?r:h,n=t[4],r=t[5],s=n<s?n:s,e=r<e?r:e,i=n>i?n:i,h=r>h?r:h,n=t[6],r=t[7],s=n<s?n:s,e=r<e?r:e,i=n>i?n:i,h=r>h?r:h,this.minX=s,this.minY=e,this.maxX=i,this.maxY=h}addFrame(t,s,e,i,h){this.addFrameMatrix(t.worldTransform,s,e,i,h)}addFrameMatrix(t,s,e,i,h){const n=t.a,r=t.b,a=t.c,l=t.d,o=t.tx,c=t.ty;let d=this.minX,u=this.minY,m=this.maxX,p=this.maxY,g=n*s+a*e+o,f=r*s+l*e+c;d=g<d?g:d,u=f<u?f:u,m=g>m?g:m,p=f>p?f:p,g=n*i+a*e+o,f=r*i+l*e+c,d=g<d?g:d,u=f<u?f:u,m=g>m?g:m,p=f>p?f:p,g=n*s+a*h+o,f=r*s+l*h+c,d=g<d?g:d,u=f<u?f:u,m=g>m?g:m,p=f>p?f:p,g=n*i+a*h+o,f=r*i+l*h+c,d=g<d?g:d,u=f<u?f:u,m=g>m?g:m,p=f>p?f:p,this.minX=d,this.minY=u,this.maxX=m,this.maxY=p}addVertexData(t,s,e){let i=this.minX,h=this.minY,n=this.maxX,r=this.maxY;for(let a=s;a<e;a+=2){const s=t[a],e=t[a+1];i=s<i?s:i,h=e<h?e:h,n=s>n?s:n,r=e>r?e:r}this.minX=i,this.minY=h,this.maxX=n,this.maxY=r}addVertices(t,s,e,i){this.addVerticesMatrix(t.worldTransform,s,e,i)}addVerticesMatrix(t,s,e,i,h=0,n=h){const r=t.a,a=t.b,l=t.c,o=t.d,c=t.tx,d=t.ty;let u=this.minX,m=this.minY,p=this.maxX,g=this.maxY;for(let t=e;t<i;t+=2){const e=s[t],i=s[t+1],f=r*e+l*i+c,b=o*i+a*e+d;u=Math.min(u,f-h),p=Math.max(p,f+h),m=Math.min(m,b-n),g=Math.max(g,b+n)}this.minX=u,this.minY=m,this.maxX=p,this.maxY=g}addBounds(t){const s=this.minX,e=this.minY,i=this.maxX,h=this.maxY;this.minX=t.minX<s?t.minX:s,this.minY=t.minY<e?t.minY:e,this.maxX=t.maxX>i?t.maxX:i,this.maxY=t.maxY>h?t.maxY:h}addBoundsMask(t,s){const e=t.minX>s.minX?t.minX:s.minX,i=t.minY>s.minY?t.minY:s.minY,h=t.maxX<s.maxX?t.maxX:s.maxX,n=t.maxY<s.maxY?t.maxY:s.maxY;if(e<=h&&i<=n){const t=this.minX,s=this.minY,r=this.maxX,a=this.maxY;this.minX=e<t?e:t,this.minY=i<s?i:s,this.maxX=h>r?h:r,this.maxY=n>a?n:a}}addBoundsMatrix(t,s){this.addFrameMatrix(s,t.minX,t.minY,t.maxX,t.maxY)}addBoundsArea(t,s){const e=t.minX>s.x?t.minX:s.x,i=t.minY>s.y?t.minY:s.y,h=t.maxX<s.x+s.width?t.maxX:s.x+s.width,n=t.maxY<s.y+s.height?t.maxY:s.y+s.height;if(e<=h&&i<=n){const t=this.minX,s=this.minY,r=this.maxX,a=this.maxY;this.minX=e<t?e:t,this.minY=i<s?i:s,this.maxX=h>r?h:r,this.maxY=n>a?n:a}}pad(t=0,s=t){this.isEmpty()||(this.minX-=t,this.maxX+=t,this.minY-=s,this.maxY+=s)}addFramePad(t,s,e,i,h,n){t-=h,s-=n,e+=h,i+=n,this.minX=this.minX<t?this.minX:t,this.maxX=this.maxX>e?this.maxX:e,this.minY=this.minY<s?this.minY:s,this.maxY=this.maxY>i?this.maxY:i}}class n extends i.Wp.EventEmitter{constructor(){super(),this.tempDisplayObjectParent=null,this.transform=new i.dL,this.alpha=1,this.visible=!0,this.renderable=!0,this.cullable=!1,this.cullArea=null,this.parent=null,this.worldAlpha=1,this._lastSortedIndex=0,this._zIndex=0,this.filterArea=null,this.filters=null,this._enabledFilters=null,this._bounds=new h,this._localBounds=null,this._boundsID=0,this._boundsRect=null,this._localBoundsRect=null,this._mask=null,this._maskRefCount=0,this._destroyed=!1,this.isSprite=!1,this.isMask=!1}static mixin(t){const s=Object.keys(t);for(let e=0;e<s.length;++e){const i=s[e];Object.defineProperty(n.prototype,i,Object.getOwnPropertyDescriptor(t,i))}}get destroyed(){return this._destroyed}_recursivePostUpdateTransform(){this.parent?(this.parent._recursivePostUpdateTransform(),this.transform.updateTransform(this.parent.transform)):this.transform.updateTransform(this._tempDisplayObjectParent.transform)}updateTransform(){this._boundsID++,this.transform.updateTransform(this.parent.transform),this.worldAlpha=this.alpha*this.parent.worldAlpha}getBounds(t,s){return t||(this.parent?(this._recursivePostUpdateTransform(),this.updateTransform()):(this.parent=this._tempDisplayObjectParent,this.updateTransform(),this.parent=null)),this._bounds.updateID!==this._boundsID&&(this.calculateBounds(),this._bounds.updateID=this._boundsID),s||(this._boundsRect||(this._boundsRect=new i.M_),s=this._boundsRect),this._bounds.getRectangle(s)}getLocalBounds(t){t||(this._localBoundsRect||(this._localBoundsRect=new i.M_),t=this._localBoundsRect),this._localBounds||(this._localBounds=new h);const s=this.transform,e=this.parent;this.parent=null,this._tempDisplayObjectParent.worldAlpha=e?.worldAlpha??1,this.transform=this._tempDisplayObjectParent.transform;const n=this._bounds,r=this._boundsID;this._bounds=this._localBounds;const a=this.getBounds(!1,t);return this.parent=e,this.transform=s,this._bounds=n,this._bounds.updateID+=this._boundsID-r,a}toGlobal(t,s,e=!1){return e||(this._recursivePostUpdateTransform(),this.parent?this.displayObjectUpdateTransform():(this.parent=this._tempDisplayObjectParent,this.displayObjectUpdateTransform(),this.parent=null)),this.worldTransform.apply(t,s)}toLocal(t,s,e,i){return s&&(t=s.toGlobal(t,e,i)),i||(this._recursivePostUpdateTransform(),this.parent?this.displayObjectUpdateTransform():(this.parent=this._tempDisplayObjectParent,this.displayObjectUpdateTransform(),this.parent=null)),this.worldTransform.applyInverse(t,e)}setParent(t){if(!t||!t.addChild)throw new Error("setParent: Argument must be a Container");return t.addChild(this),t}removeFromParent(){this.parent?.removeChild(this)}setTransform(t=0,s=0,e=1,i=1,h=0,n=0,r=0,a=0,l=0){return this.position.x=t,this.position.y=s,this.scale.x=e||1,this.scale.y=i||1,this.rotation=h,this.skew.x=n,this.skew.y=r,this.pivot.x=a,this.pivot.y=l,this}destroy(t){this.removeFromParent(),this._destroyed=!0,this.transform=null,this.parent=null,this._bounds=null,this.mask=null,this.cullArea=null,this.filters=null,this.filterArea=null,this.hitArea=null,this.eventMode="auto",this.interactiveChildren=!1,this.emit("destroyed"),this.removeAllListeners()}get _tempDisplayObjectParent(){return null===this.tempDisplayObjectParent&&(this.tempDisplayObjectParent=new r),this.tempDisplayObjectParent}enableTempParent(){const t=this.parent;return this.parent=this._tempDisplayObjectParent,t}disableTempParent(t){this.parent=t}get x(){return this.position.x}set x(t){this.transform.position.x=t}get y(){return this.position.y}set y(t){this.transform.position.y=t}get worldTransform(){return this.transform.worldTransform}get localTransform(){return this.transform.localTransform}get position(){return this.transform.position}set position(t){this.transform.position.copyFrom(t)}get scale(){return this.transform.scale}set scale(t){this.transform.scale.copyFrom(t)}get pivot(){return this.transform.pivot}set pivot(t){this.transform.pivot.copyFrom(t)}get skew(){return this.transform.skew}set skew(t){this.transform.skew.copyFrom(t)}get rotation(){return this.transform.rotation}set rotation(t){this.transform.rotation=t}get angle(){return this.transform.rotation*i.bO}set angle(t){this.transform.rotation=t*i.Td}get zIndex(){return this._zIndex}set zIndex(t){this._zIndex!==t&&(this._zIndex=t,this.parent&&(this.parent.sortDirty=!0))}get worldVisible(){let t=this;do{if(!t.visible)return!1;t=t.parent}while(t);return!0}get mask(){return this._mask}set mask(t){if(this._mask!==t){if(this._mask){const t=this._mask.isMaskData?this._mask.maskObject:this._mask;t&&(t._maskRefCount--,0===t._maskRefCount&&(t.renderable=!0,t.isMask=!1))}if(this._mask=t,this._mask){const t=this._mask.isMaskData?this._mask.maskObject:this._mask;t&&(0===t._maskRefCount&&(t.renderable=!1,t.isMask=!0),t._maskRefCount++)}}}}class r extends n{constructor(){super(...arguments),this.sortDirty=null}}n.prototype.displayObjectUpdateTransform=n.prototype.updateTransform;const a=new i.uq;function l(t,s){return t.zIndex===s.zIndex?t._lastSortedIndex-s._lastSortedIndex:t.zIndex-s.zIndex}const o=class t extends n{constructor(){super(),this.children=[],this.sortableChildren=t.defaultSortableChildren,this.sortDirty=!1}onChildrenChange(t){}addChild(...t){if(t.length>1)for(let s=0;s<t.length;s++)this.addChild(t[s]);else{const s=t[0];s.parent&&s.parent.removeChild(s),s.parent=this,this.sortDirty=!0,s.transform._parentID=-1,this.children.push(s),this._boundsID++,this.onChildrenChange(this.children.length-1),this.emit("childAdded",s,this,this.children.length-1),s.emit("added",this)}return t[0]}addChildAt(t,s){if(s<0||s>this.children.length)throw new Error(`${t}addChildAt: The index ${s} supplied is out of bounds ${this.children.length}`);return t.parent&&t.parent.removeChild(t),t.parent=this,this.sortDirty=!0,t.transform._parentID=-1,this.children.splice(s,0,t),this._boundsID++,this.onChildrenChange(s),t.emit("added",this),this.emit("childAdded",t,this,s),t}swapChildren(t,s){if(t===s)return;const e=this.getChildIndex(t),i=this.getChildIndex(s);this.children[e]=s,this.children[i]=t,this.onChildrenChange(e<i?e:i)}getChildIndex(t){const s=this.children.indexOf(t);if(-1===s)throw new Error("The supplied DisplayObject must be a child of the caller");return s}setChildIndex(t,s){if(s<0||s>=this.children.length)throw new Error(`The index ${s} supplied is out of bounds ${this.children.length}`);const e=this.getChildIndex(t);i.Wp.removeItems(this.children,e,1),this.children.splice(s,0,t),this.onChildrenChange(s)}getChildAt(t){if(t<0||t>=this.children.length)throw new Error(`getChildAt: Index (${t}) does not exist.`);return this.children[t]}removeChild(...t){if(t.length>1)for(let s=0;s<t.length;s++)this.removeChild(t[s]);else{const s=t[0],e=this.children.indexOf(s);if(-1===e)return null;s.parent=null,s.transform._parentID=-1,i.Wp.removeItems(this.children,e,1),this._boundsID++,this.onChildrenChange(e),s.emit("removed",this),this.emit("childRemoved",s,this,e)}return t[0]}removeChildAt(t){const s=this.getChildAt(t);return s.parent=null,s.transform._parentID=-1,i.Wp.removeItems(this.children,t,1),this._boundsID++,this.onChildrenChange(t),s.emit("removed",this),this.emit("childRemoved",s,this,t),s}removeChildren(t=0,s=this.children.length){const e=t,i=s-e;let h;if(i>0&&i<=s){h=this.children.splice(e,i);for(let t=0;t<h.length;++t)h[t].parent=null,h[t].transform&&(h[t].transform._parentID=-1);this._boundsID++,this.onChildrenChange(t);for(let t=0;t<h.length;++t)h[t].emit("removed",this),this.emit("childRemoved",h[t],this,t);return h}if(0===i&&0===this.children.length)return[];throw new RangeError("removeChildren: numeric values are outside the acceptable range.")}sortChildren(){let t=!1;for(let s=0,e=this.children.length;s<e;++s){const e=this.children[s];e._lastSortedIndex=s,!t&&0!==e.zIndex&&(t=!0)}t&&this.children.length>1&&this.children.sort(l),this.sortDirty=!1}updateTransform(){this.sortableChildren&&this.sortDirty&&this.sortChildren(),this._boundsID++,this.transform.updateTransform(this.parent.transform),this.worldAlpha=this.alpha*this.parent.worldAlpha;for(let t=0,s=this.children.length;t<s;++t){const s=this.children[t];s.visible&&s.updateTransform()}}calculateBounds(){this._bounds.clear(),this._calculateBounds();for(let t=0;t<this.children.length;t++){const s=this.children[t];if(s.visible&&s.renderable)if(s.calculateBounds(),s._mask){const t=s._mask.isMaskData?s._mask.maskObject:s._mask;t?(t.calculateBounds(),this._bounds.addBoundsMask(s._bounds,t._bounds)):this._bounds.addBounds(s._bounds)}else s.filterArea?this._bounds.addBoundsArea(s._bounds,s.filterArea):this._bounds.addBounds(s._bounds)}this._bounds.updateID=this._boundsID}getLocalBounds(t,s=!1){const e=super.getLocalBounds(t);if(!s)for(let t=0,s=this.children.length;t<s;++t){const s=this.children[t];s.visible&&s.updateTransform()}return e}_calculateBounds(){}_renderWithCulling(s){const e=s.renderTexture.sourceFrame;if(!(e.width>0&&e.height>0))return;let i,h;this.cullArea?(i=this.cullArea,h=this.worldTransform):this._render!==t.prototype._render&&(i=this.getBounds(!0));const n=s.projection.transform;if(n&&(h?(h=a.copyFrom(h),h.prepend(n)):h=n),i&&e.intersects(i,h))this._render(s);else if(this.cullArea)return;for(let t=0,e=this.children.length;t<e;++t){const e=this.children[t],i=e.cullable;e.cullable=i||!this.cullArea,e.render(s),e.cullable=i}}render(t){if(this.visible&&!(this.worldAlpha<=0)&&this.renderable)if(this._mask||this.filters?.length)this.renderAdvanced(t);else if(this.cullable)this._renderWithCulling(t);else{this._render(t);for(let s=0,e=this.children.length;s<e;++s)this.children[s].render(t)}}renderAdvanced(t){const s=this.filters,e=this._mask;if(s){this._enabledFilters||(this._enabledFilters=[]),this._enabledFilters.length=0;for(let t=0;t<s.length;t++)s[t].enabled&&this._enabledFilters.push(s[t])}const h=s&&this._enabledFilters?.length||e&&(!e.isMaskData||e.enabled&&(e.autoDetect||e.type!==i.vg.NONE));if(h&&t.batch.flush(),s&&this._enabledFilters?.length&&t.filter.push(this,this._enabledFilters),e&&t.mask.push(this,this._mask),this.cullable)this._renderWithCulling(t);else{this._render(t);for(let s=0,e=this.children.length;s<e;++s)this.children[s].render(t)}h&&t.batch.flush(),e&&t.mask.pop(this),s&&this._enabledFilters?.length&&t.filter.pop()}_render(t){}destroy(t){super.destroy(),this.sortDirty=!1;const s="boolean"==typeof t?t:t?.children,e=this.removeChildren(0,this.children.length);if(s)for(let s=0;s<e.length;++s)e[s].destroy(t)}get width(){return this.scale.x*this.getLocalBounds().width}set width(t){const s=this.getLocalBounds().width;this.scale.x=0!==s?t/s:1,this._width=t}get height(){return this.scale.y*this.getLocalBounds().height}set height(t){const s=this.getLocalBounds().height;this.scale.y=0!==s?t/s:1,this._height=t}};o.defaultSortableChildren=!1;let c=o;c.prototype.containerUpdateTransform=c.prototype.updateTransform,Object.defineProperties(i.W0,{SORTABLE_CHILDREN:{get:()=>c.defaultSortableChildren,set(t){i.Wp.deprecation("7.1.0","settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"),c.defaultSortableChildren=t}}})},"./node_modules/@pixi/graphics/lib/index.mjs":(t,s,e)=>{e.d(s,{Zw:()=>S,lU:()=>u,A1:()=>B,ie:()=>M,mk:()=>P,Mp:()=>c,u2:()=>o,Sc:()=>I,LV:()=>d,lo:()=>R});var i=e("./node_modules/@pixi/core/lib/index.mjs");const h={build(t){const s=t.points;let e,h,n,r,a,l;if(t.type===i.HY.CIRC){const s=t.shape;e=s.x,h=s.y,a=l=s.radius,n=r=0}else if(t.type===i.HY.ELIP){const s=t.shape;e=s.x,h=s.y,a=s.width,l=s.height,n=r=0}else{const s=t.shape,i=s.width/2,o=s.height/2;e=s.x+i,h=s.y+o,a=l=Math.max(0,Math.min(s.radius,Math.min(i,o))),n=i-a,r=o-l}if(!(a>=0&&l>=0&&n>=0&&r>=0))return void(s.length=0);const o=Math.ceil(2.3*Math.sqrt(a+l)),c=8*o+(n?4:0)+(r?4:0);if(s.length=c,0===c)return;if(0===o)return s.length=8,s[0]=s[6]=e+n,s[1]=s[3]=h+r,s[2]=s[4]=e-n,void(s[5]=s[7]=h-r);let d=0,u=4*o+(n?2:0)+2,m=u,p=c;{const t=n+a,i=r,l=e+t,o=e-t,c=h+i;if(s[d++]=l,s[d++]=c,s[--u]=c,s[--u]=o,r){const t=h-i;s[m++]=o,s[m++]=t,s[--p]=t,s[--p]=l}}for(let t=1;t<o;t++){const i=Math.PI/2*(t/o),c=n+Math.cos(i)*a,g=r+Math.sin(i)*l,f=e+c,b=e-c,x=h+g,y=h-g;s[d++]=f,s[d++]=x,s[--u]=x,s[--u]=b,s[m++]=b,s[m++]=y,s[--p]=y,s[--p]=f}{const t=r+l,i=e+n,a=e-n,o=h+t,c=h-t;s[d++]=i,s[d++]=o,s[--p]=c,s[--p]=i,n&&(s[d++]=a,s[d++]=o,s[--p]=c,s[--p]=a)}},triangulate(t,s){const e=t.points,h=s.points,n=s.indices;if(0===e.length)return;let r=h.length/2;const a=r;let l,o;if(t.type!==i.HY.RREC){const s=t.shape;l=s.x,o=s.y}else{const s=t.shape;l=s.x+s.width/2,o=s.y+s.height/2}const c=t.matrix;h.push(t.matrix?c.a*l+c.c*o+c.tx:l,t.matrix?c.b*l+c.d*o+c.ty:o),r++,h.push(e[0],e[1]);for(let t=2;t<e.length;t+=2)h.push(e[t],e[t+1]),n.push(r++,a,r);n.push(a+1,a,r)}};function n(t,s=!1){const e=t.length;if(e<6)return;let i=0;for(let s=0,h=t[e-2],n=t[e-1];s<e;s+=2){const e=t[s],r=t[s+1];i+=(e-h)*(r+n),h=e,n=r}if(!s&&i>0||s&&i<=0){const s=e/2;for(let i=s+s%2;i<e;i+=2){const s=e-i-2,h=e-i-1,n=i,r=i+1;[t[s],t[n]]=[t[n],t[s]],[t[h],t[r]]=[t[r],t[h]]}}}const r={build(t){t.points=t.shape.points.slice()},triangulate(t,s){let e=t.points;const h=t.holes,r=s.points,a=s.indices;if(e.length>=6){n(e,!1);const t=[];for(let s=0;s<h.length;s++){const i=h[s];n(i.points,!0),t.push(e.length/2),e=e.concat(i.points)}const s=i.Wp.earcut(e,t,2);if(!s)return;const l=r.length/2;for(let t=0;t<s.length;t+=3)a.push(s[t]+l),a.push(s[t+1]+l),a.push(s[t+2]+l);for(let t=0;t<e.length;t++)r.push(e[t])}}},a={build(t){const s=t.shape,e=s.x,i=s.y,h=s.width,n=s.height,r=t.points;r.length=0,h>=0&&n>=0&&r.push(e,i,e+h,i,e+h,i+n,e,i+n)},triangulate(t,s){const e=t.points,i=s.points;if(0===e.length)return;const h=i.length/2;i.push(e[0],e[1],e[2],e[3],e[6],e[7],e[4],e[5]),s.indices.push(h,h+1,h+2,h+1,h+2,h+3)}},l={build(t){h.build(t)},triangulate(t,s){h.triangulate(t,s)}};var o=(t=>(t.MITER="miter",t.BEVEL="bevel",t.ROUND="round",t))(o||{}),c=(t=>(t.BUTT="butt",t.ROUND="round",t.SQUARE="square",t))(c||{});const d={adaptive:!0,maxLength:10,minSegments:8,maxSegments:2048,epsilon:1e-4,_segmentsCount(t,s=20){if(!this.adaptive||!t||isNaN(t))return s;let e=Math.ceil(t/this.maxLength);return e<this.minSegments?e=this.minSegments:e>this.maxSegments&&(e=this.maxSegments),e}},u=d;class m{static curveTo(t,s,e,i,h,n){const r=n[n.length-2],a=n[n.length-1]-s,l=r-t,o=i-s,c=e-t,d=Math.abs(a*c-l*o);if(d<1e-8||0===h)return(n[n.length-2]!==t||n[n.length-1]!==s)&&n.push(t,s),null;const u=a*a+l*l,m=o*o+c*c,p=a*o+l*c,g=h*Math.sqrt(u)/d,f=h*Math.sqrt(m)/d,b=g*p/u,x=f*p/m,y=g*c+f*l,_=g*o+f*a,w=l*(f+b),v=a*(f+b),M=c*(g+x),T=o*(g+x);return{cx:y+t,cy:_+s,radius:h,startAngle:Math.atan2(v-_,w-y),endAngle:Math.atan2(T-_,M-y),anticlockwise:l*o>c*a}}static arc(t,s,e,h,n,r,a,l,o){const c=a-r,u=d._segmentsCount(Math.abs(c)*n,40*Math.ceil(Math.abs(c)/i.TO)),m=c/(2*u),p=2*m,g=Math.cos(m),f=Math.sin(m),b=u-1,x=b%1/b;for(let t=0;t<=b;++t){const s=m+r+p*(t+x*t),i=Math.cos(s),a=-Math.sin(s);o.push((g*i+f*a)*n+e,(g*-a+f*i)*n+h)}}}class p{static curveLength(t,s,e,i,h,n,r,a){let l=0,o=0,c=0,d=0,u=0,m=0,p=0,g=0,f=0,b=0,x=0,y=t,_=s;for(let w=1;w<=10;++w)o=w/10,c=o*o,d=c*o,u=1-o,m=u*u,p=m*u,g=p*t+3*m*o*e+3*u*c*h+d*r,f=p*s+3*m*o*i+3*u*c*n+d*a,b=y-g,x=_-f,y=g,_=f,l+=Math.sqrt(b*b+x*x);return l}static curveTo(t,s,e,i,h,n,r){const a=r[r.length-2],l=r[r.length-1];r.length-=2;const o=d._segmentsCount(p.curveLength(a,l,t,s,e,i,h,n));let c=0,u=0,m=0,g=0,f=0;r.push(a,l);for(let d=1,p=0;d<=o;++d)p=d/o,c=1-p,u=c*c,m=u*c,g=p*p,f=g*p,r.push(m*a+3*u*p*t+3*c*g*e+f*h,m*l+3*u*p*s+3*c*g*i+f*n)}}function g(t,s,e,i,h,n,r,a){let l,o;r?(l=i,o=-e):(l=-i,o=e);const c=t-e*h+l,d=s-i*h+o,u=t+e*n+l,m=s+i*n+o;return a.push(c,d,u,m),2}function f(t,s,e,i,h,n,r,a){const l=e-t,o=i-s;let c=Math.atan2(l,o),d=Math.atan2(h-t,n-s);a&&c<d?c+=2*Math.PI:!a&&c>d&&(d+=2*Math.PI);let u=c;const m=d-c,p=Math.abs(m),g=Math.sqrt(l*l+o*o),f=1+(15*p*Math.sqrt(g)/Math.PI|0),b=m/f;if(u+=b,a){r.push(t,s,e,i);for(let e=1,i=u;e<f;e++,i+=b)r.push(t,s,t+Math.sin(i)*g,s+Math.cos(i)*g);r.push(t,s,h,n)}else{r.push(e,i,t,s);for(let e=1,i=u;e<f;e++,i+=b)r.push(t+Math.sin(i)*g,s+Math.cos(i)*g,t,s);r.push(h,n,t,s)}return 2*f}function b(t,s){t.lineStyle.native?function(t,s){let e=0;const h=t.shape,n=t.points||h.points,r=h.type!==i.HY.POLY||h.closeStroke;if(0===n.length)return;const a=s.points,l=s.indices,o=n.length/2,c=a.length/2;let d=c;for(a.push(n[0],n[1]),e=1;e<o;e++)a.push(n[2*e],n[2*e+1]),l.push(d,d+1),d++;r&&l.push(d,c)}(t,s):function(t,s){const e=t.shape;let h=t.points||e.points.slice();const n=s.closePointEps;if(0===h.length)return;const r=t.lineStyle,a=new i.bR(h[0],h[1]),l=new i.bR(h[h.length-2],h[h.length-1]),u=e.type!==i.HY.POLY||e.closeStroke,m=Math.abs(a.x-l.x)<n&&Math.abs(a.y-l.y)<n;if(u){h=h.slice(),m&&(h.pop(),h.pop(),l.set(h[h.length-2],h[h.length-1]));const t=.5*(a.x+l.x),s=.5*(l.y+a.y);h.unshift(t,s),h.push(t,s)}const p=s.points,b=h.length/2;let x=h.length;const y=p.length/2,_=r.width/2,w=_*_,v=r.miterLimit*r.miterLimit;let M=h[0],T=h[1],C=h[2],D=h[3],P=0,S=0,I=-(T-D),Y=M-C,A=0,B=0,R=Math.sqrt(I*I+Y*Y);I/=R,Y/=R,I*=_,Y*=_;const X=r.alignment,E=2*(1-X),k=2*X;u||(r.cap===c.ROUND?x+=f(M-I*(E-k)*.5,T-Y*(E-k)*.5,M-I*E,T-Y*E,M+I*k,T+Y*k,p,!0)+2:r.cap===c.SQUARE&&(x+=g(M,T,I,Y,E,k,!0,p))),p.push(M-I*E,T-Y*E,M+I*k,T+Y*k);for(let t=1;t<b-1;++t){M=h[2*(t-1)],T=h[2*(t-1)+1],C=h[2*t],D=h[2*t+1],P=h[2*(t+1)],S=h[2*(t+1)+1],I=-(T-D),Y=M-C,R=Math.sqrt(I*I+Y*Y),I/=R,Y/=R,I*=_,Y*=_,A=-(D-S),B=C-P,R=Math.sqrt(A*A+B*B),A/=R,B/=R,A*=_,B*=_;const s=C-M,e=T-D,i=C-P,n=S-D,a=s*i+e*n,l=e*i-n*s,c=l<0;if(Math.abs(l)<.001*Math.abs(a)){p.push(C-I*E,D-Y*E,C+I*k,D+Y*k),a>=0&&(r.join===o.ROUND?x+=f(C,D,C-I*E,D-Y*E,C-A*E,D-B*E,p,!1)+4:x+=2,p.push(C-A*k,D-B*k,C+A*E,D+B*E));continue}const d=(-I+M)*(-Y+D)-(-I+C)*(-Y+T),u=(-A+P)*(-B+D)-(-A+C)*(-B+S),m=(s*u-i*d)/l,g=(n*d-e*u)/l,b=(m-C)*(m-C)+(g-D)*(g-D),y=C+(m-C)*E,X=D+(g-D)*E,O=C-(m-C)*k,L=D-(g-D)*k,U=c?E:k,j=b<=Math.min(s*s+e*e,i*i+n*n)+U*U*w;let F=r.join;if(F===o.MITER&&b/w>v&&(F=o.BEVEL),j)switch(F){case o.MITER:p.push(y,X,O,L);break;case o.BEVEL:c?p.push(y,X,C+I*k,D+Y*k,y,X,C+A*k,D+B*k):p.push(C-I*E,D-Y*E,O,L,C-A*E,D-B*E,O,L),x+=2;break;case o.ROUND:c?(p.push(y,X,C+I*k,D+Y*k),x+=f(C,D,C+I*k,D+Y*k,C+A*k,D+B*k,p,!0)+4,p.push(y,X,C+A*k,D+B*k)):(p.push(C-I*E,D-Y*E,O,L),x+=f(C,D,C-I*E,D-Y*E,C-A*E,D-B*E,p,!1)+4,p.push(C-A*E,D-B*E,O,L))}else{switch(p.push(C-I*E,D-Y*E,C+I*k,D+Y*k),F){case o.MITER:c?p.push(O,L,O,L):p.push(y,X,y,X),x+=2;break;case o.ROUND:x+=c?f(C,D,C+I*k,D+Y*k,C+A*k,D+B*k,p,!0)+2:f(C,D,C-I*E,D-Y*E,C-A*E,D-B*E,p,!1)+2}p.push(C-A*E,D-B*E,C+A*k,D+B*k),x+=2}}M=h[2*(b-2)],T=h[2*(b-2)+1],C=h[2*(b-1)],D=h[2*(b-1)+1],I=-(T-D),Y=M-C,R=Math.sqrt(I*I+Y*Y),I/=R,Y/=R,I*=_,Y*=_,p.push(C-I*E,D-Y*E,C+I*k,D+Y*k),u||(r.cap===c.ROUND?x+=f(C-I*(E-k)*.5,D-Y*(E-k)*.5,C-I*E,D-Y*E,C+I*k,D+Y*k,p,!1)+2:r.cap===c.SQUARE&&(x+=g(C,D,I,Y,E,k,!1,p)));const O=s.indices,L=d.epsilon*d.epsilon;for(let t=y;t<x+y-2;++t)M=p[2*t],T=p[2*t+1],C=p[2*(t+1)],D=p[2*(t+1)+1],P=p[2*(t+2)],S=p[2*(t+2)+1],!(Math.abs(M*(D-S)+C*(S-T)+P*(T-D))<L)&&O.push(t,t+1,t+2)}(t,s)}class x{static curveLength(t,s,e,i,h,n){const r=t-2*e+h,a=s-2*i+n,l=2*e-2*t,o=2*i-2*s,c=4*(r*r+a*a),d=4*(r*l+a*o),u=l*l+o*o,m=2*Math.sqrt(c+d+u),p=Math.sqrt(c),g=2*c*p,f=2*Math.sqrt(u),b=d/p;return(g*m+p*d*(m-f)+(4*u*c-d*d)*Math.log((2*p+b+m)/(b+f)))/(4*g)}static curveTo(t,s,e,i,h){const n=h[h.length-2],r=h[h.length-1],a=d._segmentsCount(x.curveLength(n,r,t,s,e,i));let l=0,o=0;for(let c=1;c<=a;++c){const d=c/a;l=n+(t-n)*d,o=r+(s-r)*d,h.push(l+(t+(e-t)*d-l)*d,o+(s+(i-s)*d-o)*d)}}}const y={[i.HY.POLY]:r,[i.HY.CIRC]:h,[i.HY.ELIP]:h,[i.HY.RECT]:a,[i.HY.RREC]:l},_=[],w=[];var v=e("./node_modules/@pixi/display/lib/index.mjs");class M{constructor(t,s=null,e=null,i=null){this.points=[],this.holes=[],this.shape=t,this.lineStyle=e,this.fillStyle=s,this.matrix=i,this.type=t.type}clone(){return new M(this.shape,this.fillStyle,this.lineStyle,this.matrix)}destroy(){this.shape=null,this.holes.length=0,this.holes=null,this.points.length=0,this.points=null,this.lineStyle=null,this.fillStyle=null}}class T{constructor(){this.reset()}begin(t,s,e){this.reset(),this.style=t,this.start=s,this.attribStart=e}end(t,s){this.attribSize=s-this.attribStart,this.size=t-this.start}reset(){this.style=null,this.size=0,this.start=0,this.attribStart=0,this.attribSize=0}}const C=new i.bR,D=class t extends i.JH{constructor(){super(),this.closePointEps=1e-4,this.boundsPadding=0,this.uvsFloat32=null,this.indicesUint16=null,this.batchable=!1,this.points=[],this.colors=[],this.uvs=[],this.indices=[],this.textureIds=[],this.graphicsData=[],this.drawCalls=[],this.batchDirty=-1,this.batches=[],this.dirty=0,this.cacheDirty=-1,this.clearDirty=0,this.shapeIndex=0,this._bounds=new v.cz,this.boundsDirty=-1}get bounds(){return this.updateBatches(),this.boundsDirty!==this.dirty&&(this.boundsDirty=this.dirty,this.calculateBounds()),this._bounds}invalidate(){this.boundsDirty=-1,this.dirty++,this.batchDirty++,this.shapeIndex=0,this.points.length=0,this.colors.length=0,this.uvs.length=0,this.indices.length=0,this.textureIds.length=0;for(let t=0;t<this.drawCalls.length;t++)this.drawCalls[t].texArray.clear(),w.push(this.drawCalls[t]);this.drawCalls.length=0;for(let t=0;t<this.batches.length;t++){const s=this.batches[t];s.reset(),_.push(s)}this.batches.length=0}clear(){return this.graphicsData.length>0&&(this.invalidate(),this.clearDirty++,this.graphicsData.length=0),this}drawShape(t,s=null,e=null,i=null){const h=new M(t,s,e,i);return this.graphicsData.push(h),this.dirty++,this}drawHole(t,s=null){if(!this.graphicsData.length)return null;const e=new M(t,null,null,s),i=this.graphicsData[this.graphicsData.length-1];return e.lineStyle=i.lineStyle,i.holes.push(e),this.dirty++,this}destroy(){super.destroy();for(let t=0;t<this.graphicsData.length;++t)this.graphicsData[t].destroy();this.points.length=0,this.points=null,this.colors.length=0,this.colors=null,this.uvs.length=0,this.uvs=null,this.indices.length=0,this.indices=null,this.indexBuffer.destroy(),this.indexBuffer=null,this.graphicsData.length=0,this.graphicsData=null,this.drawCalls.length=0,this.drawCalls=null,this.batches.length=0,this.batches=null,this._bounds=null}containsPoint(t){const s=this.graphicsData;for(let e=0;e<s.length;++e){const i=s[e];if(i.fillStyle.visible&&i.shape&&(i.matrix?i.matrix.applyInverse(t,C):C.copyFrom(t),i.shape.contains(C.x,C.y))){let t=!1;if(i.holes)for(let s=0;s<i.holes.length;s++)if(i.holes[s].shape.contains(C.x,C.y)){t=!0;break}if(!t)return!0}}return!1}updateBatches(){if(!this.graphicsData.length)return void(this.batchable=!0);if(!this.validateBatching())return;this.cacheDirty=this.dirty;const t=this.uvs,s=this.graphicsData;let e=null,h=null;this.batches.length>0&&(e=this.batches[this.batches.length-1],h=e.style);for(let n=this.shapeIndex;n<s.length;n++){this.shapeIndex++;const r=s[n],a=r.fillStyle,l=r.lineStyle;y[r.type].build(r),r.matrix&&this.transformPoints(r.points,r.matrix),(a.visible||l.visible)&&this.processHoles(r.holes);for(let s=0;s<2;s++){const n=0===s?a:l;if(!n.visible)continue;const o=n.texture.baseTexture,c=this.indices.length,d=this.points.length/2;o.wrapMode=i.uR.REPEAT,0===s?this.processFill(r):this.processLine(r);const u=this.points.length/2-d;0!==u&&(e&&!this._compareStyles(h,n)&&(e.end(c,d),e=null),e||(e=_.pop()||new T,e.begin(n,c,d),this.batches.push(e),h=n),this.addUvs(this.points,t,n.texture,d,u,n.matrix))}}const n=this.indices.length,r=this.points.length/2;if(e&&e.end(n,r),0===this.batches.length)return void(this.batchable=!0);const a=r>65535;this.indicesUint16&&this.indices.length===this.indicesUint16.length&&a===this.indicesUint16.BYTES_PER_ELEMENT>2?this.indicesUint16.set(this.indices):this.indicesUint16=a?new Uint32Array(this.indices):new Uint16Array(this.indices),this.batchable=this.isBatchable(),this.batchable?this.packBatches():this.buildDrawCalls()}_compareStyles(t,s){return!(!t||!s||t.texture.baseTexture!==s.texture.baseTexture||t.color+t.alpha!==s.color+s.alpha||!!t.native!=!!s.native)}validateBatching(){if(this.dirty===this.cacheDirty||!this.graphicsData.length)return!1;for(let t=0,s=this.graphicsData.length;t<s;t++){const s=this.graphicsData[t],e=s.fillStyle,i=s.lineStyle;if(e&&!e.texture.baseTexture.valid||i&&!i.texture.baseTexture.valid)return!1}return!0}packBatches(){this.batchDirty++,this.uvsFloat32=new Float32Array(this.uvs);const t=this.batches;for(let s=0,e=t.length;s<e;s++){const e=t[s];for(let t=0;t<e.size;t++){const s=e.start+t;this.indicesUint16[s]=this.indicesUint16[s]-e.attribStart}}}isBatchable(){if(this.points.length>131070)return!1;const s=this.batches;for(let t=0;t<s.length;t++)if(s[t].style.native)return!1;return this.points.length<2*t.BATCHABLE_SIZE}buildDrawCalls(){let t=++i.t5._globalBatch;for(let t=0;t<this.drawCalls.length;t++)this.drawCalls[t].texArray.clear(),w.push(this.drawCalls[t]);this.drawCalls.length=0;const s=this.colors,e=this.textureIds;let h=w.pop();h||(h=new i.hq,h.texArray=new i.cc),h.texArray.count=0,h.start=0,h.size=0,h.type=i._4.TRIANGLES;let n=0,r=null,a=0,l=!1,o=i._4.TRIANGLES,c=0;this.drawCalls.push(h);for(let d=0;d<this.batches.length;d++){const u=this.batches[d],m=8,p=u.style,g=p.texture.baseTexture;l!==!!p.native&&(l=!!p.native,o=l?i._4.LINES:i._4.TRIANGLES,r=null,n=m,t++),r!==g&&(r=g,g._batchEnabled!==t&&(n===m&&(t++,n=0,h.size>0&&(h=w.pop(),h||(h=new i.hq,h.texArray=new i.cc),this.drawCalls.push(h)),h.start=c,h.size=0,h.texArray.count=0,h.type=o),g.touched=1,g._batchEnabled=t,g._batchLocation=n,g.wrapMode=i.uR.REPEAT,h.texArray.elements[h.texArray.count++]=g,n++)),h.size+=u.size,c+=u.size,a=g._batchLocation,this.addColors(s,p.color,p.alpha,u.attribSize,u.attribStart),this.addTextureIds(e,a,u.attribSize,u.attribStart)}i.t5._globalBatch=t,this.packAttributes()}packAttributes(){const t=this.points,s=this.uvs,e=this.colors,i=this.textureIds,h=new ArrayBuffer(3*t.length*4),n=new Float32Array(h),r=new Uint32Array(h);let a=0;for(let h=0;h<t.length/2;h++)n[a++]=t[2*h],n[a++]=t[2*h+1],n[a++]=s[2*h],n[a++]=s[2*h+1],r[a++]=e[h],n[a++]=i[h];this._buffer.update(h),this._indexBuffer.update(this.indicesUint16)}processFill(t){t.holes.length?r.triangulate(t,this):y[t.type].triangulate(t,this)}processLine(t){b(t,this);for(let s=0;s<t.holes.length;s++)b(t.holes[s],this)}processHoles(t){for(let s=0;s<t.length;s++){const e=t[s];y[e.type].build(e),e.matrix&&this.transformPoints(e.points,e.matrix)}}calculateBounds(){const t=this._bounds;t.clear(),t.addVertexData(this.points,0,this.points.length),t.pad(this.boundsPadding,this.boundsPadding)}transformPoints(t,s){for(let e=0;e<t.length/2;e++){const i=t[2*e],h=t[2*e+1];t[2*e]=s.a*i+s.c*h+s.tx,t[2*e+1]=s.b*i+s.d*h+s.ty}}addColors(t,s,e,h,n=0){const r=i.Q1.shared.setValue(s).toLittleEndianNumber(),a=i.Q1.shared.setValue(r).toPremultiplied(e);t.length=Math.max(t.length,n+h);for(let s=0;s<h;s++)t[n+s]=a}addTextureIds(t,s,e,i=0){t.length=Math.max(t.length,i+e);for(let h=0;h<e;h++)t[i+h]=s}addUvs(t,s,e,i,h,n=null){let r=0;const a=s.length,l=e.frame;for(;r<h;){let e=t[2*(i+r)],h=t[2*(i+r)+1];if(n){const t=n.a*e+n.c*h+n.tx;h=n.b*e+n.d*h+n.ty,e=t}r++,s.push(e/l.width,h/l.height)}const o=e.baseTexture;(l.width<o.width||l.height<o.height)&&this.adjustUvs(s,e,a,h)}adjustUvs(t,s,e,i){const h=s.baseTexture,n=1e-6,r=e+2*i,a=s.frame,l=a.width/h.width,o=a.height/h.height;let c=a.x/a.width,d=a.y/a.height,u=Math.floor(t[e]+n),m=Math.floor(t[e+1]+n);for(let s=e+2;s<r;s+=2)u=Math.min(u,Math.floor(t[s]+n)),m=Math.min(m,Math.floor(t[s+1]+n));c-=u,d-=m;for(let s=e;s<r;s+=2)t[s]=(t[s]+c)*l,t[s+1]=(t[s+1]+d)*o}};D.BATCHABLE_SIZE=100;let P=D;class S{constructor(){this.color=16777215,this.alpha=1,this.texture=i.gP.WHITE,this.matrix=null,this.visible=!1,this.reset()}clone(){const t=new S;return t.color=this.color,t.alpha=this.alpha,t.texture=this.texture,t.matrix=this.matrix,t.visible=this.visible,t}reset(){this.color=16777215,this.alpha=1,this.texture=i.gP.WHITE,this.matrix=null,this.visible=!1}destroy(){this.texture=null,this.matrix=null}}class I extends S{constructor(){super(...arguments),this.width=0,this.alignment=.5,this.native=!1,this.cap=c.BUTT,this.join=o.MITER,this.miterLimit=10}clone(){const t=new I;return t.color=this.color,t.alpha=this.alpha,t.texture=this.texture,t.matrix=this.matrix,t.visible=this.visible,t.width=this.width,t.alignment=this.alignment,t.native=this.native,t.cap=this.cap,t.join=this.join,t.miterLimit=this.miterLimit,t}reset(){super.reset(),this.color=0,this.alignment=.5,this.width=0,this.native=!1,this.cap=c.BUTT,this.join=o.MITER,this.miterLimit=10}}const Y={},A=class t extends v.mc{constructor(t=null){super(),this.shader=null,this.pluginName="batch",this.currentPath=null,this.batches=[],this.batchTint=-1,this.batchDirty=-1,this.vertexData=null,this._fillStyle=new S,this._lineStyle=new I,this._matrix=null,this._holeMode=!1,this.state=i.Uw.for2d(),this._geometry=t||new P,this._geometry.refCount++,this._transformID=-1,this._tintColor=new i.Q1(16777215),this.blendMode=i.B9.NORMAL}get geometry(){return this._geometry}clone(){return this.finishPoly(),new t(this._geometry)}set blendMode(t){this.state.blendMode=t}get blendMode(){return this.state.blendMode}get tint(){return this._tintColor.value}set tint(t){this._tintColor.setValue(t)}get fill(){return this._fillStyle}get line(){return this._lineStyle}lineStyle(t=null,s=0,e,i=.5,h=!1){return"number"==typeof t&&(t={width:t,color:s,alpha:e,alignment:i,native:h}),this.lineTextureStyle(t)}lineTextureStyle(t){const s={width:0,texture:i.gP.WHITE,color:t?.texture?16777215:0,matrix:null,alignment:.5,native:!1,cap:c.BUTT,join:o.MITER,miterLimit:10};t=Object.assign(s,t),this.normalizeColor(t),this.currentPath&&this.startPoly();const e=t.width>0&&t.alpha>0;return e?(t.matrix&&(t.matrix=t.matrix.clone(),t.matrix.invert()),Object.assign(this._lineStyle,{visible:e},t)):this._lineStyle.reset(),this}startPoly(){if(this.currentPath){const t=this.currentPath.points,s=this.currentPath.points.length;s>2&&(this.drawShape(this.currentPath),this.currentPath=new i.tS,this.currentPath.closeStroke=!1,this.currentPath.points.push(t[s-2],t[s-1]))}else this.currentPath=new i.tS,this.currentPath.closeStroke=!1}finishPoly(){this.currentPath&&(this.currentPath.points.length>2?(this.drawShape(this.currentPath),this.currentPath=null):this.currentPath.points.length=0)}moveTo(t,s){return this.startPoly(),this.currentPath.points[0]=t,this.currentPath.points[1]=s,this}lineTo(t,s){this.currentPath||this.moveTo(0,0);const e=this.currentPath.points,i=e[e.length-2],h=e[e.length-1];return(i!==t||h!==s)&&e.push(t,s),this}_initCurve(t=0,s=0){this.currentPath?0===this.currentPath.points.length&&(this.currentPath.points=[t,s]):this.moveTo(t,s)}quadraticCurveTo(t,s,e,i){this._initCurve();const h=this.currentPath.points;return 0===h.length&&this.moveTo(0,0),x.curveTo(t,s,e,i,h),this}bezierCurveTo(t,s,e,i,h,n){return this._initCurve(),p.curveTo(t,s,e,i,h,n,this.currentPath.points),this}arcTo(t,s,e,i,h){this._initCurve(t,s);const n=this.currentPath.points,r=m.curveTo(t,s,e,i,h,n);if(r){const{cx:t,cy:s,radius:e,startAngle:i,endAngle:h,anticlockwise:n}=r;this.arc(t,s,e,i,h,n)}return this}arc(t,s,e,h,n,r=!1){if(h===n)return this;if(!r&&n<=h?n+=i.TO:r&&h<=n&&(h+=i.TO),n-h==0)return this;const a=t+Math.cos(h)*e,l=s+Math.sin(h)*e,o=this._geometry.closePointEps;let c=this.currentPath?this.currentPath.points:null;if(c){const t=Math.abs(c[c.length-2]-a),s=Math.abs(c[c.length-1]-l);t<o&&s<o||c.push(a,l)}else this.moveTo(a,l),c=this.currentPath.points;return m.arc(a,l,t,s,e,h,n,r,c),this}beginFill(t=0,s){return this.beginTextureFill({texture:i.gP.WHITE,color:t,alpha:s})}normalizeColor(t){const s=i.Q1.shared.setValue(t.color??0);t.color=s.toNumber(),t.alpha??(t.alpha=s.alpha)}beginTextureFill(t){const s={texture:i.gP.WHITE,color:16777215,matrix:null};t=Object.assign(s,t),this.normalizeColor(t),this.currentPath&&this.startPoly();const e=t.alpha>0;return e?(t.matrix&&(t.matrix=t.matrix.clone(),t.matrix.invert()),Object.assign(this._fillStyle,{visible:e},t)):this._fillStyle.reset(),this}endFill(){return this.finishPoly(),this._fillStyle.reset(),this}drawRect(t,s,e,h){return this.drawShape(new i.M_(t,s,e,h))}drawRoundedRect(t,s,e,h,n){return this.drawShape(new i.TE(t,s,e,h,n))}drawCircle(t,s,e){return this.drawShape(new i.jl(t,s,e))}drawEllipse(t,s,e,h){return this.drawShape(new i.Pp(t,s,e,h))}drawPolygon(...t){let s,e=!0;const h=t[0];h.points?(e=h.closeStroke,s=h.points):s=Array.isArray(t[0])?t[0]:t;const n=new i.tS(s);return n.closeStroke=e,this.drawShape(n),this}drawShape(t){return this._holeMode?this._geometry.drawHole(t,this._matrix):this._geometry.drawShape(t,this._fillStyle.clone(),this._lineStyle.clone(),this._matrix),this}clear(){return this._geometry.clear(),this._lineStyle.reset(),this._fillStyle.reset(),this._boundsID++,this._matrix=null,this._holeMode=!1,this.currentPath=null,this}isFastRect(){const t=this._geometry.graphicsData;return!(1!==t.length||t[0].shape.type!==i.HY.RECT||t[0].matrix||t[0].holes.length||t[0].lineStyle.visible&&t[0].lineStyle.width)}_render(t){this.finishPoly();const s=this._geometry;s.updateBatches(),s.batchable?(this.batchDirty!==s.batchDirty&&this._populateBatches(),this._renderBatched(t)):(t.batch.flush(),this._renderDirect(t))}_populateBatches(){const t=this._geometry,s=this.blendMode,e=t.batches.length;this.batchTint=-1,this._transformID=-1,this.batchDirty=t.batchDirty,this.batches.length=e,this.vertexData=new Float32Array(t.points);for(let h=0;h<e;h++){const e=t.batches[h],n=e.style.color,r=new Float32Array(this.vertexData.buffer,4*e.attribStart*2,2*e.attribSize),a=new Float32Array(t.uvsFloat32.buffer,4*e.attribStart*2,2*e.attribSize),l={vertexData:r,blendMode:s,indices:new Uint16Array(t.indicesUint16.buffer,2*e.start,e.size),uvs:a,_batchRGB:i.Q1.shared.setValue(n).toRgbArray(),_tintRGB:n,_texture:e.style.texture,alpha:e.style.alpha,worldAlpha:1};this.batches[h]=l}}_renderBatched(t){if(this.batches.length){t.batch.setObjectRenderer(t.plugins[this.pluginName]),this.calculateVertices(),this.calculateTints();for(let s=0,e=this.batches.length;s<e;s++){const e=this.batches[s];e.worldAlpha=this.worldAlpha*e.alpha,t.plugins[this.pluginName].render(e)}}}_renderDirect(t){const s=this._resolveDirectShader(t),e=this._geometry,h=this.worldAlpha,n=s.uniforms,r=e.drawCalls;n.translationMatrix=this.transform.worldTransform,i.Q1.shared.setValue(this._tintColor).premultiply(h).toArray(n.tint),t.shader.bind(s),t.geometry.bind(e,s),t.state.set(this.state);for(let s=0,i=r.length;s<i;s++)this._renderDrawCallDirect(t,e.drawCalls[s])}_renderDrawCallDirect(t,s){const{texArray:e,type:i,size:h,start:n}=s,r=e.count;for(let s=0;s<r;s++)t.texture.bind(e.elements[s],s);t.geometry.draw(i,h,n)}_resolveDirectShader(t){let s=this.shader;const e=this.pluginName;if(!s){if(!Y[e]){const{maxTextures:s}=t.plugins[e],h=new Int32Array(s);for(let t=0;t<s;t++)h[t]=t;const n={tint:new Float32Array([1,1,1,1]),translationMatrix:new i.uq,default:i.k2.from({uSamplers:h},!0)},r=t.plugins[e]._shader.program;Y[e]=new i.Mt(r,n)}s=Y[e]}return s}_calculateBounds(){this.finishPoly();const t=this._geometry;if(!t.graphicsData.length)return;const{minX:s,minY:e,maxX:i,maxY:h}=t.bounds;this._bounds.addFrame(this.transform,s,e,i,h)}containsPoint(s){return this.worldTransform.applyInverse(s,t._TEMP_POINT),this._geometry.containsPoint(t._TEMP_POINT)}calculateTints(){if(this.batchTint!==this.tint){this.batchTint=this._tintColor.toNumber();for(let t=0;t<this.batches.length;t++){const s=this.batches[t];s._tintRGB=i.Q1.shared.setValue(this._tintColor).multiply(s._batchRGB).toLittleEndianNumber()}}}calculateVertices(){const t=this.transform._worldID;if(this._transformID===t)return;this._transformID=t;const s=this.transform.worldTransform,e=s.a,i=s.b,h=s.c,n=s.d,r=s.tx,a=s.ty,l=this._geometry.points,o=this.vertexData;let c=0;for(let t=0;t<l.length;t+=2){const s=l[t],d=l[t+1];o[c++]=e*s+h*d+r,o[c++]=n*d+i*s+a}}closePath(){const t=this.currentPath;return t&&(t.closeStroke=!0,this.finishPoly()),this}setMatrix(t){return this._matrix=t,this}beginHole(){return this.finishPoly(),this._holeMode=!0,this}endHole(){return this.finishPoly(),this._holeMode=!1,this}destroy(t){this._geometry.refCount--,0===this._geometry.refCount&&this._geometry.dispose(),this._matrix=null,this.currentPath=null,this._lineStyle.destroy(),this._lineStyle=null,this._fillStyle.destroy(),this._fillStyle=null,this._geometry=null,this.shader=null,this.vertexData=null,this.batches.length=0,this.batches=null,super.destroy(t)}};A.curves=d,A._TEMP_POINT=new i.bR;let B=A;const R={buildPoly:r,buildCircle:h,buildRectangle:a,buildRoundedRectangle:l,buildLine:b,ArcUtils:m,BezierUtils:p,QuadraticUtils:x,BatchPart:T,FILL_COMMANDS:y,BATCH_POOL:_,DRAW_CALL_POOL:w}}}]);