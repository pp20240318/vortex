"use strict";(self.webpackChunkfederation_clients=self.webpackChunkfederation_clients||[]).push([["vendors-node_modules_pixi-spine_base_lib_index_mjs"],{"./node_modules/@pixi-spine/base/lib/index.mjs":(e,t,n)=>{n.d(t,{wh:()=>i,aG:()=>r,Q1:()=>S,lw:()=>N,ON:()=>C,lc:()=>R,cj:()=>I,qU:()=>s,mj:()=>a,bC:()=>B,pw:()=>o,py:()=>L,Ff:()=>k,Dr:()=>l,S3:()=>D,bJ:()=>j,Go:()=>q,BO:()=>H,pK:()=>G,eE:()=>M,Lw:()=>b,gB:()=>x,TE:()=>y,O$:()=>g,QL:()=>m,w3:()=>p,oM:()=>E,_C:()=>h,Aq:()=>P,I9:()=>_,p0:()=>F,ki:()=>c,W0:()=>Y,iG:()=>d});var i=(e=>(e[e.Region=0]="Region",e[e.BoundingBox=1]="BoundingBox",e[e.Mesh=2]="Mesh",e[e.LinkedMesh=3]="LinkedMesh",e[e.Path=4]="Path",e[e.Point=5]="Point",e[e.Clipping=6]="Clipping",e))(i||{});class r{constructor(e,t=new Array,n=0,i=new DataView(e.buffer)){this.strings=t,this.index=n,this.buffer=i}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const e=this.buffer.getInt16(this.index);return this.index+=2,e}readInt32(){const e=this.buffer.getInt32(this.index);return this.index+=4,e}readInt(e){let t=this.readByte(),n=127&t;return 128&t&&(t=this.readByte(),n|=(127&t)<<7,128&t&&(t=this.readByte(),n|=(127&t)<<14,128&t&&(t=this.readByte(),n|=(127&t)<<21,128&t&&(t=this.readByte(),n|=(127&t)<<28)))),e?n:n>>>1^-(1&n)}readStringRef(){const e=this.readInt(!0);return 0==e?null:this.strings[e-1]}readString(){let e=this.readInt(!0);switch(e){case 0:return null;case 1:return""}e--;let t="";for(let n=0;n<e;){const e=this.readUnsignedByte();switch(e>>4){case 12:case 13:t+=String.fromCharCode((31&e)<<6|63&this.readByte()),n+=2;break;case 14:t+=String.fromCharCode((15&e)<<12|(63&this.readByte())<<6|63&this.readByte()),n+=3;break;default:t+=String.fromCharCode(e),n++}}return t}readFloat(){const e=this.buffer.getFloat32(this.index);return this.index+=4,e}readBoolean(){return 0!=this.readByte()}}var s=(e=>(e[e.setup=0]="setup",e[e.first=1]="first",e[e.replace=2]="replace",e[e.add=3]="add",e))(s||{}),a=(e=>(e[e.mixIn=0]="mixIn",e[e.mixOut=1]="mixOut",e))(a||{}),o=(e=>(e[e.Fixed=0]="Fixed",e[e.Percent=1]="Percent",e))(o||{}),l=(e=>(e[e.Tangent=0]="Tangent",e[e.Chain=1]="Chain",e[e.ChainScale=2]="ChainScale",e))(l||{}),h=(e=>(e[e.Normal=0]="Normal",e[e.OnlyTranslation=1]="OnlyTranslation",e[e.NoRotationOrReflection=2]="NoRotationOrReflection",e[e.NoScale=3]="NoScale",e[e.NoScaleOrReflection=4]="NoScaleOrReflection",e))(h||{}),u=n("./node_modules/@pixi/core/lib/index.mjs");function c(e){switch(e.toLowerCase()){case"nearest":return g.Nearest;case"linear":return g.Linear;case"mipmap":return g.MipMap;case"mipmapnearestnearest":return g.MipMapNearestNearest;case"mipmaplinearnearest":return g.MipMapLinearNearest;case"mipmapnearestlinear":return g.MipMapNearestLinear;case"mipmaplinearlinear":return g.MipMapLinearLinear;default:throw new Error(`Unknown texture filter ${e}`)}}function d(e){switch(e.toLowerCase()){case"mirroredtepeat":return p.MirroredRepeat;case"clamptoedge":return p.ClampToEdge;case"repeat":return p.Repeat;default:throw new Error(`Unknown texture wrap ${e}`)}}var g=(e=>(e[e.Nearest=9728]="Nearest",e[e.Linear=9729]="Linear",e[e.MipMap=9987]="MipMap",e[e.MipMapNearestNearest=9984]="MipMapNearestNearest",e[e.MipMapLinearNearest=9985]="MipMapLinearNearest",e[e.MipMapNearestLinear=9986]="MipMapNearestLinear",e[e.MipMapLinearLinear=9987]="MipMapLinearLinear",e))(g||{}),p=(e=>(e[e.MirroredRepeat=33648]="MirroredRepeat",e[e.ClampToEdge=33071]="ClampToEdge",e[e.Repeat=10497]="Repeat",e))(p||{});class m{constructor(){this.size=null,this.names=null,this.values=null,this.renderObject=null}get width(){const e=this.texture;return e.trim?e.trim.width:e.orig.width}get height(){const e=this.texture;return e.trim?e.trim.height:e.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const e=this.texture;return e.trim?e.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const e=this.texture;return e.trim?e.trim.y:0}get spineOffsetY(){const e=this.texture;return this.originalHeight-this.height-(e.trim?e.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return 0!==this.texture.rotate}get degrees(){return(360-45*this.texture.rotate)%360}}class f{constructor(){this.x=0,this.y=0,this.width=0,this.height=0,this.offsetX=0,this.offsetY=0,this.originalWidth=0,this.originalHeight=0,this.rotate=0,this.index=0}}class b{constructor(e,t,n){this.pages=new Array,this.regions=new Array,e&&this.addSpineAtlas(e,t,n)}addTexture(e,t){const n=this.pages;let i=null;for(let e=0;e<n.length;e++)if(n[e].baseTexture===t.baseTexture){i=n[e];break}if(null===i){i=new x,i.name="texturePage";const e=t.baseTexture;i.width=e.realWidth,i.height=e.realHeight,i.baseTexture=e,i.minFilter=i.magFilter=g.Nearest,i.uWrap=p.ClampToEdge,i.vWrap=p.ClampToEdge,n.push(i)}const r=new y;return r.name=e,r.page=i,r.texture=t,r.index=-1,this.regions.push(r),r}addTextureHash(e,t){for(const n in e)e.hasOwnProperty(n)&&this.addTexture(t&&-1!==n.indexOf(".")?n.substr(0,n.lastIndexOf(".")):n,e[n])}addSpineAtlas(e,t,n){return this.load(e,t,n)}load(e,t,n){if(null==t)throw new Error("textureLoader cannot be null.");const i=new w(e),r=new Array(4);let s=null;const a={};let o=null;a.size=()=>{s.width=parseInt(r[1]),s.height=parseInt(r[2])},a.format=()=>{},a.filter=()=>{s.minFilter=c(r[1]),s.magFilter=c(r[2])},a.repeat=()=>{-1!=r[1].indexOf("x")&&(s.uWrap=p.Repeat),-1!=r[1].indexOf("y")&&(s.vWrap=p.Repeat)},a.pma=()=>{s.pma="true"==r[1]};const l={xy:()=>{o.x=parseInt(r[1]),o.y=parseInt(r[2])},size:()=>{o.width=parseInt(r[1]),o.height=parseInt(r[2])},bounds:()=>{o.x=parseInt(r[1]),o.y=parseInt(r[2]),o.width=parseInt(r[3]),o.height=parseInt(r[4])},offset:()=>{o.offsetX=parseInt(r[1]),o.offsetY=parseInt(r[2])},orig:()=>{o.originalWidth=parseInt(r[1]),o.originalHeight=parseInt(r[2])},offsets:()=>{o.offsetX=parseInt(r[1]),o.offsetY=parseInt(r[2]),o.originalWidth=parseInt(r[3]),o.originalHeight=parseInt(r[4])},rotate:()=>{const e=r[1];let t=0;t="true"==e.toLocaleLowerCase()?6:"false"==e.toLocaleLowerCase()?0:(720-parseFloat(e))%360/45,o.rotate=t},index:()=>{o.index=parseInt(r[1])}};let h=i.readLine();for(;null!=h&&0==h.trim().length;)h=i.readLine();for(;null!=h&&0!=h.trim().length&&0!=i.readEntry(r,h);)h=i.readLine();const d=()=>{for(;;){if(null==h)return n&&n(this);if(0==h.trim().length)s=null,h=i.readLine();else{if(null===s){for(s=new x,s.name=h.trim();0!=i.readEntry(r,h=i.readLine());){const e=a[r[0]];e&&e()}this.pages.push(s),t(s.name,(e=>{if(null===e)return this.pages.splice(this.pages.indexOf(s),1),n&&n(null);s.baseTexture=e,s.pma&&(e.alphaMode=u.Gk.PMA),e.valid||e.setSize(s.width,s.height),s.setFilters(),s.width&&s.height||(s.width=e.realWidth,s.height=e.realHeight,s.width&&s.height||console.log(`ERROR spine atlas page ${s.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`)),d()}));break}{o=new f;const e=new y;e.name=h,e.page=s;let t=null,n=null;for(;;){const e=i.readEntry(r,h=i.readLine());if(0==e)break;const s=l[r[0]];if(s)s();else{null==t&&(t=[],n=[]),t.push(r[0]);const i=[];for(let t=0;t<e;t++)i.push(parseInt(r[t+1]));n.push(i)}}0==o.originalWidth&&0==o.originalHeight&&(o.originalWidth=o.width,o.originalHeight=o.height);const a=s.baseTexture.resolution;o.x/=a,o.y/=a,o.width/=a,o.height/=a,o.originalWidth/=a,o.originalHeight/=a,o.offsetX/=a,o.offsetY/=a;const c=o.rotate%4!=0,d=new u.M_(o.x,o.y,c?o.height:o.width,c?o.width:o.height),g=new u.M_(0,0,o.originalWidth,o.originalHeight),p=new u.M_(o.offsetX,o.originalHeight-o.height-o.offsetY,o.width,o.height);e.texture=new u.gP(e.page.baseTexture,d,g,p,o.rotate),e.index=o.index,e.texture.updateUvs(),this.regions.push(e)}}}};d()}findRegion(e){for(let t=0;t<this.regions.length;t++)if(this.regions[t].name==e)return this.regions[t];return null}dispose(){for(let e=0;e<this.pages.length;e++)this.pages[e].baseTexture.dispose()}}class w{constructor(e){this.index=0,this.lines=e.split(/\r\n|\r|\n/)}readLine(){return this.index>=this.lines.length?null:this.lines[this.index++]}readEntry(e,t){if(null==t)return 0;if(0==(t=t.trim()).length)return 0;const n=t.indexOf(":");if(-1==n)return 0;e[0]=t.substr(0,n).trim();for(let i=1,r=n+1;;i++){const n=t.indexOf(",",r);if(-1==n)return e[i]=t.substr(r).trim(),i;if(e[i]=t.substr(r,n-r).trim(),r=n+1,4==i)return 4}}}class x{constructor(){this.minFilter=g.Nearest,this.magFilter=g.Nearest,this.uWrap=p.ClampToEdge,this.vWrap=p.ClampToEdge}setFilters(){const e=this.baseTexture,t=this.minFilter;t==g.Linear?e.scaleMode=u.M6.LINEAR:this.minFilter==g.Nearest?e.scaleMode=u.M6.NEAREST:(e.mipmap=u.E8.POW2,t==g.MipMapNearestNearest?e.scaleMode=u.M6.NEAREST:e.scaleMode=u.M6.LINEAR)}}class y extends m{}class C{constructor(){this.array=new Array}add(e){const t=this.contains(e);return this.array[0|e]=0|e,!t}contains(e){return null!=this.array[0|e]}remove(e){this.array[0|e]=void 0}clear(){this.array.length=0}}class M{constructor(){this.entries={},this.size=0}add(e){const t=this.entries[e];return this.entries[e]=!0,!t&&(this.size++,!0)}addAll(e){const t=this.size;for(let t=0,n=e.length;t<n;t++)this.add(e[t]);return t!=this.size}contains(e){return this.entries[e]}clear(){this.entries={},this.size=0}}const T=class{constructor(e=0,t=0,n=0,i=0){this.r=e,this.g=t,this.b=n,this.a=i}set(e,t,n,i){return this.r=e,this.g=t,this.b=n,this.a=i,this.clamp()}setFromColor(e){return this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a,this}setFromString(e){return e="#"==e.charAt(0)?e.substr(1):e,this.r=parseInt(e.substr(0,2),16)/255,this.g=parseInt(e.substr(2,2),16)/255,this.b=parseInt(e.substr(4,2),16)/255,this.a=8!=e.length?1:parseInt(e.substr(6,2),16)/255,this}add(e,t,n,i){return this.r+=e,this.g+=t,this.b+=n,this.a+=i,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(e,t){e.r=((4278190080&t)>>>24)/255,e.g=((16711680&t)>>>16)/255,e.b=((65280&t)>>>8)/255,e.a=(255&t)/255}static rgb888ToColor(e,t){e.r=((16711680&t)>>>16)/255,e.g=((65280&t)>>>8)/255,e.b=(255&t)/255}static fromString(e){return(new T).setFromString(e)}};let S=T;S.WHITE=new T(1,1,1,1),S.RED=new T(1,0,0,1),S.GREEN=new T(0,1,0,1),S.BLUE=new T(0,0,1,1),S.MAGENTA=new T(1,0,1,1);const A=class{static clamp(e,t,n){return e<t?t:e>n?n:e}static cosDeg(e){return Math.cos(e*A.degRad)}static sinDeg(e){return Math.sin(e*A.degRad)}static signum(e){return Math.sign(e)}static toInt(e){return e>0?Math.floor(e):Math.ceil(e)}static cbrt(e){const t=Math.pow(Math.abs(e),1/3);return e<0?-t:t}static randomTriangular(e,t){return A.randomTriangularWith(e,t,.5*(e+t))}static randomTriangularWith(e,t,n){const i=Math.random(),r=t-e;return i<=(n-e)/r?e+Math.sqrt(i*r*(n-e)):t-Math.sqrt((1-i)*r*(t-n))}static isPowerOfTwo(e){return e&&!(e&e-1)}};let I=A;I.PI=3.1415927,I.PI2=2*A.PI,I.radiansToDegrees=180/A.PI,I.radDeg=A.radiansToDegrees,I.degreesToRadians=A.PI/180,I.degRad=A.degreesToRadians;class R{apply(e,t,n){return e+(t-e)*this.applyInternal(n)}}class L extends R{constructor(e){super(),this.power=2,this.power=e}applyInternal(e){return e<=.5?Math.pow(2*e,this.power)/2:Math.pow(2*(e-1),this.power)/(this.power%2==0?-2:2)+1}}class k extends L{applyInternal(e){return Math.pow(e-1,this.power)*(this.power%2==0?-1:1)+1}}const v=class{static arrayCopy(e,t,n,i,r){for(let s=t,a=i;s<t+r;s++,a++)n[a]=e[s]}static arrayFill(e,t,n,i){for(let r=t;r<n;r++)e[r]=i}static setArraySize(e,t,n=0){const i=e.length;if(i==t)return e;if(e.length=t,i<t)for(let r=i;r<t;r++)e[r]=n;return e}static ensureArrayCapacity(e,t,n=0){return e.length>=t?e:v.setArraySize(e,t,n)}static newArray(e,t){const n=new Array(e);for(let i=0;i<e;i++)n[i]=t;return n}static newFloatArray(e){if(v.SUPPORTS_TYPED_ARRAYS)return new Float32Array(e);const t=new Array(e);for(let e=0;e<t.length;e++)t[e]=0;return t}static newShortArray(e){if(v.SUPPORTS_TYPED_ARRAYS)return new Int16Array(e);const t=new Array(e);for(let e=0;e<t.length;e++)t[e]=0;return t}static toFloatArray(e){return v.SUPPORTS_TYPED_ARRAYS?new Float32Array(e):e}static toSinglePrecision(e){return v.SUPPORTS_TYPED_ARRAYS?Math.fround(e):e}static webkit602BugfixHelper(e,t){}static contains(e,t,n=!0){for(let n=0;n<e.length;n++)if(e[n]==t)return!0;return!1}static enumValue(e,t){return e[t[0].toUpperCase()+t.slice(1)]}};let P=v;P.SUPPORTS_TYPED_ARRAYS="undefined"!=typeof Float32Array;class N{static logBones(e){for(let t=0;t<e.bones.length;t++){const n=e.bones[t],i=n.matrix;console.log(`${n.data.name}, ${i.a}, ${i.b}, ${i.c}, ${i.d}, ${i.tx}, ${i.ty}`)}}}class B{constructor(e){this.items=new Array,this.instantiator=e}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(e){e.reset&&e.reset(),this.items.push(e)}freeAll(e){for(let t=0;t<e.length;t++)this.free(e[t])}clear(){this.items.length=0}}class _{constructor(e=0,t=0){this.x=e,this.y=t}set(e,t){return this.x=e,this.y=t,this}length(){const e=this.x,t=this.y;return Math.sqrt(e*e+t*t)}normalize(){const e=this.length();return 0!=e&&(this.x/=e,this.y/=e),this}}class E{constructor(){this.maxDelta=.064,this.framesPerSecond=0,this.delta=0,this.totalTime=0,this.lastTime=Date.now()/1e3,this.frameCount=0,this.frameTime=0}update(){const e=Date.now()/1e3;this.delta=e-this.lastTime,this.frameTime+=this.delta,this.totalTime+=this.delta,this.delta>this.maxDelta&&(this.delta=this.maxDelta),this.lastTime=e,this.frameCount++,this.frameTime>1&&(this.framesPerSecond=this.frameCount/this.frameTime,this.frameTime=0,this.frameCount=0)}}class F{constructor(e=32){this.addedValues=0,this.lastValue=0,this.mean=0,this.dirty=!0,this.values=new Array(e)}hasEnoughData(){return this.addedValues>=this.values.length}addValue(e){this.addedValues<this.values.length&&this.addedValues++,this.values[this.lastValue++]=e,this.lastValue>this.values.length-1&&(this.lastValue=0),this.dirty=!0}getMean(){if(this.hasEnoughData()){if(this.dirty){let e=0;for(let t=0;t<this.values.length;t++)e+=this.values[t];this.mean=e/this.values.length,this.dirty=!1}return this.mean}return 0}}class D{constructor(){this.minX=0,this.minY=0,this.maxX=0,this.maxY=0,this.boundingBoxes=new Array,this.polygons=new Array,this.polygonPool=new B((()=>P.newFloatArray(16)))}update(e,t){if(!e)throw new Error("skeleton cannot be null.");const n=this.boundingBoxes,r=this.polygons,s=this.polygonPool,a=e.slots,o=a.length;n.length=0,s.freeAll(r),r.length=0;for(let e=0;e<o;e++){const t=a[e];if(!t.bone.active)continue;const o=t.getAttachment();if(null!=o&&o.type===i.BoundingBox){const e=o;n.push(e);let i=s.obtain();i.length!=e.worldVerticesLength&&(i=P.newFloatArray(e.worldVerticesLength)),r.push(i),e.computeWorldVertices(t,0,e.worldVerticesLength,i,0,2)}}t?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let e=Number.POSITIVE_INFINITY,t=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY,i=Number.NEGATIVE_INFINITY;const r=this.polygons;for(let s=0,a=r.length;s<a;s++){const a=r[s],o=a;for(let r=0,s=a.length;r<s;r+=2){const s=o[r],a=o[r+1];e=Math.min(e,s),t=Math.min(t,a),n=Math.max(n,s),i=Math.max(i,a)}}this.minX=e,this.minY=t,this.maxX=n,this.maxY=i}aabbContainsPoint(e,t){return e>=this.minX&&e<=this.maxX&&t>=this.minY&&t<=this.maxY}aabbIntersectsSegment(e,t,n,i){const r=this.minX,s=this.minY,a=this.maxX,o=this.maxY;if(e<=r&&n<=r||t<=s&&i<=s||e>=a&&n>=a||t>=o&&i>=o)return!1;const l=(i-t)/(n-e);let h=l*(r-e)+t;if(h>s&&h<o)return!0;if(h=l*(a-e)+t,h>s&&h<o)return!0;let u=(s-t)/l+e;return u>r&&u<a||(u=(o-t)/l+e,u>r&&u<a)}aabbIntersectsSkeleton(e){return this.minX<e.maxX&&this.maxX>e.minX&&this.minY<e.maxY&&this.maxY>e.minY}containsPoint(e,t){const n=this.polygons;for(let i=0,r=n.length;i<r;i++)if(this.containsPointPolygon(n[i],e,t))return this.boundingBoxes[i];return null}containsPointPolygon(e,t,n){const i=e,r=e.length;let s=r-2,a=!1;for(let e=0;e<r;e+=2){const r=i[e+1],o=i[s+1];if(r<n&&o>=n||o<n&&r>=n){const l=i[e];l+(n-r)/(o-r)*(i[s]-l)<t&&(a=!a)}s=e}return a}intersectsSegment(e,t,n,i){const r=this.polygons;for(let s=0,a=r.length;s<a;s++)if(this.intersectsSegmentPolygon(r[s],e,t,n,i))return this.boundingBoxes[s];return null}intersectsSegmentPolygon(e,t,n,i,r){const s=e,a=e.length,o=t-i,l=n-r,h=t*r-n*i;let u=s[a-2],c=s[a-1];for(let e=0;e<a;e+=2){const a=s[e],d=s[e+1],g=u*d-c*a,p=u-a,m=c-d,f=o*m-l*p,b=(h*p-o*g)/f;if((b>=u&&b<=a||b>=a&&b<=u)&&(b>=t&&b<=i||b>=i&&b<=t)){const e=(h*m-l*g)/f;if((e>=c&&e<=d||e>=d&&e<=c)&&(e>=n&&e<=r||e>=r&&e<=n))return!0}u=a,c=d}return!1}getPolygon(e){if(!e)throw new Error("boundingBox cannot be null.");const t=this.boundingBoxes.indexOf(e);return-1==t?null:this.polygons[t]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}}const Y={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0,REPORT_TEXTURE_LOADER_ERROR:!0};var O=n("./node_modules/@pixi/display/lib/index.mjs"),W=n("./node_modules/@pixi/sprite/lib/index.mjs"),V=n("./node_modules/@pixi/mesh-extras/lib/index.mjs"),X=n("./node_modules/@pixi/graphics/lib/index.mjs");const U=[0,0,0];class G extends W.k{constructor(){super(...arguments),this.region=null,this.attachment=null}}class H extends V.g{constructor(e,t,n,i,r){super(e,t,n,i,r),this.region=null,this.attachment=null}}const z=class extends O.mc{constructor(e){if(super(),!e)throw new Error("The spineData param is required.");if("string"==typeof e)throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=e,this.createSkeleton(e),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,t=this.skeleton.slots.length;e<t;e++){const t=this.skeleton.slots[e],n=t.getAttachment(),r=this.newContainer();if(this.slotContainers.push(r),this.addChild(r),this.tempClipContainers.push(null),n)if(n.type===i.Region){const e=n.name,i=this.createSprite(t,n,e);t.currentSprite=i,t.currentSpriteName=e,r.addChild(i)}else if(n.type===i.Mesh){const e=this.createMesh(t,n);t.currentMesh=e,t.currentMeshId=n.id,t.currentMeshName=n.name,r.addChild(e)}else n.type===i.Clipping&&(this.createGraphics(t,n),r.addChild(t.clippingContainer),r.addChild(t.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(e){e!=this._debug&&(this._debug?.unregisterSpine(this),e?.registerSpine(this),this._debug=e)}get autoUpdate(){return this._autoUpdate}set autoUpdate(e){e!==this._autoUpdate&&(this._autoUpdate=e,this.updateTransform=e?z.prototype.autoUpdateTransform:O.mc.prototype.updateTransform)}get tint(){return u.Wp.rgb2hex(this.tintRgb)}set tint(e){this.tintRgb=u.Wp.hex2rgb(e,this.tintRgb)}get delayLimit(){return(void 0!==this.localDelayLimit?this.localDelayLimit:Y.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(e){const t=this.delayLimit;if(e>t&&(e=t),this.state.update(e),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform();const n=this.skeleton.slots,r=this.color;let s=null,a=null;r?(s=r.light,a=r.dark):s=this.tintRgb;for(let e=0,t=n.length;e<t;e++){const t=n[e],r=t.getAttachment(),o=this.slotContainers[e];if(!r){o.visible=!1;continue}let l=null;r.sequence&&r.sequence.apply(t,r);let h=r.region;const c=r.color;switch(null!=r&&r.type){case i.Region:if(o.transform.setFromMatrix(t.bone.matrix),h=r.region,t.currentMesh&&(t.currentMesh.visible=!1,t.currentMesh=null,t.currentMeshId=void 0,t.currentMeshName=void 0),!h){t.currentSprite&&(t.currentSprite.renderable=!1);break}if(!t.currentSpriteName||t.currentSpriteName!==r.name){const e=r.name;if(t.currentSprite&&(t.currentSprite.visible=!1),t.sprites=t.sprites||{},void 0!==t.sprites[e])t.sprites[e].visible=!0;else{const n=this.createSprite(t,r,e);o.addChild(n)}t.currentSprite=t.sprites[e],t.currentSpriteName=e}t.currentSprite.renderable=!0,t.hackRegion||this.setSpriteRegion(r,t.currentSprite,h),t.currentSprite.color?l=t.currentSprite.color:(U[0]=s[0]*t.color.r*c.r,U[1]=s[1]*t.color.g*c.g,U[2]=s[2]*t.color.b*c.b,t.currentSprite.tint=u.Wp.rgb2hex(U)),t.currentSprite.blendMode=t.blendMode;break;case i.Mesh:if(t.currentSprite){t.currentSprite.visible=!1,t.currentSprite=null,t.currentSpriteName=void 0;const e=new u.dL;e._parentID=-1,e._worldID=o.transform._worldID,o.transform=e}if(!h){t.currentMesh&&(t.currentMesh.renderable=!1);break}const e=r.id;if(void 0===t.currentMeshId||t.currentMeshId!==e){const n=e;if(t.currentMesh&&(t.currentMesh.visible=!1),t.meshes=t.meshes||{},void 0!==t.meshes[n])t.meshes[n].visible=!0;else{const e=this.createMesh(t,r);o.addChild(e)}t.currentMesh=t.meshes[n],t.currentMeshName=r.name,t.currentMeshId=n}t.currentMesh.renderable=!0,r.computeWorldVerticesOld(t,t.currentMesh.vertices),t.currentMesh.color?l=t.currentMesh.color:(U[0]=s[0]*t.color.r*c.r,U[1]=s[1]*t.color.g*c.g,U[2]=s[2]*t.color.b*c.b,t.currentMesh.tint=u.Wp.rgb2hex(U)),t.currentMesh.blendMode=t.blendMode,t.hackRegion||this.setMeshRegion(r,t.currentMesh,h);break;case i.Clipping:t.currentGraphics||(this.createGraphics(t,r),o.addChild(t.clippingContainer),o.addChild(t.currentGraphics)),this.updateGraphics(t,r),o.alpha=1,o.visible=!0;continue;default:o.visible=!1;continue}if(o.visible=!0,l){let e=t.color.r*c.r,n=t.color.g*c.g,i=t.color.b*c.b;l.setLight(s[0]*e+a[0]*(1-e),s[1]*n+a[1]*(1-n),s[2]*i+a[2]*(1-i)),t.darkColor?(e=t.darkColor.r,n=t.darkColor.g,i=t.darkColor.b):(e=0,n=0,i=0),l.setDark(s[0]*e+a[0]*(1-e),s[1]*n+a[1]*(1-n),s[2]*i+a[2]*(1-i))}o.alpha=t.color.a}const o=this.skeleton.drawOrder;let l=null,h=null;for(let e=0,t=o.length;e<t;e++){const t=n[o[e].data.index],i=this.slotContainers[o[e].data.index];if(h||null!==i.parent&&i.parent!==this&&(i.parent.removeChild(i),i.parent=this),t.currentGraphics&&t.getAttachment())h=t.clippingContainer,l=t.getAttachment(),h.children.length=0,this.children[e]=i,l.endSlot===t.data&&(l.endSlot=null);else if(h){let n=this.tempClipContainers[e];n||(n=this.tempClipContainers[e]=this.newContainer(),n.visible=!1),this.children[e]=n,i.parent=null,h.addChild(i),l.endSlot==t.data&&(h.renderable=!0,h=null,l=null)}else this.children[e]=i}this._debug?.renderDebug(this)}setSpriteRegion(e,t,n){t.attachment===e&&t.region===n||(t.region=n,t.attachment=e,t.texture=n.texture,t.rotation=e.rotation*I.degRad,t.position.x=e.x,t.position.y=e.y,t.alpha=e.color.a,n.size?(t.scale.x=n.size.width/n.originalWidth,t.scale.y=-n.size.height/n.originalHeight):(t.scale.x=e.scaleX*e.width/n.originalWidth,t.scale.y=-e.scaleY*e.height/n.originalHeight))}setMeshRegion(e,t,n){t.attachment===e&&t.region===n||(t.region=n,t.attachment=e,t.texture=n.texture,n.texture.updateUvs(),t.uvBuffer.update(e.regionUVs))}autoUpdateTransform(){if(Y.GLOBAL_AUTO_UPDATE){this.lastTime=this.lastTime||Date.now();const e=.001*(Date.now()-this.lastTime);this.lastTime=Date.now(),this.update(e)}else this.lastTime=0;O.mc.prototype.updateTransform.call(this)}createSprite(e,t,n){let i=t.region;e.hackAttachment===t&&(i=e.hackRegion);const r=i?i.texture:null,s=this.newSprite(r);return s.anchor.set(.5),i&&this.setSpriteRegion(t,s,t.region),e.sprites=e.sprites||{},e.sprites[n]=s,s}createMesh(e,t){!t.region&&t.sequence&&t.sequence.apply(e,t);let n=t.region;e.hackAttachment===t&&(n=e.hackRegion,e.hackAttachment=null,e.hackRegion=null);const i=this.newMesh(n?n.texture:null,new Float32Array(t.regionUVs.length),t.regionUVs,new Uint16Array(t.triangles),u._4.TRIANGLES);return void 0!==i._canvasPadding&&(i._canvasPadding=1.5),i.alpha=t.color.a,i.region=t.region,n&&this.setMeshRegion(t,i,n),e.meshes=e.meshes||{},e.meshes[t.id]=i,i}createGraphics(e,t){const n=this.newGraphics(),i=new u.tS([]);return n.clear(),n.beginFill(16777215,1),n.drawPolygon(i),n.renderable=!1,e.currentGraphics=n,e.clippingContainer=this.newContainer(),e.clippingContainer.mask=e.currentGraphics,n}updateGraphics(e,t){const n=e.currentGraphics.geometry,i=n.graphicsData[0].shape.points,r=t.worldVerticesLength;i.length=r,t.computeWorldVertices(e,0,r,i,0,2),n.invalidate()}hackTextureBySlotIndex(e,t=null,n=null){const i=this.skeleton.slots[e];if(!i)return!1;const r=i.getAttachment();let s=r.region;return t?(s=new m,s.texture=t,s.size=n,i.hackRegion=s,i.hackAttachment=r):(i.hackRegion=null,i.hackAttachment=null),i.currentSprite?this.setSpriteRegion(r,i.currentSprite,s):i.currentMesh&&this.setMeshRegion(r,i.currentMesh,s),!0}hackTextureBySlotName(e,t=null,n=null){const i=this.skeleton.findSlotIndex(e);return-1!=i&&this.hackTextureBySlotIndex(i,t,n)}hackTextureAttachment(e,t,n,i=null){const r=this.skeleton.findSlotIndex(e),s=this.skeleton.getAttachmentByName(e,t);s.region.texture=n;const a=this.skeleton.slots[r];if(!a)return!1;const o=a.getAttachment();if(t===o.name){let e=s.region;return n?(e=new m,e.texture=n,e.size=i,a.hackRegion=e,a.hackAttachment=o):(a.hackRegion=null,a.hackAttachment=null),a.currentSprite&&a.currentSprite.region!=e?(this.setSpriteRegion(o,a.currentSprite,e),a.currentSprite.region=e):a.currentMesh&&a.currentMesh.region!=e&&this.setMeshRegion(o,a.currentMesh,e),!0}return!1}newContainer(){return new O.mc}newSprite(e){return new G(e)}newGraphics(){return new X.A1}newMesh(e,t,n,i,r){return new H(e,t,n,i,r)}transformHack(){return 1}hackAttachmentGroups(e,t,n){if(!e)return;const i=[],r=[];for(let s=0,a=this.skeleton.slots.length;s<a;s++){const a=this.skeleton.slots[s],o=a.currentSpriteName||a.currentMeshName||"",l=a.currentSprite||a.currentMesh;o.endsWith(e)?(l.parentGroup=t,r.push(l)):n&&l&&(l.parentGroup=n,i.push(l))}return[i,r]}destroy(e){this.debug=null;for(let t=0,n=this.skeleton.slots.length;t<n;t++){const n=this.skeleton.slots[t];for(const t in n.meshes)n.meshes[t].destroy(e);n.meshes=null;for(const t in n.sprites)n.sprites[t].destroy(e);n.sprites=null}for(let t=0,n=this.slotContainers.length;t<n;t++)this.slotContainers[t].destroy(e);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(e)}};let j=z;j.clippingPolygon=[],Object.defineProperty(j.prototype,"visible",{get(){return this._visible},set(e){e!==this._visible&&(this._visible=e,e&&(this.lastTime=0))}});class q{constructor(){this.registeredSpines=new Map,this.drawDebug=!0,this.drawMeshHull=!0,this.drawMeshTriangles=!0,this.drawBones=!0,this.drawPaths=!0,this.drawBoundingBoxes=!0,this.drawClipping=!0,this.drawRegionAttachments=!0,this.lineWidth=1,this.regionAttachmentsColor=30975,this.meshHullColor=30975,this.meshTrianglesColor=16763904,this.clippingPolygonColor=16711935,this.boundingBoxesRectColor=65280,this.boundingBoxesPolygonColor=65280,this.boundingBoxesCircleColor=65280,this.pathsCurveColor=16711680,this.pathsLineColor=16711935,this.skeletonXYColor=16711680,this.bonesColor=61132}registerSpine(e){this.registeredSpines.has(e)&&console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!",e);const t={parentDebugContainer:new O.mc,bones:new O.mc,skeletonXY:new X.A1,regionAttachmentsShape:new X.A1,meshTrianglesLine:new X.A1,meshHullLine:new X.A1,clippingPolygon:new X.A1,boundingBoxesRect:new X.A1,boundingBoxesCircle:new X.A1,boundingBoxesPolygon:new X.A1,pathsCurve:new X.A1,pathsLine:new X.A1};t.parentDebugContainer.addChild(t.bones),t.parentDebugContainer.addChild(t.skeletonXY),t.parentDebugContainer.addChild(t.regionAttachmentsShape),t.parentDebugContainer.addChild(t.meshTrianglesLine),t.parentDebugContainer.addChild(t.meshHullLine),t.parentDebugContainer.addChild(t.clippingPolygon),t.parentDebugContainer.addChild(t.boundingBoxesRect),t.parentDebugContainer.addChild(t.boundingBoxesCircle),t.parentDebugContainer.addChild(t.boundingBoxesPolygon),t.parentDebugContainer.addChild(t.pathsCurve),t.parentDebugContainer.addChild(t.pathsLine),e.addChild(t.parentDebugContainer),this.registeredSpines.set(e,t)}renderDebug(e){this.registeredSpines.has(e)||this.registerSpine(e);const t=this.registeredSpines.get(e);t.skeletonXY.clear(),t.regionAttachmentsShape.clear(),t.meshTrianglesLine.clear(),t.meshHullLine.clear(),t.clippingPolygon.clear(),t.boundingBoxesRect.clear(),t.boundingBoxesCircle.clear(),t.boundingBoxesPolygon.clear(),t.pathsCurve.clear(),t.pathsLine.clear();for(let e=t.bones.children.length;e>0;e--)t.bones.children[e-1].destroy({children:!0,texture:!0,baseTexture:!0});const n=e.scale.x||e.scale.y||1,i=this.lineWidth/n;this.drawBones&&this.drawBonesFunc(e,t,i,n),this.drawPaths&&this.drawPathsFunc(e,t,i),this.drawBoundingBoxes&&this.drawBoundingBoxesFunc(e,t,i),this.drawClipping&&this.drawClippingFunc(e,t,i),(this.drawMeshHull||this.drawMeshTriangles)&&this.drawMeshHullAndMeshTriangles(e,t,i),this.drawRegionAttachments&&this.drawRegionAttachmentsFunc(e,t,i)}drawBonesFunc(e,t,n,i){const r=e.skeleton,s=r.x,a=r.y,o=r.bones;t.skeletonXY.lineStyle(n,this.skeletonXYColor,1);for(let e=0,r=o.length;e<r;e++){const r=o[e],l=r.data.length,h=s+r.matrix.tx,u=a+r.matrix.ty,c=s+l*r.matrix.a+r.matrix.tx,d=a+l*r.matrix.b+r.matrix.ty;if("root"===r.data.name||null===r.data.parent)continue;const g=Math.abs(h-c),p=Math.abs(u-d),m=Math.pow(g,2),f=p,b=Math.pow(p,2),w=Math.sqrt(m+b),x=Math.pow(w,2),y=Math.PI/180,C=Math.acos((x+b-m)/(2*f*w))||0;if(0===w)continue;const M=new X.A1;t.bones.addChild(M);const T=w/50/i;M.beginFill(this.bonesColor,1),M.drawPolygon(0,0,0-T,w-3*T,0,w-T,0+T,w-3*T),M.endFill(),M.x=h,M.y=u,M.pivot.y=w;let S=0;h<c&&u<d?S=180*y-C:h>c&&u<d?S=180*y+C:h>c&&u>d?S=-C:h<c&&u>d?S=C:u===d&&h<c?S=90*y:u===d&&h>c?S=-90*y:h===c&&u<d?S=180*y:h===c&&u>d&&(S=0),M.rotation=S,M.lineStyle(n+T/2.4,this.bonesColor,1),M.beginFill(0,.6),M.drawCircle(0,w,1.2*T),M.endFill()}const l=3*n;t.skeletonXY.moveTo(s-l,a-l),t.skeletonXY.lineTo(s+l,a+l),t.skeletonXY.moveTo(s+l,a-l),t.skeletonXY.lineTo(s-l,a+l)}drawRegionAttachmentsFunc(e,t,n){const r=e.skeleton.slots;t.regionAttachmentsShape.lineStyle(n,this.regionAttachmentsColor,1);for(let e=0,n=r.length;e<n;e++){const n=r[e],s=n.getAttachment();if(null==s||s.type!==i.Region)continue;const a=s,o=new Float32Array(8);a.updateOffset&&a.updateOffset(),a.computeWorldVertices(n,o,0,2),t.regionAttachmentsShape.drawPolygon(Array.from(o.slice(0,8)))}}drawMeshHullAndMeshTriangles(e,t,n){const r=e.skeleton.slots;t.meshHullLine.lineStyle(n,this.meshHullColor,1),t.meshTrianglesLine.lineStyle(n,this.meshTrianglesColor,1);for(let e=0,n=r.length;e<n;e++){const n=r[e];if(!n.bone.active)continue;const s=n.getAttachment();if(null==s||s.type!==i.Mesh)continue;const a=s,o=new Float32Array(a.worldVerticesLength),l=a.triangles;let h=a.hullLength;if(a.computeWorldVertices(n,0,a.worldVerticesLength,o,0,2),this.drawMeshTriangles)for(let e=0,n=l.length;e<n;e+=3){const n=2*l[e],i=2*l[e+1],r=2*l[e+2];t.meshTrianglesLine.moveTo(o[n],o[n+1]),t.meshTrianglesLine.lineTo(o[i],o[i+1]),t.meshTrianglesLine.lineTo(o[r],o[r+1])}if(this.drawMeshHull&&h>0){h=2*(h>>1);let e=o[h-2],n=o[h-1];for(let i=0,r=h;i<r;i+=2){const r=o[i],s=o[i+1];t.meshHullLine.moveTo(r,s),t.meshHullLine.lineTo(e,n),e=r,n=s}}}}drawClippingFunc(e,t,n){const r=e.skeleton.slots;t.clippingPolygon.lineStyle(n,this.clippingPolygonColor,1);for(let e=0,n=r.length;e<n;e++){const n=r[e];if(!n.bone.active)continue;const s=n.getAttachment();if(null==s||s.type!==i.Clipping)continue;const a=s,o=a.worldVerticesLength,l=new Float32Array(o);a.computeWorldVertices(n,0,o,l,0,2),t.clippingPolygon.drawPolygon(Array.from(l))}}drawBoundingBoxesFunc(e,t,n){t.boundingBoxesRect.lineStyle(n,this.boundingBoxesRectColor,5);const i=new D;i.update(e.skeleton,!0),t.boundingBoxesRect.drawRect(i.minX,i.minY,i.getWidth(),i.getHeight());const r=i.polygons,s=(e,i,r)=>{if(t.boundingBoxesPolygon.lineStyle(n,this.boundingBoxesPolygonColor,1),t.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor,.1),r<3)throw new Error("Polygon must contain at least 3 vertices");const s=[],a=2*n;for(let n=0,i=e.length;n<i;n+=2){const i=e[n],r=e[n+1];t.boundingBoxesCircle.lineStyle(0),t.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor),t.boundingBoxesCircle.drawCircle(i,r,a),t.boundingBoxesCircle.endFill(),s.push(i,r)}t.boundingBoxesPolygon.drawPolygon(s),t.boundingBoxesPolygon.endFill()};for(let e=0,t=r.length;e<t;e++){const t=r[e];s(t,0,t.length)}}drawPathsFunc(e,t,n){const r=e.skeleton.slots;t.pathsCurve.lineStyle(n,this.pathsCurveColor,1),t.pathsLine.lineStyle(n,this.pathsLineColor,1);for(let e=0,n=r.length;e<n;e++){const n=r[e];if(!n.bone.active)continue;const s=n.getAttachment();if(null==s||s.type!==i.Path)continue;const a=s;let o=a.worldVerticesLength;const l=new Float32Array(o);a.computeWorldVertices(n,0,o,l,0,2);let h=l[2],u=l[3],c=0,d=0;if(a.closed){const e=l[0],n=l[1],i=l[o-2],r=l[o-1];c=l[o-4],d=l[o-3],t.pathsCurve.moveTo(h,u),t.pathsCurve.bezierCurveTo(e,n,i,r,c,d),t.pathsLine.moveTo(h,u),t.pathsLine.lineTo(e,n),t.pathsLine.moveTo(c,d),t.pathsLine.lineTo(i,r)}o-=4;for(let e=4;e<o;e+=6){const n=l[e],i=l[e+1],r=l[e+2],s=l[e+3];c=l[e+4],d=l[e+5],t.pathsCurve.moveTo(h,u),t.pathsCurve.bezierCurveTo(n,i,r,s,c,d),t.pathsLine.moveTo(h,u),t.pathsLine.lineTo(n,i),t.pathsLine.moveTo(c,d),t.pathsLine.lineTo(r,s),h=c,u=d}}}unregisterSpine(e){this.registeredSpines.has(e)||console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!",e),this.registeredSpines.get(e).parentDebugContainer.destroy({baseTexture:!0,children:!0,texture:!0}),this.registeredSpines.delete(e)}}}}]);